/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/prop_attribute_arg.h>
CPS_START_NAMESPACE

bool_t
vml_AttrType (VML *vmls, char *name,AttrType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,AttrType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map AttrType_map[] = {
	{"AttrType","GENERIC_PROP_ATTR",GENERIC_PROP_ATTR},
	{"AttrType","POINT_SOURCE_ATTR",POINT_SOURCE_ATTR},
	{"AttrType","WALL_SOURCE_ATTR",WALL_SOURCE_ATTR},
	{"AttrType","VOLUME_SOURCE_ATTR",VOLUME_SOURCE_ATTR},
	{"AttrType","MOMENTUM_ATTR",MOMENTUM_ATTR},
	{"AttrType","PROP_IO_ATTR",PROP_IO_ATTR},
	{"AttrType","GPARITY_FLAVOR_ATTR",GPARITY_FLAVOR_ATTR},
	{"AttrType","CG_ATTR",CG_ATTR},
	{"AttrType","GAUGE_FIX_ATTR",GAUGE_FIX_ATTR},
	{"AttrType","MOM_COS_ATTR",MOM_COS_ATTR},
	{"AttrType","PROP_COMBINATION_ATTR",PROP_COMBINATION_ATTR},
	{"AttrType","GPARITY_OTHER_FLAV_PROP_ATTR",GPARITY_OTHER_FLAV_PROP_ATTR},
	{"AttrType","TWISTED_BC_ATTR",TWISTED_BC_ATTR},
	{"AttrType","STORE_MIDPROP_ATTR",STORE_MIDPROP_ATTR},
	{NULL,NULL,0}
};

bool_t
vml_PropagatorType (VML *vmls, char *name,PropagatorType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,PropagatorType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map PropagatorType_map[] = {
	{"PropagatorType","QPROPW_TYPE",QPROPW_TYPE},
	{"PropagatorType","A2A_PROP_TYPE",A2A_PROP_TYPE},
	{NULL,NULL,0}
};

bool_t
vml_GenericPropAttrArg (VML *vmls, char *name,GenericPropAttrArg *objp)
{
	 vml_struct_begin(vmls,"GenericPropAttrArg",name);
	int i;
	 if (!vml_PropagatorType (vmls, "type", &objp->type))
		 return FALSE;
	 if (!vml_string (vmls, "tag", &objp->tag, ~0))
		 return FALSE;
	 if (!vml_Float (vmls, "mass", &objp->mass))
		 return FALSE;
	 if (!vml_vector (vmls, "bc", (char *)objp->bc, 4,
		sizeof (BndCndType), (vmlproc_t) vml_BndCndType))
		 return FALSE;
	 vml_struct_end(vmls,"GenericPropAttrArg",name);
	return TRUE;
}
void rpc_deepcopy<GenericPropAttrArg>::doit(GenericPropAttrArg &into, GenericPropAttrArg const &from){
	  rpc_deepcopy<PropagatorType>::doit(into.type,from.type);
	  rpc_deepcopy<char *>::doit(into.tag,from.tag,strlen(from.tag)+1);
	  rpc_deepcopy<Float>::doit(into.mass,from.mass);
	  for(int i=0;i<4;i++) rpc_deepcopy<BndCndType>::doit(into.bc[i],from.bc[i]);
}
void GenericPropAttrArg::deep_copy(GenericPropAttrArg const &rhs){
	rpc_deepcopy<GenericPropAttrArg>::doit(*this,rhs);
}
void rpc_print<GenericPropAttrArg>::doit(GenericPropAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<PropagatorType>::doit(what.type,spaces+" type = ");
	rpc_print<char *>::doit(what.tag,strlen(what.tag)+1,spaces+" tag = ");
	rpc_print<Float>::doit(what.mass,spaces+" mass = ");
	{
	  std::ostringstream os; os << spaces << " bc[4] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<4;i++){ std::ostringstream tos; tos << newspaces << " bc["<<i<<"] = "; rpc_print<BndCndType>::doit(what.bc[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void GenericPropAttrArg::print(const std::string &prefix){
	rpc_print<GenericPropAttrArg>::doit(*this,prefix);
}

bool_t
vml_PointSourceAttrArg (VML *vmls, char *name,PointSourceAttrArg *objp)
{
	 vml_struct_begin(vmls,"PointSourceAttrArg",name);
	int i;
	 if (!vml_vector (vmls, "pos", (char *)objp->pos, 4,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 vml_struct_end(vmls,"PointSourceAttrArg",name);
	return TRUE;
}
void rpc_deepcopy<PointSourceAttrArg>::doit(PointSourceAttrArg &into, PointSourceAttrArg const &from){
	  for(int i=0;i<4;i++) rpc_deepcopy<int>::doit(into.pos[i],from.pos[i]);
}
void PointSourceAttrArg::deep_copy(PointSourceAttrArg const &rhs){
	rpc_deepcopy<PointSourceAttrArg>::doit(*this,rhs);
}
void rpc_print<PointSourceAttrArg>::doit(PointSourceAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	{
	  std::ostringstream os; os << spaces << " pos[4] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<4;i++){ std::ostringstream tos; tos << newspaces << " pos["<<i<<"] = "; rpc_print<int>::doit(what.pos[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void PointSourceAttrArg::print(const std::string &prefix){
	rpc_print<PointSourceAttrArg>::doit(*this,prefix);
}

bool_t
vml_WallSourceAttrArg (VML *vmls, char *name,WallSourceAttrArg *objp)
{
	 vml_struct_begin(vmls,"WallSourceAttrArg",name);
	 if (!vml_int (vmls, "t", &objp->t))
		 return FALSE;
	 vml_struct_end(vmls,"WallSourceAttrArg",name);
	return TRUE;
}
void rpc_print<WallSourceAttrArg>::doit(WallSourceAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.t,spaces+" t = ");
	std::cout << spaces << "}\n";
}
void WallSourceAttrArg::print(const std::string &prefix){
	rpc_print<WallSourceAttrArg>::doit(*this,prefix);
}

bool_t
vml_VolumeSourceAttrArg (VML *vmls, char *name,VolumeSourceAttrArg *objp)
{
	 vml_struct_begin(vmls,"VolumeSourceAttrArg",name);
	 vml_struct_end(vmls,"VolumeSourceAttrArg",name);
	return TRUE;
}
void rpc_print<VolumeSourceAttrArg>::doit(VolumeSourceAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	std::cout << spaces << "}\n";
}
void VolumeSourceAttrArg::print(const std::string &prefix){
	rpc_print<VolumeSourceAttrArg>::doit(*this,prefix);
}

bool_t
vml_MomentumAttrArg (VML *vmls, char *name,MomentumAttrArg *objp)
{
	 vml_struct_begin(vmls,"MomentumAttrArg",name);
	int i;
	 if (!vml_vector (vmls, "p", (char *)objp->p, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 vml_struct_end(vmls,"MomentumAttrArg",name);
	return TRUE;
}
void rpc_deepcopy<MomentumAttrArg>::doit(MomentumAttrArg &into, MomentumAttrArg const &from){
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.p[i],from.p[i]);
}
void MomentumAttrArg::deep_copy(MomentumAttrArg const &rhs){
	rpc_deepcopy<MomentumAttrArg>::doit(*this,rhs);
}
void rpc_print<MomentumAttrArg>::doit(MomentumAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	{
	  std::ostringstream os; os << spaces << " p[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p["<<i<<"] = "; rpc_print<int>::doit(what.p[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void MomentumAttrArg::print(const std::string &prefix){
	rpc_print<MomentumAttrArg>::doit(*this,prefix);
}

bool_t
vml_PropIOAttrArg (VML *vmls, char *name,PropIOAttrArg *objp)
{
	 vml_struct_begin(vmls,"PropIOAttrArg",name);
	 if (!vml_string (vmls, "qio_filename", &objp->qio_filename, ~0))
		 return FALSE;
	 if (!vml_bool (vmls, "prop_on_disk", &objp->prop_on_disk))
		 return FALSE;
	 if (!vml_int (vmls, "save_to_disk", &objp->save_to_disk))
		 return FALSE;
	 vml_struct_end(vmls,"PropIOAttrArg",name);
	return TRUE;
}
void rpc_deepcopy<PropIOAttrArg>::doit(PropIOAttrArg &into, PropIOAttrArg const &from){
	  rpc_deepcopy<char *>::doit(into.qio_filename,from.qio_filename,strlen(from.qio_filename)+1);
	  rpc_deepcopy<bool_t>::doit(into.prop_on_disk,from.prop_on_disk);
	  rpc_deepcopy<int>::doit(into.save_to_disk,from.save_to_disk);
}
void PropIOAttrArg::deep_copy(PropIOAttrArg const &rhs){
	rpc_deepcopy<PropIOAttrArg>::doit(*this,rhs);
}
void rpc_print<PropIOAttrArg>::doit(PropIOAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.qio_filename,strlen(what.qio_filename)+1,spaces+" qio_filename = ");
	rpc_print<bool_t>::doit(what.prop_on_disk,spaces+" prop_on_disk = ");
	rpc_print<int>::doit(what.save_to_disk,spaces+" save_to_disk = ");
	std::cout << spaces << "}\n";
}
void PropIOAttrArg::print(const std::string &prefix){
	rpc_print<PropIOAttrArg>::doit(*this,prefix);
}

bool_t
vml_GparityFlavorAttrArg (VML *vmls, char *name,GparityFlavorAttrArg *objp)
{
	 vml_struct_begin(vmls,"GparityFlavorAttrArg",name);
	 if (!vml_int (vmls, "flavor", &objp->flavor))
		 return FALSE;
	 vml_struct_end(vmls,"GparityFlavorAttrArg",name);
	return TRUE;
}
void rpc_print<GparityFlavorAttrArg>::doit(GparityFlavorAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.flavor,spaces+" flavor = ");
	std::cout << spaces << "}\n";
}
void GparityFlavorAttrArg::print(const std::string &prefix){
	rpc_print<GparityFlavorAttrArg>::doit(*this,prefix);
}

bool_t
vml_CGAttrArg (VML *vmls, char *name,CGAttrArg *objp)
{
	 vml_struct_begin(vmls,"CGAttrArg",name);
	 if (!vml_int (vmls, "max_num_iter", &objp->max_num_iter))
		 return FALSE;
	 if (!vml_Float (vmls, "stop_rsd", &objp->stop_rsd))
		 return FALSE;
	 if (!vml_Float (vmls, "true_rsd", &objp->true_rsd))
		 return FALSE;
	 vml_struct_end(vmls,"CGAttrArg",name);
	return TRUE;
}
void rpc_print<CGAttrArg>::doit(CGAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.max_num_iter,spaces+" max_num_iter = ");
	rpc_print<Float>::doit(what.stop_rsd,spaces+" stop_rsd = ");
	rpc_print<Float>::doit(what.true_rsd,spaces+" true_rsd = ");
	std::cout << spaces << "}\n";
}
void CGAttrArg::print(const std::string &prefix){
	rpc_print<CGAttrArg>::doit(*this,prefix);
}

bool_t
vml_GaugeFixAttrArg (VML *vmls, char *name,GaugeFixAttrArg *objp)
{
	 vml_struct_begin(vmls,"GaugeFixAttrArg",name);
	 if (!vml_int (vmls, "gauge_fix_src", &objp->gauge_fix_src))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_fix_snk", &objp->gauge_fix_snk))
		 return FALSE;
	 vml_struct_end(vmls,"GaugeFixAttrArg",name);
	return TRUE;
}
void rpc_print<GaugeFixAttrArg>::doit(GaugeFixAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.gauge_fix_src,spaces+" gauge_fix_src = ");
	rpc_print<int>::doit(what.gauge_fix_snk,spaces+" gauge_fix_snk = ");
	std::cout << spaces << "}\n";
}
void GaugeFixAttrArg::print(const std::string &prefix){
	rpc_print<GaugeFixAttrArg>::doit(*this,prefix);
}

bool_t
vml_MomCosAttrArg (VML *vmls, char *name,MomCosAttrArg *objp)
{
	 vml_struct_begin(vmls,"MomCosAttrArg",name);
	 vml_struct_end(vmls,"MomCosAttrArg",name);
	return TRUE;
}
void rpc_print<MomCosAttrArg>::doit(MomCosAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	std::cout << spaces << "}\n";
}
void MomCosAttrArg::print(const std::string &prefix){
	rpc_print<MomCosAttrArg>::doit(*this,prefix);
}

bool_t
vml_GparityOtherFlavPropAttrArg (VML *vmls, char *name,GparityOtherFlavPropAttrArg *objp)
{
	 vml_struct_begin(vmls,"GparityOtherFlavPropAttrArg",name);
	 if (!vml_string (vmls, "tag", &objp->tag, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"GparityOtherFlavPropAttrArg",name);
	return TRUE;
}
void rpc_deepcopy<GparityOtherFlavPropAttrArg>::doit(GparityOtherFlavPropAttrArg &into, GparityOtherFlavPropAttrArg const &from){
	  rpc_deepcopy<char *>::doit(into.tag,from.tag,strlen(from.tag)+1);
}
void GparityOtherFlavPropAttrArg::deep_copy(GparityOtherFlavPropAttrArg const &rhs){
	rpc_deepcopy<GparityOtherFlavPropAttrArg>::doit(*this,rhs);
}
void rpc_print<GparityOtherFlavPropAttrArg>::doit(GparityOtherFlavPropAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.tag,strlen(what.tag)+1,spaces+" tag = ");
	std::cout << spaces << "}\n";
}
void GparityOtherFlavPropAttrArg::print(const std::string &prefix){
	rpc_print<GparityOtherFlavPropAttrArg>::doit(*this,prefix);
}

bool_t
vml_TwistedBcAttrArg (VML *vmls, char *name,TwistedBcAttrArg *objp)
{
	 vml_struct_begin(vmls,"TwistedBcAttrArg",name);
	int i;
	 if (!vml_vector (vmls, "theta", (char *)objp->theta, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 vml_struct_end(vmls,"TwistedBcAttrArg",name);
	return TRUE;
}
void rpc_deepcopy<TwistedBcAttrArg>::doit(TwistedBcAttrArg &into, TwistedBcAttrArg const &from){
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.theta[i],from.theta[i]);
}
void TwistedBcAttrArg::deep_copy(TwistedBcAttrArg const &rhs){
	rpc_deepcopy<TwistedBcAttrArg>::doit(*this,rhs);
}
void rpc_print<TwistedBcAttrArg>::doit(TwistedBcAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	{
	  std::ostringstream os; os << spaces << " theta[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " theta["<<i<<"] = "; rpc_print<int>::doit(what.theta[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void TwistedBcAttrArg::print(const std::string &prefix){
	rpc_print<TwistedBcAttrArg>::doit(*this,prefix);
}

bool_t
vml_StoreMidpropAttrArg (VML *vmls, char *name,StoreMidpropAttrArg *objp)
{
	 vml_struct_begin(vmls,"StoreMidpropAttrArg",name);
	 vml_struct_end(vmls,"StoreMidpropAttrArg",name);
	return TRUE;
}
void rpc_print<StoreMidpropAttrArg>::doit(StoreMidpropAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	std::cout << spaces << "}\n";
}
void StoreMidpropAttrArg::print(const std::string &prefix){
	rpc_print<StoreMidpropAttrArg>::doit(*this,prefix);
}

bool_t
vml_PropCombination (VML *vmls, char *name,PropCombination *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,PropCombination_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map PropCombination_map[] = {
	{"PropCombination","A_PLUS_B",A_PLUS_B},
	{"PropCombination","A_MINUS_B",A_MINUS_B},
	{NULL,NULL,0}
};

bool_t
vml_PropCombinationAttrArg (VML *vmls, char *name,PropCombinationAttrArg *objp)
{
	 vml_struct_begin(vmls,"PropCombinationAttrArg",name);
	 if (!vml_string (vmls, "prop_A", &objp->prop_A, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_B", &objp->prop_B, ~0))
		 return FALSE;
	 if (!vml_PropCombination (vmls, "combination", &objp->combination))
		 return FALSE;
	 vml_struct_end(vmls,"PropCombinationAttrArg",name);
	return TRUE;
}
void rpc_deepcopy<PropCombinationAttrArg>::doit(PropCombinationAttrArg &into, PropCombinationAttrArg const &from){
	  rpc_deepcopy<char *>::doit(into.prop_A,from.prop_A,strlen(from.prop_A)+1);
	  rpc_deepcopy<char *>::doit(into.prop_B,from.prop_B,strlen(from.prop_B)+1);
	  rpc_deepcopy<PropCombination>::doit(into.combination,from.combination);
}
void PropCombinationAttrArg::deep_copy(PropCombinationAttrArg const &rhs){
	rpc_deepcopy<PropCombinationAttrArg>::doit(*this,rhs);
}
void rpc_print<PropCombinationAttrArg>::doit(PropCombinationAttrArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_A,strlen(what.prop_A)+1,spaces+" prop_A = ");
	rpc_print<char *>::doit(what.prop_B,strlen(what.prop_B)+1,spaces+" prop_B = ");
	rpc_print<PropCombination>::doit(what.combination,spaces+" combination = ");
	std::cout << spaces << "}\n";
}
void PropCombinationAttrArg::print(const std::string &prefix){
	rpc_print<PropCombinationAttrArg>::doit(*this,prefix);
}

bool_t
vml_AttributeContainer (VML *vmls, char *name,AttributeContainer *objp)
{
	 if (!vml_AttrType (vmls, "type", &objp->type))
		 return FALSE;
	switch (objp->type) {
	case GENERIC_PROP_ATTR:
		 if (!vml_GenericPropAttrArg (vmls, "generic_prop_attr", &objp->AttributeContainer_u.generic_prop_attr))
			 return FALSE;
		break;
	case POINT_SOURCE_ATTR:
		 if (!vml_PointSourceAttrArg (vmls, "point_source_attr", &objp->AttributeContainer_u.point_source_attr))
			 return FALSE;
		break;
	case WALL_SOURCE_ATTR:
		 if (!vml_WallSourceAttrArg (vmls, "wall_source_attr", &objp->AttributeContainer_u.wall_source_attr))
			 return FALSE;
		break;
	case VOLUME_SOURCE_ATTR:
		 if (!vml_VolumeSourceAttrArg (vmls, "volume_source_attr", &objp->AttributeContainer_u.volume_source_attr))
			 return FALSE;
		break;
	case MOMENTUM_ATTR:
		 if (!vml_MomentumAttrArg (vmls, "momentum_attr", &objp->AttributeContainer_u.momentum_attr))
			 return FALSE;
		break;
	case PROP_IO_ATTR:
		 if (!vml_PropIOAttrArg (vmls, "prop_io_attr", &objp->AttributeContainer_u.prop_io_attr))
			 return FALSE;
		break;
	case GPARITY_FLAVOR_ATTR:
		 if (!vml_GparityFlavorAttrArg (vmls, "gparity_flavor_attr", &objp->AttributeContainer_u.gparity_flavor_attr))
			 return FALSE;
		break;
	case CG_ATTR:
		 if (!vml_CGAttrArg (vmls, "cg_attr", &objp->AttributeContainer_u.cg_attr))
			 return FALSE;
		break;
	case GAUGE_FIX_ATTR:
		 if (!vml_GaugeFixAttrArg (vmls, "gauge_fix_attr", &objp->AttributeContainer_u.gauge_fix_attr))
			 return FALSE;
		break;
	case MOM_COS_ATTR:
		 if (!vml_MomCosAttrArg (vmls, "mom_cos_attr", &objp->AttributeContainer_u.mom_cos_attr))
			 return FALSE;
		break;
	case PROP_COMBINATION_ATTR:
		 if (!vml_PropCombinationAttrArg (vmls, "prop_combination_attr", &objp->AttributeContainer_u.prop_combination_attr))
			 return FALSE;
		break;
	case GPARITY_OTHER_FLAV_PROP_ATTR:
		 if (!vml_GparityOtherFlavPropAttrArg (vmls, "gparity_other_flav_prop_attr", &objp->AttributeContainer_u.gparity_other_flav_prop_attr))
			 return FALSE;
		break;
	case TWISTED_BC_ATTR:
		 if (!vml_TwistedBcAttrArg (vmls, "twisted_bc_attr", &objp->AttributeContainer_u.twisted_bc_attr))
			 return FALSE;
		break;
	case STORE_MIDPROP_ATTR:
		 if (!vml_StoreMidpropAttrArg (vmls, "store_midprop_attr", &objp->AttributeContainer_u.store_midprop_attr))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
template <> AttrType AttributeContainer::type_map<GenericPropAttrArg>(){
	 return GENERIC_PROP_ATTR;
}
template <> AttrType AttributeContainer::type_map<PointSourceAttrArg>(){
	 return POINT_SOURCE_ATTR;
}
template <> AttrType AttributeContainer::type_map<WallSourceAttrArg>(){
	 return WALL_SOURCE_ATTR;
}
template <> AttrType AttributeContainer::type_map<VolumeSourceAttrArg>(){
	 return VOLUME_SOURCE_ATTR;
}
template <> AttrType AttributeContainer::type_map<MomentumAttrArg>(){
	 return MOMENTUM_ATTR;
}
template <> AttrType AttributeContainer::type_map<PropIOAttrArg>(){
	 return PROP_IO_ATTR;
}
template <> AttrType AttributeContainer::type_map<GparityFlavorAttrArg>(){
	 return GPARITY_FLAVOR_ATTR;
}
template <> AttrType AttributeContainer::type_map<CGAttrArg>(){
	 return CG_ATTR;
}
template <> AttrType AttributeContainer::type_map<GaugeFixAttrArg>(){
	 return GAUGE_FIX_ATTR;
}
template <> AttrType AttributeContainer::type_map<MomCosAttrArg>(){
	 return MOM_COS_ATTR;
}
template <> AttrType AttributeContainer::type_map<PropCombinationAttrArg>(){
	 return PROP_COMBINATION_ATTR;
}
template <> AttrType AttributeContainer::type_map<GparityOtherFlavPropAttrArg>(){
	 return GPARITY_OTHER_FLAV_PROP_ATTR;
}
template <> AttrType AttributeContainer::type_map<TwistedBcAttrArg>(){
	 return TWISTED_BC_ATTR;
}
template <> AttrType AttributeContainer::type_map<StoreMidpropAttrArg>(){
	 return STORE_MIDPROP_ATTR;
}
void rpc_deepcopy<AttributeContainer>::doit(AttributeContainer &into, AttributeContainer const &from){
	  into.type = from.type;
	  switch(from.type){
	    case GENERIC_PROP_ATTR:
	      rpc_deepcopy<GenericPropAttrArg>::doit(into.AttributeContainer_u.generic_prop_attr,from.AttributeContainer_u.generic_prop_attr); break;
	    case POINT_SOURCE_ATTR:
	      rpc_deepcopy<PointSourceAttrArg>::doit(into.AttributeContainer_u.point_source_attr,from.AttributeContainer_u.point_source_attr); break;
	    case WALL_SOURCE_ATTR:
	      rpc_deepcopy<WallSourceAttrArg>::doit(into.AttributeContainer_u.wall_source_attr,from.AttributeContainer_u.wall_source_attr); break;
	    case VOLUME_SOURCE_ATTR:
	      rpc_deepcopy<VolumeSourceAttrArg>::doit(into.AttributeContainer_u.volume_source_attr,from.AttributeContainer_u.volume_source_attr); break;
	    case MOMENTUM_ATTR:
	      rpc_deepcopy<MomentumAttrArg>::doit(into.AttributeContainer_u.momentum_attr,from.AttributeContainer_u.momentum_attr); break;
	    case PROP_IO_ATTR:
	      rpc_deepcopy<PropIOAttrArg>::doit(into.AttributeContainer_u.prop_io_attr,from.AttributeContainer_u.prop_io_attr); break;
	    case GPARITY_FLAVOR_ATTR:
	      rpc_deepcopy<GparityFlavorAttrArg>::doit(into.AttributeContainer_u.gparity_flavor_attr,from.AttributeContainer_u.gparity_flavor_attr); break;
	    case CG_ATTR:
	      rpc_deepcopy<CGAttrArg>::doit(into.AttributeContainer_u.cg_attr,from.AttributeContainer_u.cg_attr); break;
	    case GAUGE_FIX_ATTR:
	      rpc_deepcopy<GaugeFixAttrArg>::doit(into.AttributeContainer_u.gauge_fix_attr,from.AttributeContainer_u.gauge_fix_attr); break;
	    case MOM_COS_ATTR:
	      rpc_deepcopy<MomCosAttrArg>::doit(into.AttributeContainer_u.mom_cos_attr,from.AttributeContainer_u.mom_cos_attr); break;
	    case PROP_COMBINATION_ATTR:
	      rpc_deepcopy<PropCombinationAttrArg>::doit(into.AttributeContainer_u.prop_combination_attr,from.AttributeContainer_u.prop_combination_attr); break;
	    case GPARITY_OTHER_FLAV_PROP_ATTR:
	      rpc_deepcopy<GparityOtherFlavPropAttrArg>::doit(into.AttributeContainer_u.gparity_other_flav_prop_attr,from.AttributeContainer_u.gparity_other_flav_prop_attr); break;
	    case TWISTED_BC_ATTR:
	      rpc_deepcopy<TwistedBcAttrArg>::doit(into.AttributeContainer_u.twisted_bc_attr,from.AttributeContainer_u.twisted_bc_attr); break;
	    case STORE_MIDPROP_ATTR:
	      rpc_deepcopy<StoreMidpropAttrArg>::doit(into.AttributeContainer_u.store_midprop_attr,from.AttributeContainer_u.store_midprop_attr); break;
	  };
}
void AttributeContainer::deep_copy(AttributeContainer const &rhs){
	rpc_deepcopy<AttributeContainer>::doit(*this,rhs);
}
void rpc_print<AttributeContainer>::doit(AttributeContainer const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	  switch(what.type){
	    case GENERIC_PROP_ATTR:
	      rpc_print<GenericPropAttrArg>::doit(what.AttributeContainer_u.generic_prop_attr,spaces+" union AttributeContainer_u.generic_prop_attr = "); break;
	    case POINT_SOURCE_ATTR:
	      rpc_print<PointSourceAttrArg>::doit(what.AttributeContainer_u.point_source_attr,spaces+" union AttributeContainer_u.point_source_attr = "); break;
	    case WALL_SOURCE_ATTR:
	      rpc_print<WallSourceAttrArg>::doit(what.AttributeContainer_u.wall_source_attr,spaces+" union AttributeContainer_u.wall_source_attr = "); break;
	    case VOLUME_SOURCE_ATTR:
	      rpc_print<VolumeSourceAttrArg>::doit(what.AttributeContainer_u.volume_source_attr,spaces+" union AttributeContainer_u.volume_source_attr = "); break;
	    case MOMENTUM_ATTR:
	      rpc_print<MomentumAttrArg>::doit(what.AttributeContainer_u.momentum_attr,spaces+" union AttributeContainer_u.momentum_attr = "); break;
	    case PROP_IO_ATTR:
	      rpc_print<PropIOAttrArg>::doit(what.AttributeContainer_u.prop_io_attr,spaces+" union AttributeContainer_u.prop_io_attr = "); break;
	    case GPARITY_FLAVOR_ATTR:
	      rpc_print<GparityFlavorAttrArg>::doit(what.AttributeContainer_u.gparity_flavor_attr,spaces+" union AttributeContainer_u.gparity_flavor_attr = "); break;
	    case CG_ATTR:
	      rpc_print<CGAttrArg>::doit(what.AttributeContainer_u.cg_attr,spaces+" union AttributeContainer_u.cg_attr = "); break;
	    case GAUGE_FIX_ATTR:
	      rpc_print<GaugeFixAttrArg>::doit(what.AttributeContainer_u.gauge_fix_attr,spaces+" union AttributeContainer_u.gauge_fix_attr = "); break;
	    case MOM_COS_ATTR:
	      rpc_print<MomCosAttrArg>::doit(what.AttributeContainer_u.mom_cos_attr,spaces+" union AttributeContainer_u.mom_cos_attr = "); break;
	    case PROP_COMBINATION_ATTR:
	      rpc_print<PropCombinationAttrArg>::doit(what.AttributeContainer_u.prop_combination_attr,spaces+" union AttributeContainer_u.prop_combination_attr = "); break;
	    case GPARITY_OTHER_FLAV_PROP_ATTR:
	      rpc_print<GparityOtherFlavPropAttrArg>::doit(what.AttributeContainer_u.gparity_other_flav_prop_attr,spaces+" union AttributeContainer_u.gparity_other_flav_prop_attr = "); break;
	    case TWISTED_BC_ATTR:
	      rpc_print<TwistedBcAttrArg>::doit(what.AttributeContainer_u.twisted_bc_attr,spaces+" union AttributeContainer_u.twisted_bc_attr = "); break;
	    case STORE_MIDPROP_ATTR:
	      rpc_print<StoreMidpropAttrArg>::doit(what.AttributeContainer_u.store_midprop_attr,spaces+" union AttributeContainer_u.store_midprop_attr = "); break;
	  };
	std::cout << spaces << "}\n";
}
void AttributeContainer::print(const std::string &prefix){
	rpc_print<AttributeContainer>::doit(*this,prefix);
}
	 bool PropagatorArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool PropagatorArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool PropagatorArg::Vml(VML *vmls,char *instance){
		 if(!vml_PropagatorArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_PropagatorArg (VML *vmls, char *name,PropagatorArg *objp)
{
	 vml_class_begin(vmls,"PropagatorArg",name);
	 if (!vml_GenericPropAttrArg (vmls, "generics", &objp->generics))
		 return FALSE;
	 if (!vml_array (vmls, "attributes", (char **)&objp->attributes.attributes_val, (u_int *) &objp->attributes.attributes_len, ~0,
		sizeof (AttributeContainer), (vmlproc_t) vml_AttributeContainer))
		 return FALSE;
	 vml_class_end(vmls,"PropagatorArg",name);
	return TRUE;
}
void rpc_deepcopy<PropagatorArg>::doit(PropagatorArg &into, PropagatorArg const &from){
	  rpc_deepcopy<GenericPropAttrArg>::doit(into.generics,from.generics);
	  into.attributes.attributes_len = from.attributes.attributes_len;
	  rpc_deepcopy<AttributeContainer *>::doit(into.attributes.attributes_val,from.attributes.attributes_val,from.attributes.attributes_len);
}
void PropagatorArg::deep_copy(PropagatorArg const &rhs){
	rpc_deepcopy<PropagatorArg>::doit(*this,rhs);
}
void rpc_print<PropagatorArg>::doit(PropagatorArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<GenericPropAttrArg>::doit(what.generics,spaces+" generics = ");
	rpc_print<AttributeContainer *>::doit(what.attributes.attributes_val,what.attributes.attributes_len,spaces+" attributes = ");
	std::cout << spaces << "}\n";
}
void PropagatorArg::print(const std::string &prefix){
	rpc_print<PropagatorArg>::doit(*this,prefix);
}
	 bool JobPropagatorArgs::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool JobPropagatorArgs::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool JobPropagatorArgs::Vml(VML *vmls,char *instance){
		 if(!vml_JobPropagatorArgs(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_JobPropagatorArgs (VML *vmls, char *name,JobPropagatorArgs *objp)
{
	 vml_class_begin(vmls,"JobPropagatorArgs",name);
	 if (!vml_array (vmls, "props", (char **)&objp->props.props_val, (u_int *) &objp->props.props_len, ~0,
		sizeof (PropagatorArg), (vmlproc_t) vml_PropagatorArg))
		 return FALSE;
	 vml_class_end(vmls,"JobPropagatorArgs",name);
	return TRUE;
}
void rpc_deepcopy<JobPropagatorArgs>::doit(JobPropagatorArgs &into, JobPropagatorArgs const &from){
	  into.props.props_len = from.props.props_len;
	  rpc_deepcopy<PropagatorArg *>::doit(into.props.props_val,from.props.props_val,from.props.props_len);
}
void JobPropagatorArgs::deep_copy(JobPropagatorArgs const &rhs){
	rpc_deepcopy<JobPropagatorArgs>::doit(*this,rhs);
}
void rpc_print<JobPropagatorArgs>::doit(JobPropagatorArgs const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<PropagatorArg *>::doit(what.props.props_val,what.props.props_len,spaces+" props = ");
	std::cout << spaces << "}\n";
}
void JobPropagatorArgs::print(const std::string &prefix){
	rpc_print<JobPropagatorArgs>::doit(*this,prefix);
}
CPS_END_NAMESPACE
