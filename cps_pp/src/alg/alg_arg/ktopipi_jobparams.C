/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/ktopipi_jobparams.h>
CPS_START_NAMESPACE
	 bool ZMobiusParams::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool ZMobiusParams::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool ZMobiusParams::Vml(VML *vmls,char *instance){
		 if(!vml_ZMobiusParams(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_ZMobiusParams (VML *vmls, char *name,ZMobiusParams *objp)
{
	 vml_class_begin(vmls,"ZMobiusParams",name);
	 if (!vml_A2A_ZMobiusGammaSource (vmls, "gamma_src", &objp->gamma_src))
		 return FALSE;
	 if (!vml_double (vmls, "compute_lambda_max", &objp->compute_lambda_max))
		 return FALSE;
	 if (!vml_array (vmls, "gamma_real", (char **)&objp->gamma_real.gamma_real_val, (u_int *) &objp->gamma_real.gamma_real_len, ~0,
		sizeof (double), (vmlproc_t) vml_double))
		 return FALSE;
	 if (!vml_array (vmls, "gamma_imag", (char **)&objp->gamma_imag.gamma_imag_val, (u_int *) &objp->gamma_imag.gamma_imag_len, ~0,
		sizeof (double), (vmlproc_t) vml_double))
		 return FALSE;
	 vml_class_end(vmls,"ZMobiusParams",name);
	return TRUE;
}
void rpc_print<ZMobiusParams>::doit(ZMobiusParams const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<A2A_ZMobiusGammaSource>::doit(what.gamma_src,spaces+" gamma_src = ");
	rpc_print<double>::doit(what.compute_lambda_max,spaces+" compute_lambda_max = ");
	rpc_print<double *>::doit(what.gamma_real.gamma_real_val,what.gamma_real.gamma_real_len,spaces+" gamma_real = ");
	rpc_print<double *>::doit(what.gamma_imag.gamma_imag_val,what.gamma_imag.gamma_imag_len,spaces+" gamma_imag = ");
	std::cout << spaces << "}\n";
}
void ZMobiusParams::print(const std::string &prefix){
	rpc_print<ZMobiusParams>::doit(*this,prefix);
}
void rpc_deepcopy<ZMobiusParams>::doit(ZMobiusParams &into, ZMobiusParams const &from){
	  rpc_deepcopy<A2A_ZMobiusGammaSource>::doit(into.gamma_src,from.gamma_src);
	  rpc_deepcopy<double>::doit(into.compute_lambda_max,from.compute_lambda_max);
	  into.gamma_real.gamma_real_len = from.gamma_real.gamma_real_len;
	  rpc_deepcopy<double *>::doit(into.gamma_real.gamma_real_val,from.gamma_real.gamma_real_val,from.gamma_real.gamma_real_len);
	  into.gamma_imag.gamma_imag_len = from.gamma_imag.gamma_imag_len;
	  rpc_deepcopy<double *>::doit(into.gamma_imag.gamma_imag_val,from.gamma_imag.gamma_imag_val,from.gamma_imag.gamma_imag_len);
}
void ZMobiusParams::deep_copy(ZMobiusParams const &rhs){
	rpc_deepcopy<ZMobiusParams>::doit(*this,rhs);
}
	 bool MADWFparams::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool MADWFparams::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool MADWFparams::Vml(VML *vmls,char *instance){
		 if(!vml_MADWFparams(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_MADWFparams (VML *vmls, char *name,MADWFparams *objp)
{
	 vml_class_begin(vmls,"MADWFparams",name);
	 if (!vml_int (vmls, "Ls_inner", &objp->Ls_inner))
		 return FALSE;
	 if (!vml_double (vmls, "b_plus_c_inner", &objp->b_plus_c_inner))
		 return FALSE;
	 if (!vml_A2Apreconditioning (vmls, "precond", &objp->precond))
		 return FALSE;
	 if (!vml_bool (vmls, "use_ZMobius", &objp->use_ZMobius))
		 return FALSE;
	 if (!vml_ZMobiusParams (vmls, "ZMobius_params", &objp->ZMobius_params))
		 return FALSE;
	 vml_class_end(vmls,"MADWFparams",name);
	return TRUE;
}
void rpc_print<MADWFparams>::doit(MADWFparams const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.Ls_inner,spaces+" Ls_inner = ");
	rpc_print<double>::doit(what.b_plus_c_inner,spaces+" b_plus_c_inner = ");
	rpc_print<A2Apreconditioning>::doit(what.precond,spaces+" precond = ");
	rpc_print<bool_t>::doit(what.use_ZMobius,spaces+" use_ZMobius = ");
	rpc_print<ZMobiusParams>::doit(what.ZMobius_params,spaces+" ZMobius_params = ");
	std::cout << spaces << "}\n";
}
void MADWFparams::print(const std::string &prefix){
	rpc_print<MADWFparams>::doit(*this,prefix);
}
void rpc_deepcopy<MADWFparams>::doit(MADWFparams &into, MADWFparams const &from){
	  rpc_deepcopy<int>::doit(into.Ls_inner,from.Ls_inner);
	  rpc_deepcopy<double>::doit(into.b_plus_c_inner,from.b_plus_c_inner);
	  rpc_deepcopy<A2Apreconditioning>::doit(into.precond,from.precond);
	  rpc_deepcopy<bool_t>::doit(into.use_ZMobius,from.use_ZMobius);
	  rpc_deepcopy<ZMobiusParams>::doit(into.ZMobius_params,from.ZMobius_params);
}
void MADWFparams::deep_copy(MADWFparams const &rhs){
	rpc_deepcopy<MADWFparams>::doit(*this,rhs);
}
	 bool CGcontrols::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool CGcontrols::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool CGcontrols::Vml(VML *vmls,char *instance){
		 if(!vml_CGcontrols(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_CGcontrols (VML *vmls, char *name,CGcontrols *objp)
{
	 vml_class_begin(vmls,"CGcontrols",name);
	 if (!vml_A2ACGalgorithm (vmls, "CGalgorithm", &objp->CGalgorithm))
		 return FALSE;
	 if (!vml_double (vmls, "CG_tolerance", &objp->CG_tolerance))
		 return FALSE;
	 if (!vml_int (vmls, "CG_max_iters", &objp->CG_max_iters))
		 return FALSE;
	 if (!vml_double (vmls, "mixedCG_init_inner_tolerance", &objp->mixedCG_init_inner_tolerance))
		 return FALSE;
	 if (!vml_double (vmls, "reliable_update_delta", &objp->reliable_update_delta))
		 return FALSE;
	 if (!vml_double (vmls, "reliable_update_transition_tol", &objp->reliable_update_transition_tol))
		 return FALSE;
	 if (!vml_int (vmls, "multiCG_block_size", &objp->multiCG_block_size))
		 return FALSE;
	 if (!vml_array (vmls, "split_grid_geometry", (char **)&objp->split_grid_geometry.split_grid_geometry_val, (u_int *) &objp->split_grid_geometry.split_grid_geometry_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_MADWFparams (vmls, "madwf_params", &objp->madwf_params))
		 return FALSE;
	 vml_class_end(vmls,"CGcontrols",name);
	return TRUE;
}
void rpc_print<CGcontrols>::doit(CGcontrols const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<A2ACGalgorithm>::doit(what.CGalgorithm,spaces+" CGalgorithm = ");
	rpc_print<double>::doit(what.CG_tolerance,spaces+" CG_tolerance = ");
	rpc_print<int>::doit(what.CG_max_iters,spaces+" CG_max_iters = ");
	rpc_print<double>::doit(what.mixedCG_init_inner_tolerance,spaces+" mixedCG_init_inner_tolerance = ");
	rpc_print<double>::doit(what.reliable_update_delta,spaces+" reliable_update_delta = ");
	rpc_print<double>::doit(what.reliable_update_transition_tol,spaces+" reliable_update_transition_tol = ");
	rpc_print<int>::doit(what.multiCG_block_size,spaces+" multiCG_block_size = ");
	rpc_print<int *>::doit(what.split_grid_geometry.split_grid_geometry_val,what.split_grid_geometry.split_grid_geometry_len,spaces+" split_grid_geometry = ");
	rpc_print<MADWFparams>::doit(what.madwf_params,spaces+" madwf_params = ");
	std::cout << spaces << "}\n";
}
void CGcontrols::print(const std::string &prefix){
	rpc_print<CGcontrols>::doit(*this,prefix);
}
void rpc_deepcopy<CGcontrols>::doit(CGcontrols &into, CGcontrols const &from){
	  rpc_deepcopy<A2ACGalgorithm>::doit(into.CGalgorithm,from.CGalgorithm);
	  rpc_deepcopy<double>::doit(into.CG_tolerance,from.CG_tolerance);
	  rpc_deepcopy<int>::doit(into.CG_max_iters,from.CG_max_iters);
	  rpc_deepcopy<double>::doit(into.mixedCG_init_inner_tolerance,from.mixedCG_init_inner_tolerance);
	  rpc_deepcopy<double>::doit(into.reliable_update_delta,from.reliable_update_delta);
	  rpc_deepcopy<double>::doit(into.reliable_update_transition_tol,from.reliable_update_transition_tol);
	  rpc_deepcopy<int>::doit(into.multiCG_block_size,from.multiCG_block_size);
	  into.split_grid_geometry.split_grid_geometry_len = from.split_grid_geometry.split_grid_geometry_len;
	  rpc_deepcopy<int *>::doit(into.split_grid_geometry.split_grid_geometry_val,from.split_grid_geometry.split_grid_geometry_val,from.split_grid_geometry.split_grid_geometry_len);
	  rpc_deepcopy<MADWFparams>::doit(into.madwf_params,from.madwf_params);
}
void CGcontrols::deep_copy(CGcontrols const &rhs){
	rpc_deepcopy<CGcontrols>::doit(*this,rhs);
}
	 bool JobParams::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool JobParams::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool JobParams::Vml(VML *vmls,char *instance){
		 if(!vml_JobParams(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_JobParams (VML *vmls, char *name,JobParams *objp)
{
	 vml_class_begin(vmls,"JobParams",name);
	 if (!vml_BfmSolverType (vmls, "solver", &objp->solver))
		 return FALSE;
	 if (!vml_double (vmls, "mobius_scale", &objp->mobius_scale))
		 return FALSE;
	 if (!vml_bool (vmls, "convert_evecs_to_single_precision", &objp->convert_evecs_to_single_precision))
		 return FALSE;
	 if (!vml_CGcontrols (vmls, "cg_controls", &objp->cg_controls))
		 return FALSE;
	 if (!vml_double (vmls, "pion_rad", &objp->pion_rad))
		 return FALSE;
	 if (!vml_double (vmls, "kaon_rad", &objp->kaon_rad))
		 return FALSE;
	 if (!vml_int (vmls, "pipi_separation", &objp->pipi_separation))
		 return FALSE;
	 if (!vml_int (vmls, "tstep_pipi", &objp->tstep_pipi))
		 return FALSE;
	 if (!vml_array (vmls, "k_pi_separation", (char **)&objp->k_pi_separation.k_pi_separation_val, (u_int *) &objp->k_pi_separation.k_pi_separation_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_int (vmls, "xyzstep_type1", &objp->xyzstep_type1))
		 return FALSE;
	 if (!vml_int (vmls, "tstep_type12", &objp->tstep_type12))
		 return FALSE;
	 vml_class_end(vmls,"JobParams",name);
	return TRUE;
}
void rpc_print<JobParams>::doit(JobParams const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<BfmSolverType>::doit(what.solver,spaces+" solver = ");
	rpc_print<double>::doit(what.mobius_scale,spaces+" mobius_scale = ");
	rpc_print<bool_t>::doit(what.convert_evecs_to_single_precision,spaces+" convert_evecs_to_single_precision = ");
	rpc_print<CGcontrols>::doit(what.cg_controls,spaces+" cg_controls = ");
	rpc_print<double>::doit(what.pion_rad,spaces+" pion_rad = ");
	rpc_print<double>::doit(what.kaon_rad,spaces+" kaon_rad = ");
	rpc_print<int>::doit(what.pipi_separation,spaces+" pipi_separation = ");
	rpc_print<int>::doit(what.tstep_pipi,spaces+" tstep_pipi = ");
	rpc_print<int *>::doit(what.k_pi_separation.k_pi_separation_val,what.k_pi_separation.k_pi_separation_len,spaces+" k_pi_separation = ");
	rpc_print<int>::doit(what.xyzstep_type1,spaces+" xyzstep_type1 = ");
	rpc_print<int>::doit(what.tstep_type12,spaces+" tstep_type12 = ");
	std::cout << spaces << "}\n";
}
void JobParams::print(const std::string &prefix){
	rpc_print<JobParams>::doit(*this,prefix);
}
void rpc_deepcopy<JobParams>::doit(JobParams &into, JobParams const &from){
	  rpc_deepcopy<BfmSolverType>::doit(into.solver,from.solver);
	  rpc_deepcopy<double>::doit(into.mobius_scale,from.mobius_scale);
	  rpc_deepcopy<bool_t>::doit(into.convert_evecs_to_single_precision,from.convert_evecs_to_single_precision);
	  rpc_deepcopy<CGcontrols>::doit(into.cg_controls,from.cg_controls);
	  rpc_deepcopy<double>::doit(into.pion_rad,from.pion_rad);
	  rpc_deepcopy<double>::doit(into.kaon_rad,from.kaon_rad);
	  rpc_deepcopy<int>::doit(into.pipi_separation,from.pipi_separation);
	  rpc_deepcopy<int>::doit(into.tstep_pipi,from.tstep_pipi);
	  into.k_pi_separation.k_pi_separation_len = from.k_pi_separation.k_pi_separation_len;
	  rpc_deepcopy<int *>::doit(into.k_pi_separation.k_pi_separation_val,from.k_pi_separation.k_pi_separation_val,from.k_pi_separation.k_pi_separation_len);
	  rpc_deepcopy<int>::doit(into.xyzstep_type1,from.xyzstep_type1);
	  rpc_deepcopy<int>::doit(into.tstep_type12,from.tstep_type12);
}
void JobParams::deep_copy(JobParams const &rhs){
	rpc_deepcopy<JobParams>::doit(*this,rhs);
}
CPS_END_NAMESPACE
