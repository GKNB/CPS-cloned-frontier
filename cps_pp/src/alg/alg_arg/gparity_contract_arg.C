/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/gparity_contract_arg.h>
CPS_START_NAMESPACE

bool_t
vml_ContractionType (VML *vmls, char *name,ContractionType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,ContractionType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map ContractionType_map[] = {
	{"ContractionType","CONTRACTION_TYPE_LL_MESONS",CONTRACTION_TYPE_LL_MESONS},
	{"ContractionType","CONTRACTION_TYPE_HL_MESONS",CONTRACTION_TYPE_HL_MESONS},
	{"ContractionType","CONTRACTION_TYPE_O_VV_P_AA",CONTRACTION_TYPE_O_VV_P_AA},
	{"ContractionType","CONTRACTION_TYPE_ALL_BILINEARS",CONTRACTION_TYPE_ALL_BILINEARS},
	{"ContractionType","CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS",CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS},
	{"ContractionType","CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM",CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM},
	{"ContractionType","CONTRACTION_TYPE_FOURIER_PROP",CONTRACTION_TYPE_FOURIER_PROP},
	{"ContractionType","CONTRACTION_TYPE_BILINEAR_VERTEX",CONTRACTION_TYPE_BILINEAR_VERTEX},
	{"ContractionType","CONTRACTION_TYPE_QUADRILINEAR_VERTEX",CONTRACTION_TYPE_QUADRILINEAR_VERTEX},
	{"ContractionType","CONTRACTION_TYPE_TOPOLOGICAL_CHARGE",CONTRACTION_TYPE_TOPOLOGICAL_CHARGE},
	{"ContractionType","CONTRACTION_TYPE_MRES",CONTRACTION_TYPE_MRES},
	{NULL,NULL,0}
};

bool_t
vml_ContractionTypeLLMesons (VML *vmls, char *name,ContractionTypeLLMesons *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeLLMesons",name);
	int i;
	 if (!vml_string (vmls, "prop_L", &objp->prop_L, ~0))
		 return FALSE;
	 if (!vml_vector (vmls, "sink_mom", (char *)objp->sink_mom, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeLLMesons",name);
	return TRUE;
}
void rpc_print<ContractionTypeLLMesons>::doit(ContractionTypeLLMesons const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_L,strlen(what.prop_L)+1,spaces+" prop_L = ");
	{
	  std::ostringstream os; os << spaces << " sink_mom[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " sink_mom["<<i<<"] = "; rpc_print<int>::doit(what.sink_mom[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeLLMesons::print(const std::string &prefix){
	rpc_print<ContractionTypeLLMesons>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeLLMesons>::doit(ContractionTypeLLMesons &into, ContractionTypeLLMesons const &from){
	  rpc_deepcopy<char *>::doit(into.prop_L,from.prop_L,strlen(from.prop_L)+1);
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.sink_mom[i],from.sink_mom[i]);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeLLMesons::deep_copy(ContractionTypeLLMesons const &rhs){
	rpc_deepcopy<ContractionTypeLLMesons>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeHLMesons (VML *vmls, char *name,ContractionTypeHLMesons *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeHLMesons",name);
	int i;
	 if (!vml_string (vmls, "prop_H", &objp->prop_H, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L", &objp->prop_L, ~0))
		 return FALSE;
	 if (!vml_vector (vmls, "sink_mom", (char *)objp->sink_mom, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeHLMesons",name);
	return TRUE;
}
void rpc_print<ContractionTypeHLMesons>::doit(ContractionTypeHLMesons const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_H,strlen(what.prop_H)+1,spaces+" prop_H = ");
	rpc_print<char *>::doit(what.prop_L,strlen(what.prop_L)+1,spaces+" prop_L = ");
	{
	  std::ostringstream os; os << spaces << " sink_mom[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " sink_mom["<<i<<"] = "; rpc_print<int>::doit(what.sink_mom[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeHLMesons::print(const std::string &prefix){
	rpc_print<ContractionTypeHLMesons>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeHLMesons>::doit(ContractionTypeHLMesons &into, ContractionTypeHLMesons const &from){
	  rpc_deepcopy<char *>::doit(into.prop_H,from.prop_H,strlen(from.prop_H)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L,from.prop_L,strlen(from.prop_L)+1);
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.sink_mom[i],from.sink_mom[i]);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeHLMesons::deep_copy(ContractionTypeHLMesons const &rhs){
	rpc_deepcopy<ContractionTypeHLMesons>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeOVVpAA (VML *vmls, char *name,ContractionTypeOVVpAA *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeOVVpAA",name);
	 if (!vml_string (vmls, "prop_H_t0", &objp->prop_H_t0, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L_t0", &objp->prop_L_t0, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_H_t1", &objp->prop_H_t1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L_t1", &objp->prop_L_t1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeOVVpAA",name);
	return TRUE;
}
void rpc_print<ContractionTypeOVVpAA>::doit(ContractionTypeOVVpAA const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_H_t0,strlen(what.prop_H_t0)+1,spaces+" prop_H_t0 = ");
	rpc_print<char *>::doit(what.prop_L_t0,strlen(what.prop_L_t0)+1,spaces+" prop_L_t0 = ");
	rpc_print<char *>::doit(what.prop_H_t1,strlen(what.prop_H_t1)+1,spaces+" prop_H_t1 = ");
	rpc_print<char *>::doit(what.prop_L_t1,strlen(what.prop_L_t1)+1,spaces+" prop_L_t1 = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeOVVpAA::print(const std::string &prefix){
	rpc_print<ContractionTypeOVVpAA>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeOVVpAA>::doit(ContractionTypeOVVpAA &into, ContractionTypeOVVpAA const &from){
	  rpc_deepcopy<char *>::doit(into.prop_H_t0,from.prop_H_t0,strlen(from.prop_H_t0)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L_t0,from.prop_L_t0,strlen(from.prop_L_t0)+1);
	  rpc_deepcopy<char *>::doit(into.prop_H_t1,from.prop_H_t1,strlen(from.prop_H_t1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L_t1,from.prop_L_t1,strlen(from.prop_L_t1)+1);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeOVVpAA::deep_copy(ContractionTypeOVVpAA const &rhs){
	rpc_deepcopy<ContractionTypeOVVpAA>::doit(*this,rhs);
}

bool_t
vml_MomArg (VML *vmls, char *name,MomArg *objp)
{
	 vml_struct_begin(vmls,"MomArg",name);
	int i;
	 if (!vml_vector (vmls, "p", (char *)objp->p, 3,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 vml_struct_end(vmls,"MomArg",name);
	return TRUE;
}
void rpc_print<MomArg>::doit(MomArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	{
	  std::ostringstream os; os << spaces << " p[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p["<<i<<"] = "; rpc_print<Float>::doit(what.p[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void MomArg::print(const std::string &prefix){
	rpc_print<MomArg>::doit(*this,prefix);
}
void rpc_deepcopy<MomArg>::doit(MomArg &into, MomArg const &from){
	  for(int i=0;i<3;i++) rpc_deepcopy<Float>::doit(into.p[i],from.p[i]);
}
void MomArg::deep_copy(MomArg const &rhs){
	rpc_deepcopy<MomArg>::doit(*this,rhs);
}

bool_t
vml_MomPairArg (VML *vmls, char *name,MomPairArg *objp)
{
	 vml_struct_begin(vmls,"MomPairArg",name);
	int i;
	 if (!vml_vector (vmls, "p1", (char *)objp->p1, 3,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 if (!vml_vector (vmls, "p2", (char *)objp->p2, 3,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 vml_struct_end(vmls,"MomPairArg",name);
	return TRUE;
}
void rpc_print<MomPairArg>::doit(MomPairArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	{
	  std::ostringstream os; os << spaces << " p1[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p1["<<i<<"] = "; rpc_print<Float>::doit(what.p1[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	{
	  std::ostringstream os; os << spaces << " p2[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p2["<<i<<"] = "; rpc_print<Float>::doit(what.p2[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void MomPairArg::print(const std::string &prefix){
	rpc_print<MomPairArg>::doit(*this,prefix);
}
void rpc_deepcopy<MomPairArg>::doit(MomPairArg &into, MomPairArg const &from){
	  for(int i=0;i<3;i++) rpc_deepcopy<Float>::doit(into.p1[i],from.p1[i]);
	  for(int i=0;i<3;i++) rpc_deepcopy<Float>::doit(into.p2[i],from.p2[i]);
}
void MomPairArg::deep_copy(MomPairArg const &rhs){
	rpc_deepcopy<MomPairArg>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeAllBilinears (VML *vmls, char *name,ContractionTypeAllBilinears *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeAllBilinears",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeAllBilinears",name);
	return TRUE;
}
void rpc_print<ContractionTypeAllBilinears>::doit(ContractionTypeAllBilinears const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeAllBilinears::print(const std::string &prefix){
	rpc_print<ContractionTypeAllBilinears>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeAllBilinears>::doit(ContractionTypeAllBilinears &into, ContractionTypeAllBilinears const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeAllBilinears::deep_copy(ContractionTypeAllBilinears const &rhs){
	rpc_deepcopy<ContractionTypeAllBilinears>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeAllWallSinkBilinears (VML *vmls, char *name,ContractionTypeAllWallSinkBilinears *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeAllWallSinkBilinears",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeAllWallSinkBilinears",name);
	return TRUE;
}
void rpc_print<ContractionTypeAllWallSinkBilinears>::doit(ContractionTypeAllWallSinkBilinears const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeAllWallSinkBilinears::print(const std::string &prefix){
	rpc_print<ContractionTypeAllWallSinkBilinears>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeAllWallSinkBilinears>::doit(ContractionTypeAllWallSinkBilinears &into, ContractionTypeAllWallSinkBilinears const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeAllWallSinkBilinears::deep_copy(ContractionTypeAllWallSinkBilinears const &rhs){
	rpc_deepcopy<ContractionTypeAllWallSinkBilinears>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeAllWallSinkBilinearsSpecificMomentum (VML *vmls, char *name,ContractionTypeAllWallSinkBilinearsSpecificMomentum *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeAllWallSinkBilinearsSpecificMomentum",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomPairArg), (vmlproc_t) vml_MomPairArg))
		 return FALSE;
	 if (!vml_int (vmls, "cosine_sink", &objp->cosine_sink))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeAllWallSinkBilinearsSpecificMomentum",name);
	return TRUE;
}
void rpc_print<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(ContractionTypeAllWallSinkBilinearsSpecificMomentum const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<MomPairArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<int>::doit(what.cosine_sink,spaces+" cosine_sink = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeAllWallSinkBilinearsSpecificMomentum::print(const std::string &prefix){
	rpc_print<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(ContractionTypeAllWallSinkBilinearsSpecificMomentum &into, ContractionTypeAllWallSinkBilinearsSpecificMomentum const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomPairArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<int>::doit(into.cosine_sink,from.cosine_sink);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeAllWallSinkBilinearsSpecificMomentum::deep_copy(ContractionTypeAllWallSinkBilinearsSpecificMomentum const &rhs){
	rpc_deepcopy<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeFourierProp (VML *vmls, char *name,ContractionTypeFourierProp *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeFourierProp",name);
	 if (!vml_string (vmls, "prop", &objp->prop, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_fix", &objp->gauge_fix))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeFourierProp",name);
	return TRUE;
}
void rpc_print<ContractionTypeFourierProp>::doit(ContractionTypeFourierProp const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop,strlen(what.prop)+1,spaces+" prop = ");
	rpc_print<int>::doit(what.gauge_fix,spaces+" gauge_fix = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeFourierProp::print(const std::string &prefix){
	rpc_print<ContractionTypeFourierProp>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeFourierProp>::doit(ContractionTypeFourierProp &into, ContractionTypeFourierProp const &from){
	  rpc_deepcopy<char *>::doit(into.prop,from.prop,strlen(from.prop)+1);
	  rpc_deepcopy<int>::doit(into.gauge_fix,from.gauge_fix);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeFourierProp::deep_copy(ContractionTypeFourierProp const &rhs){
	rpc_deepcopy<ContractionTypeFourierProp>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeBilinearVertex (VML *vmls, char *name,ContractionTypeBilinearVertex *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeBilinearVertex",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeBilinearVertex",name);
	return TRUE;
}
void rpc_print<ContractionTypeBilinearVertex>::doit(ContractionTypeBilinearVertex const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeBilinearVertex::print(const std::string &prefix){
	rpc_print<ContractionTypeBilinearVertex>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeBilinearVertex>::doit(ContractionTypeBilinearVertex &into, ContractionTypeBilinearVertex const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeBilinearVertex::deep_copy(ContractionTypeBilinearVertex const &rhs){
	rpc_deepcopy<ContractionTypeBilinearVertex>::doit(*this,rhs);
}

bool_t
vml_QuadrilinearSpinStructure (VML *vmls, char *name,QuadrilinearSpinStructure *objp)
{
	 vml_struct_begin(vmls,"QuadrilinearSpinStructure",name);
	 if (!vml_array (vmls, "Gamma1", (char **)&objp->Gamma1.Gamma1_val, (u_int *) &objp->Gamma1.Gamma1_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "Gamma2", (char **)&objp->Gamma2.Gamma2_val, (u_int *) &objp->Gamma2.Gamma2_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "Sigma1", (char **)&objp->Sigma1.Sigma1_val, (u_int *) &objp->Sigma1.Sigma1_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "Sigma2", (char **)&objp->Sigma2.Sigma2_val, (u_int *) &objp->Sigma2.Sigma2_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 vml_struct_end(vmls,"QuadrilinearSpinStructure",name);
	return TRUE;
}
void rpc_print<QuadrilinearSpinStructure>::doit(QuadrilinearSpinStructure const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int *>::doit(what.Gamma1.Gamma1_val,what.Gamma1.Gamma1_len,spaces+" Gamma1 = ");
	rpc_print<int *>::doit(what.Gamma2.Gamma2_val,what.Gamma2.Gamma2_len,spaces+" Gamma2 = ");
	rpc_print<int *>::doit(what.Sigma1.Sigma1_val,what.Sigma1.Sigma1_len,spaces+" Sigma1 = ");
	rpc_print<int *>::doit(what.Sigma2.Sigma2_val,what.Sigma2.Sigma2_len,spaces+" Sigma2 = ");
	std::cout << spaces << "}\n";
}
void QuadrilinearSpinStructure::print(const std::string &prefix){
	rpc_print<QuadrilinearSpinStructure>::doit(*this,prefix);
}

bool_t
vml_ContractionTypeQuadrilinearVertex (VML *vmls, char *name,ContractionTypeQuadrilinearVertex *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeQuadrilinearVertex",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_3", &objp->prop_3, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_4", &objp->prop_4, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "spin_structs", (char **)&objp->spin_structs.spin_structs_val, (u_int *) &objp->spin_structs.spin_structs_len, ~0,
		sizeof (QuadrilinearSpinStructure), (vmlproc_t) vml_QuadrilinearSpinStructure))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeQuadrilinearVertex",name);
	return TRUE;
}
void rpc_print<ContractionTypeQuadrilinearVertex>::doit(ContractionTypeQuadrilinearVertex const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<char *>::doit(what.prop_3,strlen(what.prop_3)+1,spaces+" prop_3 = ");
	rpc_print<char *>::doit(what.prop_4,strlen(what.prop_4)+1,spaces+" prop_4 = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	rpc_print<QuadrilinearSpinStructure *>::doit(what.spin_structs.spin_structs_val,what.spin_structs.spin_structs_len,spaces+" spin_structs = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeQuadrilinearVertex::print(const std::string &prefix){
	rpc_print<ContractionTypeQuadrilinearVertex>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeQuadrilinearVertex>::doit(ContractionTypeQuadrilinearVertex &into, ContractionTypeQuadrilinearVertex const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  rpc_deepcopy<char *>::doit(into.prop_3,from.prop_3,strlen(from.prop_3)+1);
	  rpc_deepcopy<char *>::doit(into.prop_4,from.prop_4,strlen(from.prop_4)+1);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
	  into.spin_structs.spin_structs_len = from.spin_structs.spin_structs_len;
	  rpc_deepcopy<QuadrilinearSpinStructure *>::doit(into.spin_structs.spin_structs_val,from.spin_structs.spin_structs_val,from.spin_structs.spin_structs_len);
}
void ContractionTypeQuadrilinearVertex::deep_copy(ContractionTypeQuadrilinearVertex const &rhs){
	rpc_deepcopy<ContractionTypeQuadrilinearVertex>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeTopologicalCharge (VML *vmls, char *name,ContractionTypeTopologicalCharge *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeTopologicalCharge",name);
	 if (!vml_int (vmls, "n_ape_smearing_cycles", &objp->n_ape_smearing_cycles))
		 return FALSE;
	 if (!vml_int (vmls, "ape_smear_su3_project", &objp->ape_smear_su3_project))
		 return FALSE;
	 if (!vml_Float (vmls, "ape_su3_proj_tolerance", &objp->ape_su3_proj_tolerance))
		 return FALSE;
	 if (!vml_int (vmls, "ape_orthog", &objp->ape_orthog))
		 return FALSE;
	 if (!vml_Float (vmls, "ape_coef", &objp->ape_coef))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeTopologicalCharge",name);
	return TRUE;
}
void rpc_print<ContractionTypeTopologicalCharge>::doit(ContractionTypeTopologicalCharge const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.n_ape_smearing_cycles,spaces+" n_ape_smearing_cycles = ");
	rpc_print<int>::doit(what.ape_smear_su3_project,spaces+" ape_smear_su3_project = ");
	rpc_print<Float>::doit(what.ape_su3_proj_tolerance,spaces+" ape_su3_proj_tolerance = ");
	rpc_print<int>::doit(what.ape_orthog,spaces+" ape_orthog = ");
	rpc_print<Float>::doit(what.ape_coef,spaces+" ape_coef = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeTopologicalCharge::print(const std::string &prefix){
	rpc_print<ContractionTypeTopologicalCharge>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeTopologicalCharge>::doit(ContractionTypeTopologicalCharge &into, ContractionTypeTopologicalCharge const &from){
	  rpc_deepcopy<int>::doit(into.n_ape_smearing_cycles,from.n_ape_smearing_cycles);
	  rpc_deepcopy<int>::doit(into.ape_smear_su3_project,from.ape_smear_su3_project);
	  rpc_deepcopy<Float>::doit(into.ape_su3_proj_tolerance,from.ape_su3_proj_tolerance);
	  rpc_deepcopy<int>::doit(into.ape_orthog,from.ape_orthog);
	  rpc_deepcopy<Float>::doit(into.ape_coef,from.ape_coef);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeTopologicalCharge::deep_copy(ContractionTypeTopologicalCharge const &rhs){
	rpc_deepcopy<ContractionTypeTopologicalCharge>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeMres (VML *vmls, char *name,ContractionTypeMres *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeMres",name);
	 if (!vml_string (vmls, "prop", &objp->prop, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeMres",name);
	return TRUE;
}
void rpc_print<ContractionTypeMres>::doit(ContractionTypeMres const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop,strlen(what.prop)+1,spaces+" prop = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeMres::print(const std::string &prefix){
	rpc_print<ContractionTypeMres>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeMres>::doit(ContractionTypeMres &into, ContractionTypeMres const &from){
	  rpc_deepcopy<char *>::doit(into.prop,from.prop,strlen(from.prop)+1);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeMres::deep_copy(ContractionTypeMres const &rhs){
	rpc_deepcopy<ContractionTypeMres>::doit(*this,rhs);
}

bool_t
vml_GparityMeasurement (VML *vmls, char *name,GparityMeasurement *objp)
{
	 if (!vml_ContractionType (vmls, "type", &objp->type))
		 return FALSE;
	switch (objp->type) {
	case CONTRACTION_TYPE_LL_MESONS:
		 if (!vml_ContractionTypeLLMesons (vmls, "contraction_type_ll_mesons", &objp->GparityMeasurement_u.contraction_type_ll_mesons))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_HL_MESONS:
		 if (!vml_ContractionTypeHLMesons (vmls, "contraction_type_hl_mesons", &objp->GparityMeasurement_u.contraction_type_hl_mesons))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_O_VV_P_AA:
		 if (!vml_ContractionTypeOVVpAA (vmls, "contraction_type_o_vv_p_aa", &objp->GparityMeasurement_u.contraction_type_o_vv_p_aa))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_ALL_BILINEARS:
		 if (!vml_ContractionTypeAllBilinears (vmls, "contraction_type_all_bilinears", &objp->GparityMeasurement_u.contraction_type_all_bilinears))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS:
		 if (!vml_ContractionTypeAllWallSinkBilinears (vmls, "contraction_type_all_wallsink_bilinears", &objp->GparityMeasurement_u.contraction_type_all_wallsink_bilinears))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM:
		 if (!vml_ContractionTypeAllWallSinkBilinearsSpecificMomentum (vmls, "contraction_type_all_wallsink_bilinears_specific_momentum", &objp->GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_FOURIER_PROP:
		 if (!vml_ContractionTypeFourierProp (vmls, "contraction_type_fourier_prop", &objp->GparityMeasurement_u.contraction_type_fourier_prop))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_BILINEAR_VERTEX:
		 if (!vml_ContractionTypeBilinearVertex (vmls, "contraction_type_bilinear_vertex", &objp->GparityMeasurement_u.contraction_type_bilinear_vertex))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_QUADRILINEAR_VERTEX:
		 if (!vml_ContractionTypeQuadrilinearVertex (vmls, "contraction_type_quadrilinear_vertex", &objp->GparityMeasurement_u.contraction_type_quadrilinear_vertex))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_TOPOLOGICAL_CHARGE:
		 if (!vml_ContractionTypeTopologicalCharge (vmls, "contraction_type_topological_charge", &objp->GparityMeasurement_u.contraction_type_topological_charge))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_MRES:
		 if (!vml_ContractionTypeMres (vmls, "contraction_type_mres", &objp->GparityMeasurement_u.contraction_type_mres))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeLLMesons>(){
	 return CONTRACTION_TYPE_LL_MESONS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeHLMesons>(){
	 return CONTRACTION_TYPE_HL_MESONS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeOVVpAA>(){
	 return CONTRACTION_TYPE_O_VV_P_AA;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeAllBilinears>(){
	 return CONTRACTION_TYPE_ALL_BILINEARS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeAllWallSinkBilinears>(){
	 return CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeAllWallSinkBilinearsSpecificMomentum>(){
	 return CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeFourierProp>(){
	 return CONTRACTION_TYPE_FOURIER_PROP;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeBilinearVertex>(){
	 return CONTRACTION_TYPE_BILINEAR_VERTEX;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeQuadrilinearVertex>(){
	 return CONTRACTION_TYPE_QUADRILINEAR_VERTEX;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeTopologicalCharge>(){
	 return CONTRACTION_TYPE_TOPOLOGICAL_CHARGE;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeMres>(){
	 return CONTRACTION_TYPE_MRES;
}
void rpc_deepcopy<GparityMeasurement>::doit(GparityMeasurement &into, GparityMeasurement const &from){
	  into.type = from.type;
	  switch(from.type){
	    case CONTRACTION_TYPE_LL_MESONS:
	      rpc_deepcopy<ContractionTypeLLMesons>::doit(into.GparityMeasurement_u.contraction_type_ll_mesons,from.GparityMeasurement_u.contraction_type_ll_mesons); break;
	    case CONTRACTION_TYPE_HL_MESONS:
	      rpc_deepcopy<ContractionTypeHLMesons>::doit(into.GparityMeasurement_u.contraction_type_hl_mesons,from.GparityMeasurement_u.contraction_type_hl_mesons); break;
	    case CONTRACTION_TYPE_O_VV_P_AA:
	      rpc_deepcopy<ContractionTypeOVVpAA>::doit(into.GparityMeasurement_u.contraction_type_o_vv_p_aa,from.GparityMeasurement_u.contraction_type_o_vv_p_aa); break;
	    case CONTRACTION_TYPE_ALL_BILINEARS:
	      rpc_deepcopy<ContractionTypeAllBilinears>::doit(into.GparityMeasurement_u.contraction_type_all_bilinears,from.GparityMeasurement_u.contraction_type_all_bilinears); break;
	    case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS:
	      rpc_deepcopy<ContractionTypeAllWallSinkBilinears>::doit(into.GparityMeasurement_u.contraction_type_all_wallsink_bilinears,from.GparityMeasurement_u.contraction_type_all_wallsink_bilinears); break;
	    case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM:
	      rpc_deepcopy<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(into.GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum,from.GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum); break;
	    case CONTRACTION_TYPE_FOURIER_PROP:
	      rpc_deepcopy<ContractionTypeFourierProp>::doit(into.GparityMeasurement_u.contraction_type_fourier_prop,from.GparityMeasurement_u.contraction_type_fourier_prop); break;
	    case CONTRACTION_TYPE_BILINEAR_VERTEX:
	      rpc_deepcopy<ContractionTypeBilinearVertex>::doit(into.GparityMeasurement_u.contraction_type_bilinear_vertex,from.GparityMeasurement_u.contraction_type_bilinear_vertex); break;
	    case CONTRACTION_TYPE_QUADRILINEAR_VERTEX:
	      rpc_deepcopy<ContractionTypeQuadrilinearVertex>::doit(into.GparityMeasurement_u.contraction_type_quadrilinear_vertex,from.GparityMeasurement_u.contraction_type_quadrilinear_vertex); break;
	    case CONTRACTION_TYPE_TOPOLOGICAL_CHARGE:
	      rpc_deepcopy<ContractionTypeTopologicalCharge>::doit(into.GparityMeasurement_u.contraction_type_topological_charge,from.GparityMeasurement_u.contraction_type_topological_charge); break;
	    case CONTRACTION_TYPE_MRES:
	      rpc_deepcopy<ContractionTypeMres>::doit(into.GparityMeasurement_u.contraction_type_mres,from.GparityMeasurement_u.contraction_type_mres); break;
	  };
}
void GparityMeasurement::deep_copy(GparityMeasurement const &rhs){
	rpc_deepcopy<GparityMeasurement>::doit(*this,rhs);
}
void rpc_print<GparityMeasurement>::doit(GparityMeasurement const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	  switch(what.type){
	    case CONTRACTION_TYPE_LL_MESONS:
	      rpc_print<ContractionTypeLLMesons>::doit(what.GparityMeasurement_u.contraction_type_ll_mesons,spaces+" union GparityMeasurement_u.contraction_type_ll_mesons = "); break;
	    case CONTRACTION_TYPE_HL_MESONS:
	      rpc_print<ContractionTypeHLMesons>::doit(what.GparityMeasurement_u.contraction_type_hl_mesons,spaces+" union GparityMeasurement_u.contraction_type_hl_mesons = "); break;
	    case CONTRACTION_TYPE_O_VV_P_AA:
	      rpc_print<ContractionTypeOVVpAA>::doit(what.GparityMeasurement_u.contraction_type_o_vv_p_aa,spaces+" union GparityMeasurement_u.contraction_type_o_vv_p_aa = "); break;
	    case CONTRACTION_TYPE_ALL_BILINEARS:
	      rpc_print<ContractionTypeAllBilinears>::doit(what.GparityMeasurement_u.contraction_type_all_bilinears,spaces+" union GparityMeasurement_u.contraction_type_all_bilinears = "); break;
	    case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS:
	      rpc_print<ContractionTypeAllWallSinkBilinears>::doit(what.GparityMeasurement_u.contraction_type_all_wallsink_bilinears,spaces+" union GparityMeasurement_u.contraction_type_all_wallsink_bilinears = "); break;
	    case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM:
	      rpc_print<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(what.GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum,spaces+" union GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum = "); break;
	    case CONTRACTION_TYPE_FOURIER_PROP:
	      rpc_print<ContractionTypeFourierProp>::doit(what.GparityMeasurement_u.contraction_type_fourier_prop,spaces+" union GparityMeasurement_u.contraction_type_fourier_prop = "); break;
	    case CONTRACTION_TYPE_BILINEAR_VERTEX:
	      rpc_print<ContractionTypeBilinearVertex>::doit(what.GparityMeasurement_u.contraction_type_bilinear_vertex,spaces+" union GparityMeasurement_u.contraction_type_bilinear_vertex = "); break;
	    case CONTRACTION_TYPE_QUADRILINEAR_VERTEX:
	      rpc_print<ContractionTypeQuadrilinearVertex>::doit(what.GparityMeasurement_u.contraction_type_quadrilinear_vertex,spaces+" union GparityMeasurement_u.contraction_type_quadrilinear_vertex = "); break;
	    case CONTRACTION_TYPE_TOPOLOGICAL_CHARGE:
	      rpc_print<ContractionTypeTopologicalCharge>::doit(what.GparityMeasurement_u.contraction_type_topological_charge,spaces+" union GparityMeasurement_u.contraction_type_topological_charge = "); break;
	    case CONTRACTION_TYPE_MRES:
	      rpc_print<ContractionTypeMres>::doit(what.GparityMeasurement_u.contraction_type_mres,spaces+" union GparityMeasurement_u.contraction_type_mres = "); break;
	  };
	std::cout << spaces << "}\n";
}
void GparityMeasurement::print(const std::string &prefix){
	rpc_print<GparityMeasurement>::doit(*this,prefix);
}
	 bool GparityContractArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool GparityContractArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool GparityContractArg::Vml(VML *vmls,char *instance){
		 if(!vml_GparityContractArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_GparityContractArg (VML *vmls, char *name,GparityContractArg *objp)
{
	 vml_class_begin(vmls,"GparityContractArg",name);
	 if (!vml_array (vmls, "meas", (char **)&objp->meas.meas_val, (u_int *) &objp->meas.meas_len, ~0,
		sizeof (GparityMeasurement), (vmlproc_t) vml_GparityMeasurement))
		 return FALSE;
	 if (!vml_string (vmls, "config_fmt", &objp->config_fmt, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "conf_start", &objp->conf_start))
		 return FALSE;
	 if (!vml_int (vmls, "conf_incr", &objp->conf_incr))
		 return FALSE;
	 if (!vml_int (vmls, "conf_lessthan", &objp->conf_lessthan))
		 return FALSE;
	 if (!vml_FixGaugeArg (vmls, "fix_gauge", &objp->fix_gauge))
		 return FALSE;
	 vml_class_end(vmls,"GparityContractArg",name);
	return TRUE;
}
void rpc_deepcopy<GparityContractArg>::doit(GparityContractArg &into, GparityContractArg const &from){
	  into.meas.meas_len = from.meas.meas_len;
	  rpc_deepcopy<GparityMeasurement *>::doit(into.meas.meas_val,from.meas.meas_val,from.meas.meas_len);
	  rpc_deepcopy<char *>::doit(into.config_fmt,from.config_fmt,strlen(from.config_fmt)+1);
	  rpc_deepcopy<int>::doit(into.conf_start,from.conf_start);
	  rpc_deepcopy<int>::doit(into.conf_incr,from.conf_incr);
	  rpc_deepcopy<int>::doit(into.conf_lessthan,from.conf_lessthan);
	  rpc_deepcopy<FixGaugeArg>::doit(into.fix_gauge,from.fix_gauge);
}
void GparityContractArg::deep_copy(GparityContractArg const &rhs){
	rpc_deepcopy<GparityContractArg>::doit(*this,rhs);
}
CPS_END_NAMESPACE
