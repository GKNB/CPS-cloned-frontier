/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/gparity_contract_arg.h>
CPS_START_NAMESPACE

bool_t
vml_GparityMeasurement (VML *vmls, char *name,GparityMeasurement *objp)
{
	 vml_struct_begin(vmls,"GparityMeasurement",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "label_stub", &objp->label_stub, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "file_stub", &objp->file_stub, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"GparityMeasurement",name);
	return TRUE;
}
	 bool GparityContractArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool GparityContractArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool GparityContractArg::Vml(VML *vmls,char *instance){
		 if(!vml_GparityContractArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_GparityContractArg (VML *vmls, char *name,GparityContractArg *objp)
{
	 vml_class_begin(vmls,"GparityContractArg",name);
	 if (!vml_array (vmls, "meas", (char **)&objp->meas.meas_val, (u_int *) &objp->meas.meas_len, ~0,
		sizeof (GparityMeasurement), (vmlproc_t) vml_GparityMeasurement))
		 return FALSE;
	 if (!vml_string (vmls, "config_fmt", &objp->config_fmt, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "conf_start", &objp->conf_start))
		 return FALSE;
	 if (!vml_int (vmls, "conf_incr", &objp->conf_incr))
		 return FALSE;
	 if (!vml_int (vmls, "conf_lessthan", &objp->conf_lessthan))
		 return FALSE;
	 if (!vml_FixGaugeArg (vmls, "fix_gauge", &objp->fix_gauge))
		 return FALSE;
	 vml_class_end(vmls,"GparityContractArg",name);
	return TRUE;
}
CPS_END_NAMESPACE
