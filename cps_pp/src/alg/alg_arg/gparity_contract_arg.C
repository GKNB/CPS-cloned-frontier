/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */
#include <comms/sysfunc_cps.h>
#include <alg/gparity_contract_arg.h>
CPS_START_NAMESPACE

bool_t
vml_ContractionType (VML *vmls, char *name,ContractionType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,ContractionType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map ContractionType_map[] = {
	{"ContractionType","CONTRACTION_TYPE_LL_MESONS",CONTRACTION_TYPE_LL_MESONS},
	{"ContractionType","CONTRACTION_TYPE_HL_MESONS",CONTRACTION_TYPE_HL_MESONS},
	{"ContractionType","CONTRACTION_TYPE_O_VV_P_AA",CONTRACTION_TYPE_O_VV_P_AA},
	{NULL,NULL,0}
};

bool_t
vml_ContractionTypeLLMesons (VML *vmls, char *name,ContractionTypeLLMesons *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeLLMesons",name);
	int i;
	 if (!vml_string (vmls, "prop_L", &objp->prop_L, ~0))
		 return FALSE;
	 if (!vml_vector (vmls, "sink_mom", (char *)objp->sink_mom, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeLLMesons",name);
	return TRUE;
}
void rpc_print<ContractionTypeLLMesons>::doit(ContractionTypeLLMesons const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_L,strlen(what.prop_L)+1,spaces+" prop_L = ");
	{
	  std::ostringstream os; os << spaces << " sink_mom[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " sink_mom["<<i<<"] = "; rpc_print<int>::doit(what.sink_mom[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeLLMesons::print(const std::string &prefix){
	rpc_print<ContractionTypeLLMesons>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeLLMesons>::doit(ContractionTypeLLMesons &into, ContractionTypeLLMesons const &from){
	  rpc_deepcopy<char *>::doit(into.prop_L,from.prop_L,strlen(from.prop_L)+1);
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.sink_mom[i],from.sink_mom[i]);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeLLMesons::deep_copy(ContractionTypeLLMesons const &rhs){
	rpc_deepcopy<ContractionTypeLLMesons>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeHLMesons (VML *vmls, char *name,ContractionTypeHLMesons *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeHLMesons",name);
	int i;
	 if (!vml_string (vmls, "prop_H", &objp->prop_H, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L", &objp->prop_L, ~0))
		 return FALSE;
	 if (!vml_vector (vmls, "sink_mom", (char *)objp->sink_mom, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeHLMesons",name);
	return TRUE;
}
void rpc_print<ContractionTypeHLMesons>::doit(ContractionTypeHLMesons const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_H,strlen(what.prop_H)+1,spaces+" prop_H = ");
	rpc_print<char *>::doit(what.prop_L,strlen(what.prop_L)+1,spaces+" prop_L = ");
	{
	  std::ostringstream os; os << spaces << " sink_mom[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " sink_mom["<<i<<"] = "; rpc_print<int>::doit(what.sink_mom[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeHLMesons::print(const std::string &prefix){
	rpc_print<ContractionTypeHLMesons>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeHLMesons>::doit(ContractionTypeHLMesons &into, ContractionTypeHLMesons const &from){
	  rpc_deepcopy<char *>::doit(into.prop_H,from.prop_H,strlen(from.prop_H)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L,from.prop_L,strlen(from.prop_L)+1);
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.sink_mom[i],from.sink_mom[i]);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeHLMesons::deep_copy(ContractionTypeHLMesons const &rhs){
	rpc_deepcopy<ContractionTypeHLMesons>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeOVVpAA (VML *vmls, char *name,ContractionTypeOVVpAA *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeOVVpAA",name);
	 if (!vml_string (vmls, "prop_H_t0", &objp->prop_H_t0, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L_t0", &objp->prop_L_t0, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_H_t1", &objp->prop_H_t1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L_t1", &objp->prop_L_t1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeOVVpAA",name);
	return TRUE;
}
void rpc_print<ContractionTypeOVVpAA>::doit(ContractionTypeOVVpAA const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_H_t0,strlen(what.prop_H_t0)+1,spaces+" prop_H_t0 = ");
	rpc_print<char *>::doit(what.prop_L_t0,strlen(what.prop_L_t0)+1,spaces+" prop_L_t0 = ");
	rpc_print<char *>::doit(what.prop_H_t1,strlen(what.prop_H_t1)+1,spaces+" prop_H_t1 = ");
	rpc_print<char *>::doit(what.prop_L_t1,strlen(what.prop_L_t1)+1,spaces+" prop_L_t1 = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeOVVpAA::print(const std::string &prefix){
	rpc_print<ContractionTypeOVVpAA>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeOVVpAA>::doit(ContractionTypeOVVpAA &into, ContractionTypeOVVpAA const &from){
	  rpc_deepcopy<char *>::doit(into.prop_H_t0,from.prop_H_t0,strlen(from.prop_H_t0)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L_t0,from.prop_L_t0,strlen(from.prop_L_t0)+1);
	  rpc_deepcopy<char *>::doit(into.prop_H_t1,from.prop_H_t1,strlen(from.prop_H_t1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L_t1,from.prop_L_t1,strlen(from.prop_L_t1)+1);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeOVVpAA::deep_copy(ContractionTypeOVVpAA const &rhs){
	rpc_deepcopy<ContractionTypeOVVpAA>::doit(*this,rhs);
}

bool_t
vml_GparityMeasurement (VML *vmls, char *name,GparityMeasurement *objp)
{
	 if (!vml_ContractionType (vmls, "type", &objp->type))
		 return FALSE;
	switch (objp->type) {
	case CONTRACTION_TYPE_LL_MESONS:
		 if (!vml_ContractionTypeLLMesons (vmls, "contraction_type_ll_mesons", &objp->GparityMeasurement_u.contraction_type_ll_mesons))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_HL_MESONS:
		 if (!vml_ContractionTypeHLMesons (vmls, "contraction_type_hl_mesons", &objp->GparityMeasurement_u.contraction_type_hl_mesons))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_O_VV_P_AA:
		 if (!vml_ContractionTypeOVVpAA (vmls, "contraction_type_o_vv_p_aa", &objp->GparityMeasurement_u.contraction_type_o_vv_p_aa))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeLLMesons>(){
	 return CONTRACTION_TYPE_LL_MESONS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeHLMesons>(){
	 return CONTRACTION_TYPE_HL_MESONS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeOVVpAA>(){
	 return CONTRACTION_TYPE_O_VV_P_AA;
}
void rpc_deepcopy<GparityMeasurement>::doit(GparityMeasurement &into, GparityMeasurement const &from){
	  into.type = from.type;
	  switch(from.type){
	    case CONTRACTION_TYPE_LL_MESONS:
	      rpc_deepcopy<ContractionTypeLLMesons>::doit(into.GparityMeasurement_u.contraction_type_ll_mesons,from.GparityMeasurement_u.contraction_type_ll_mesons); break;
	    case CONTRACTION_TYPE_HL_MESONS:
	      rpc_deepcopy<ContractionTypeHLMesons>::doit(into.GparityMeasurement_u.contraction_type_hl_mesons,from.GparityMeasurement_u.contraction_type_hl_mesons); break;
	    case CONTRACTION_TYPE_O_VV_P_AA:
	      rpc_deepcopy<ContractionTypeOVVpAA>::doit(into.GparityMeasurement_u.contraction_type_o_vv_p_aa,from.GparityMeasurement_u.contraction_type_o_vv_p_aa); break;
	  };
}
void GparityMeasurement::deep_copy(GparityMeasurement const &rhs){
	rpc_deepcopy<GparityMeasurement>::doit(*this,rhs);
}
void rpc_print<GparityMeasurement>::doit(GparityMeasurement const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	  switch(what.type){
	    case CONTRACTION_TYPE_LL_MESONS:
	      rpc_print<ContractionTypeLLMesons>::doit(what.GparityMeasurement_u.contraction_type_ll_mesons,spaces+" union GparityMeasurement_u.contraction_type_ll_mesons = "); break;
	    case CONTRACTION_TYPE_HL_MESONS:
	      rpc_print<ContractionTypeHLMesons>::doit(what.GparityMeasurement_u.contraction_type_hl_mesons,spaces+" union GparityMeasurement_u.contraction_type_hl_mesons = "); break;
	    case CONTRACTION_TYPE_O_VV_P_AA:
	      rpc_print<ContractionTypeOVVpAA>::doit(what.GparityMeasurement_u.contraction_type_o_vv_p_aa,spaces+" union GparityMeasurement_u.contraction_type_o_vv_p_aa = "); break;
	  };
	std::cout << spaces << "}\n";
}
void GparityMeasurement::print(const std::string &prefix){
	rpc_print<GparityMeasurement>::doit(*this,prefix);
}
	 bool GparityContractArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool GparityContractArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool GparityContractArg::Vml(VML *vmls,char *instance){
		 if(!vml_GparityContractArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_GparityContractArg (VML *vmls, char *name,GparityContractArg *objp)
{
	 vml_class_begin(vmls,"GparityContractArg",name);
	 if (!vml_array (vmls, "meas", (char **)&objp->meas.meas_val, (u_int *) &objp->meas.meas_len, ~0,
		sizeof (GparityMeasurement), (vmlproc_t) vml_GparityMeasurement))
		 return FALSE;
	 else if(!UniqueID()){
	   printf("Got meas array of size %d:\n",objp->meas.meas_len);
	   for(int i=0;i<objp->meas.meas_len;i++) objp->meas.meas_val[i].print();	   
	 }
	 if (!vml_string (vmls, "config_fmt", &objp->config_fmt, ~0))
		 return FALSE;
	 else if(!UniqueID()) printf("Got config_fmt: %s\n",objp->config_fmt);

	 if (!vml_int (vmls, "conf_start", &objp->conf_start))
		 return FALSE;
	 if (!vml_int (vmls, "conf_incr", &objp->conf_incr))
		 return FALSE;
	 if (!vml_int (vmls, "conf_lessthan", &objp->conf_lessthan))
		 return FALSE;
	 if (!vml_FixGaugeArg (vmls, "fix_gauge", &objp->fix_gauge))
		 return FALSE;
	 vml_class_end(vmls,"GparityContractArg",name);
	return TRUE;
}
void rpc_deepcopy<GparityContractArg>::doit(GparityContractArg &into, GparityContractArg const &from){
	  into.meas.meas_len = from.meas.meas_len;
	  rpc_deepcopy<GparityMeasurement *>::doit(into.meas.meas_val,from.meas.meas_val,from.meas.meas_len);
	  rpc_deepcopy<char *>::doit(into.config_fmt,from.config_fmt,strlen(from.config_fmt)+1);
	  rpc_deepcopy<int>::doit(into.conf_start,from.conf_start);
	  rpc_deepcopy<int>::doit(into.conf_incr,from.conf_incr);
	  rpc_deepcopy<int>::doit(into.conf_lessthan,from.conf_lessthan);
	  rpc_deepcopy<FixGaugeArg>::doit(into.fix_gauge,from.fix_gauge);
}
void GparityContractArg::deep_copy(GparityContractArg const &rhs){
	rpc_deepcopy<GparityContractArg>::doit(*this,rhs);
}
CPS_END_NAMESPACE
