/*

In CPS, we generate random numbers in parallel using different random
number generators initialized with different seeds each seperated by 23.

We can put the numbers in a table

time       0  1  2  3  4  . . .   Ndrop . . . Ndrop+Ntake   . . .

                                |-------------------------|
gen0       x  x  x  x  x  . . . |  x    . . .      x      | . . .
gen1       x  x  x  x  x  . . . |  x    . . .      x      | . . .
gen2       x  x  x  x  x  . . . |  x    . . .      x      | . . .
gen3       x  x  x  x  x  . . . |  x    . . .      x      | . . .
 .         .  .  .  .  .  . . . |  .    . . .      .      | . . .
 .         .  .  .  .  .  . . . |  .    . . .      .      | . . .
gen(Nt*Nn) x  x  x  x  x  . . . |  x    . . .      x      | . . .
                                |-------------------------|

This program studies a certain correlation of numbers in the box showing above.
They are Ntake = 8 continuous columns starting from Ndrop = 1024.

The correlation do not go away when Ndrop get larger. You may verify
this by change Ndrop to a larger number (eg. Ndrop = 1024 * 128).

However, if the numbers in the table are generated by a single random
number generator, the correlation disappears. You can verify this by
commenting out the line "ran.Reset(seed)".

Luchang Jin

*/


#include <iostream>
#include <complex>
#include <util/random.h>

const double PI = 3.14159265359;

using namespace std;
using namespace cps;

double sqr(double x) {
  return x*x;
}

int main() {
  UGrandomGenerator ran;
  ran.Reset(1231);
  const int Nt = 256;
  const int Nn = 16;
  const int Ndrop = 1024;
  const int Ntake = 8;
  double sum = 0;
  double sigma = 0;
  for (int traj = 0; traj < Nt; traj++) {
    Complex a = 0;
    for (int id = 0; id < Nn; id++) {
      int seed = 123132 + 23 * Nn * traj + 23 * id;
      // Comment out the line below to see the correct result
      ran.Reset(seed);
      for (int i = 0; i < Ndrop; i++) {
        ran.Urand();
      }
      for (int i = 0; i < Ntake; i++) {
        a += polar(1.0, ran.Urand(PI,-PI));
      }
    }
    sum += norm(a);
    sigma += sqr(norm(a));
  }
  cout << "Expected : " << Nn * Ntake << endl;
  cout << "Mean     : " << sum / Nt << endl;
  cout << "Var      : " << sqrt (sigma / Nt - sqr(sum / Nt)) / sqrt (Nt) << endl;
  return 0;
}
