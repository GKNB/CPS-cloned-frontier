# $Id: regression.pl.in,v 1.16 2004-05-11 15:48:21 mcneile Exp $
# @configure_input@
# $Id: regression.pl.in,v 1.16 2004-05-11 15:48:21 mcneile Exp $ 
#--------------------------------------------------------------------
# 
# This perl script writes a shell script "regression.sh"
# that actually runs the tests. (This dual mode is
# required because of the limitations of QCDSP).
#

#
# Configurations: These are platform/config-dependant:
#

#
# General defs of versions and trusted versions:
#

# directory with good test data in it
$test_dir = "v5_0_0" ;
$error_tol = 0.001; 

@test_names = ( "f_hmd" , "f_hmd_dwfso", "g_hb" , "g_hmd" , "s_spect" ,  "w_spect" , "f_wilson_eig" ,  "xi_spect_gsum" , "f_stag_pbp" , "t_asqtad_pion" ) ; 




#  Create the test comparison for each test
#
#  this could be done with some fancy OO perl
#  techniques. Let us do something simple at first.
#

foreach $test (@test_names)
{
    $which_test{ $test }  = 1 ; 
}

    $which_test{ "t_asqtad_pion" }  = 2 ; 
#------ 

if( '@NOT_TESTING_QCDSP@' eq 'yes' ) {
# This makes it run autoconf version:
  $machine = '@target@';
  $parallel = '@TESTING_PARALLEL@';
  $executable = "@ARCH@.x";
} else {
# This is right for the parallel QCDSP version:
  $machine = "qcdsp";
  $parallel = "yes";
  $executable = "qcdsp.out";
}


#
# Configurations: These should be relevant always:
#

#The name of the shell script this will create:
$shellscript = "regression.sh";
$output_dir = "regressions";


# Variations:
#---------------------------------
if( $machine eq "qcdsp" || $machine eq "qcdoc" ) {
    $exec_prefix = "qrun ./";
} else {
    $exec_prefix = "./";
}

#--------------------------------------------------------------------

# Open the file which will contain the shell script which will run the tests:
open SHOUT,">$shellscript" or die "Could not open $shellscript!\n";

# clean up any old output
print SHOUT 'rm -f '.$output_dir.'/*.dat '."\n";

##
##  first compile 
##

print SHOUT "echo COMPILATION STATUS\n";
foreach $tni (@test_names){
    print SHOUT '#------------------------------------'."\n";

# Construct the name of the file which holds the original results:

# If we are on qcdsp, reset the machine before beginning the next run:
	if( $machine eq "qcdsp"  ) {
	    print SHOUT "echo Rebooting the board...\n";
	    print SHOUT "qreset_boot > qreset.log\n";
	}

# State which test is about to run, run it, and store the results:
	print SHOUT "cd ".$tni."\n";
# Remove any files associated with previous runs (i.e. *.dat)
	print SHOUT 'make -s -f Makefile_regression clean'."\n";
#       compile the code (do not echo the commands)
	print SHOUT 'make -s -f Makefile_regression'."\n";
#       check that the executable has been created
	print SHOUT 'if test ! -f '.$executable.' ; then'."\n";
	print SHOUT 'echo '.$tni." FAILURE\n";
##	print SHOUT "cd ..\n";

	print SHOUT "else\n";
	print SHOUT 'echo '.$tni." SUCCESS\n";
	print SHOUT "fi\n";
	print SHOUT "cd ..\n";

# Loop over to the next test:
}



#
#  now run the code
#

print SHOUT "echo TEST_CASE_STATUS\n";
foreach $tni (@test_names){
    print SHOUT '#------------------------------------'."\n";

# Construct the names of the files to store the results:
	$res_file = "../".$output_dir."/stdio.".$tni.".dat";
	$dat_file = "../".$output_dir."/data.".$tni.".dat";

# Construct the name of the file which holds the original results:

# If we are on qcdsp, reset the machine before beginning the next run:
	if( $machine eq "qcdsp"  ) {
	    print SHOUT "echo Rebooting the board...\n";
	    print SHOUT "qreset_boot > qreset.log\n";
	}

# State which test is about to run, run it, and store the results:
	print SHOUT "cd ".$tni."\n";
# Remove any files associated with previous runs (i.e. *.dat)
#       check that the executable has been created
	print SHOUT 'if test ! -f '.$executable.' ; then'."\n";
	print SHOUT "cd ..\n";

	print SHOUT "else\n";


# Run the program:
    $exec_cmd = $exec_prefix.$executable;
    print SHOUT "$exec_cmd > $res_file\n";

# test the resulting output
    $test_type = $which_test{$tni} ;
    if( $test_type eq "1" ) 
    {		
	&backwards_test() ;
    }
    else
    {
	check_file_output($tni,$res_file);
    }


# Clean up
	print SHOUT "make -s -f Makefile_regression clean\n";
	print SHOUT "cd ..\n";
	print SHOUT "fi\n";

# Loop over to the next test:
}

print SHOUT "echo ------------------------------\n";
print SHOUT "echo DISCLAIMER\n";
print SHOUT "echo Please also test this code on \n";
print SHOUT "echo a physical system before using in \n";
print SHOUT "echo production runs \n";
print SHOUT "echo ------------------------------\n";



# close the script file
close SHOUT;

exit;


#
#  collection of testing functions
#


#
# compare against old tests data
#
sub backwards_test
{
# Grab all of the *.dat output files and sling them into a single file:
    print SHOUT "perl ../combine_files.pl *.dat > $dat_file\n";
    print SHOUT "cd ..\n";
# Diff the output and report if the output differs from that expected:
# Drop back to the test directory:


    print SHOUT "cd regressions ; perl check_data.pl $tni  $error_tol  $test_dir\n" ;
    print SHOUT "cd ../".$tni."\n" ;


}


#
#  
#
#

sub check_file_output
{
    my ($name ,$log) = @_ ;

    print SHOUT "ans=`grep test_result ".$log." | awk \'{print \$3  }\'`\n";
    print SHOUT "echo ".$name." \$ans \n" ; 
}
