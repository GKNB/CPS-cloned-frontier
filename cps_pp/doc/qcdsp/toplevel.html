

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta name="GENERATOR" content="TtH 2.92">


<title> An Introduction to Using the QCDSP Computer </title>
</head>
<body>
 
<h1 align="center">An Introduction to Using the QCDSP Computer </h1>

<h3 align="center">B&#225;lint Jo&#243; and Robert D. Mawhinney </h3>



<p>








          
<h1>Contents </h1><a href="#tth_chAp1"
>1&nbsp; Introduction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1"
>1.1&nbsp; Organisation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.2"
>1.2&nbsp; Notational conventions</a><br />
<a href="#tth_chAp2"
>2&nbsp; Hello World</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Foo or Bar?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; Front End and Logging In</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; QOS and Environment Variables</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; The QC-Shell and Booting the QCDSP</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5"
>2.5&nbsp; Booting the QCDSP</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.6"
>2.6&nbsp; Hello World</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.7"
>2.7&nbsp; Summary</a><br />





<a href="#tth_chAp3"
>3&nbsp; Basic Programming of the QCDSP</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; Introduction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; Parallelism in the QCDSP Computer</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; Brief description of the QCDSP Architecture</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; Programming Interface</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; Who Am I?</a><br />


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; Nearest Neighbour Communications</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.7"
>3.7&nbsp; Getting To Know Your Neighbours</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.8"
>3.8&nbsp; Summary of Chapter</a><br />




&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.9"
>3.9&nbsp; Programming Exercise</a><br />




<a href="#tth_chAp4"
>4&nbsp; Collective Communication</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; What are Collective Communications ?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; Who Communicates?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; Global Communication in General</a><br />




&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; Global Communication on the QCDSP</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; Global Reduction Algorithms for Ring Architectures</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; A simple collective communications library</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7"
>4.7&nbsp; Summary of Chapter</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.8"
>4.8&nbsp; Exercise</a><br />
<a href="#tth_chAp5"
>5&nbsp; I/O on the QCDSP</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; Introduction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; Parallel I/O</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; Parallel I/O with NTFs, qread and qload</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4"
>5.4&nbsp; Creating Node Tagged files using qread</a><br />


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5"
>5.5&nbsp; Loading data with qload</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6"
>5.6&nbsp; Digression for Lattice Folk</a><br />


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7"
>5.7&nbsp; Serial I/O</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8"
>5.8&nbsp; Summary</a><br />










<a href="#tth_chAp6"
>6&nbsp; Compiling, Linking and Libraries</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; Overview</a><br />


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; Tartan C++ Software Tools</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; The C++ Compiler</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4"
>6.4&nbsp; QCDSP Runtime and IO Libraries</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5"
>6.5&nbsp; Converting TOFF to COFF</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.6"
>6.6&nbsp; A typical Makefile</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.7"
>6.7&nbsp; Linker Control Files</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.8"
>6.8&nbsp; The Tartan Archiver</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.9"
>6.9&nbsp; Summary</a><br />
<a href="#tth_chAp7"
>7&nbsp; Single Processor Optimisation I - Using CRAM</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; Introduction</a><br />


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; Overlay Programming and the Linker Control File</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; Step One: Straight C++</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4"
>7.4&nbsp; Step 2: Relocate C++ to CRAM</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.5"
>7.5&nbsp; Step 3: Assembler optimisation</a><br />


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.6"
>7.6&nbsp; Summary</a><br />



 

 <h1><a name="tth_chAp1">
Chapter 1 </a><br />Introduction</h1>
These notes are an attempt at gently introducing a new
user to the QCDSP computer. It reflects my own particular
path of learning (which may or may not do me credit). 

<p>
 <h2><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Organisation</h2>
We begin in chapter <a href="#c:HelloWorld">2</a> where we discuss
some introductory aspects of the QCDSP, including how 
to boot a QCDSP machine and how to run a simple 
<em>``Hello World''</em> application.

<p>
 <h2><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Notational conventions</h2>
Generally, when illustrating dialogue with the computer
we shall use the <tt>teletype font</tt>. Filenames shall usually
be denoted in <b>bold face</b>.

<p>
 <h1><a name="tth_chAp2">
Chapter 2 </a><br />Hello World</h1><a name="c:HelloWorld">
</a>

 <h2><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Foo or Bar?</h2>
It is the long and honourable tradition of user guides to 
begin by a walk through example of how to get a simple program
(usually named <b>foo.c</b> or <b>bar.c</b> in more reputable 
texts) to run on a certain development platform. Such a program
usually does something simple like write the message <em>``Hello World''</em>
to the screen. In this chapter we should like to show how to 
get such a program running on a QCDSP computer.

<p>
 <h2><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Front End and Logging In</h2>
The QCDSP is a parallel system that is accessible through a <em>front end</em>
 &nbsp;host, which is a possibly simpler, serial computer such as a Sun Workstation.

<p>
This is an accepted principle in supercomputing circles. For example,
the Thinking Machines Corporation Connection machines were often 
accessed from a Sun front end, as were some of the Elenia-Quadrics
supercomputers. Cray T3E computers often have another Cray supercomputer 
(such as a J90 or a YMP) as their front end.

<p>
It is important to point out, however, that the Connection Machine and 
Quadrics machines were true <em>back end</em> machines in the sense that
user programs ran on the front end Sun workstation, and the parallel hardware
was controlled entirely by the front end, usually for array operations.
The Cray and QCDSP supercomputers are different. They compute independently
of the front end. The front end however provides important services such
as a compilation environment, control to boot the parallel machines and
disk space for the data produced by the QCDSP. 

<p>
The QCDSP front end discussed in the rest of this section is a Sun
workstation running the SunOS 4 variant of the UNIX operating system.
Before being able to log in one requires an account to be set up
on the system, which should be requested from one of the systems staff
of the QCDSP collaboration<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>.

<p>

<h3>Login Procedures</h3>
In the following example I shall use a host called 
<em>qcdhost.phys.columbia.edu</em>, which is the front end to two QCDSP 
boards (each containing 64 processors). The QCDSP boards are themselves
known as <em>q_1</em> and <em>q_2</em>. This machine 
is also the front end to some other machines of which more will be said later.

<p>
Logging in to QCDSP is done according to the standard network login procedure.
One can use <tt>telnet</tt> to reach the host from anywhere on the Internet
although nowadays the more secure SSH login is recommended, which apart
from forwarding X-Windows connections also encrypts the network 
communications and does strict host-name resolutions. As an example I use
my current machine which is named <em>lattice2</em> &nbsp;to log into <em>qcdhost</em> &nbsp;via <tt>ssh</tt>.

<p>

<pre>
[bj@lattice2 bj]$ ssh bj@qcdhost.phys.columbia.edu
bj@qcdhost.phys.columbia.edu's password: 
Last login: Wed Mar 29 11:15:05 2000 from lattice2.pa.uky.
SunOS Release 4.1.4 (QCDHOST.sz) #2: Fri Nov 20 14:32:57 EST 1998
(qcdhost:/homeqs0/bj)%

</pre>

<p>
Note that the password needs to be entered at the prompt in the second
line, but, as is characteristic of UNIX the password is not echoed back to the 
terminal. If <tt>ssh</tt> is not available one can use <tt>telnet</tt> &nbsp;:

<pre>
[bj@lattice2 bj]$ telnet qcdhost.phys.columbia.edu
Trying 128.59.196.11...
Connected to qcdhost.phys.columbia.edu.
Escape character is '^]'.


SunOS UNIX (qcdhost)

login: bj
password:
Last login: Wed Mar 29 11:20:05 2000 from lattice2.pa.uky.
SunOS Release 4.1.4 (QCDHOST.sz) #2: Fri Nov 20 14:32:57 EST 1998
(qcdhost:/homeqs0/bj)%

</pre>
or <tt>rlogin</tt>:

<pre>
[bj@lattice2 bj]$ rlogin -lbj qcdhost.phys.columbia.edu
bj@qcdhost.phys.columbia.edu's password: 
Last login: Wed Mar 29 11:25:05 2000 from lattice2.pa.uky.
SunOS Release 4.1.4 (QCDHOST.sz) #2: Fri Nov 20 14:32:57 EST 1998

</pre>
although in the latter two cases the protocols send the user
passwords over the networks unencrypted and liable to interception
by pesky hacksters worldwide. We note that when using <em>rlogin</em>
one ends up talking to a <em>SSH</em> connection at the QCDSP end.

<p>
 <h2><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;QOS and Environment Variables</h2>

<h3>QOS Version</h3>
The QCDSP computer runs an operating system entitled <em>QOS</em>.
Numerous revisions of <em>QOS</em> exist with the current version at the
time of writing this note being <em>QOS 5.3.3</em>. A UNIX shell
environment variable, <tt>QOS_VERS</tt> is used to identify the version
of <em>QOS</em> that a given user will be using.  This environment
variable should be set automatically be the shell startup files at the
time the user logs in. In particular <em>qcdhost</em> supports the <em>
TC-Shell</em> (<tt>tcsh</tt>) and the startup file in which  the environment 
variables are set is <b>.cshrc</b>.

<p>
The toplevel <em>QOS</em> directory on <em>qcdhost</em> is

<p>
<tt>/qcdsp/sfw/qos.&lt;version&#62;</tt>, 

<p>
where <tt>version</tt> refers to the
operating system revision held by the variable <tt>QOS_VERS</tt>. For version
5.3.3 the relevant directory is 

<p>
<tt>/qcdsp/sfw/qos.5.3.3</tt>&nbsp;.

<p>

<h3>The Tartan C++ Compiler</h3>
Another set of environmental variables that need to be set are related
to the installation of the Tartan C++ compiler. The two variables in 
my <b>.cshrc</b> file at the time of writing are <tt>TC_DIR</tt> and <tt>TC_BOARD</tt>.
Currently these two variables are set to the following values:
<pre>
TC_DIR=/qcdsp/sfw/qos.&lt;version&#62;/usr:/usr/local/tartan/v2.1
TC_BOARD=qcdsp_v&lt;version&#62;

</pre>
where <tt>version</tt> is the value of the variable <tt>QOS_VERS</tt>. I believe
that <tt>TC_DIR</tt> is a list of directories which contain subdirectories
for <tt>
identifies, which QOS operating system version interfaces the hardware
is compliant with (<em>but this is guesswork on my part. Bob, please enlighten us here</em>.) In any case these variables need to be set to sensible values
for code to compile, link, resolve and run successfully on the QCDSP computer.

<p>

<h3>The QOS Toplevel Directory</h3>
Let us now pass a cursory glance at the toplevel QOS directory.
A simple listing of files therein reveals the following directory 
contents

<pre>
(qcdhost:/qcdsp/sfw/qos.5.3.3)%	ls
Makefile                        make.log
README                          os_03_20_00_18:36.tar.gz
announce                        plaq/
bug/                            qio/
diag/                           qio_qker/
distrib/                        qker/
example/                        rts/
include/                        usr/
lib/                            util_prog/
machines/

</pre>

<p>
Currently for us the most interesting of these are going to be 
the subdirectories called <tt>machines</tt> and <tt>usr</tt>. In the
former are defined the various machine partitions available, whereas
in the latter reside some useful header files describing the
parallel programming communications objects.

<p>
Looking at the machines directory reveals the following list:

<pre>
(qcdhost:/qcdsp/sfw/qos.5.3.3)%	cd machines/
(qcdhost:/qcdsp/sfw/qos.5.3.3/machines)% ls
Makefile      cc_1/         q4_1/          q6_2/          q_1/
c4_1/         cc_2/         q4_2/          q7_1/          q_2/
c4_2/         cc_3/         q5_1/          q7_2/          src/
cb_2/         q3_1/         q5_2/          q8_1/
cb_3/         q3_2/         q6_1/          q8_2/

</pre>

<p>
Each directory with the exception of <tt>src</tt> refers to a QCDSP processor
partition. We are qoing to use machines <tt>q_1</tt> and <tt>q_2</tt> for the 
rest of this guide so let us examine <tt>q_1</tt>:

<pre>
(qcdhost:/qcdsp/sfw/qos.5.3.3/machines/q_1)% ls
boot_n0_notest.qrb      notest.qrb              q_1_sec4/
boot_n0_notest_25.qrb   notest_25.qrb           q_1_sec5/
debug.qrb               q_1@                    q_1_sec6/
debug_25.qrb            q_1_pri0/               standard.qrb
debug_notest.qrb        q_1_sec1/               standard_25.qrb
debug_notest_25.qrb     q_1_sec2/
dev                     q_1_sec3/

</pre>

<p>
Most of the files in this directory have the suffix <b>.qrb</b>. 
These files are the configuration files for booting the QCDSP computer.
They specify which operating systems kernels are to be sent to the
QCDSP daughterboards, what speed the inter processor communications 
should run at, what self test procedures to carry out at boot time, <em>etc</em>&nbsp;.
In normal usage, the file <b>standard.qrb</b> should probably be used
(the manner of its use will be described in the next section).

<p>
The file <b>q_1</b> is a symbolic link to a program called the 
<em>QC-Shell</em>, which is the shell environment used to boot, and 
run programs on the QCDSP, of which we shall say more below.

<p>
 <h2><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;The QC-Shell and Booting the QCDSP</h2>

<h3>The QC-Shell - <tt>qcsh</tt></h3>
So far we have been happily romping around the filesystem of the 
front end host. Now comes the time to actually boot a set of processors
for our use.

<p>
Interaction with the QCDSP generally takes place through the aforementioned
<em>QC-Shell</em>. This effectively is the usual <em>TC-Shell</em> &nbsp;with some 
bolted on features (in the form of built in commands) to manipulate the 
QCDSP computer. Commands for manipulating the QCDSP begin with the letter
<tt>q</tt>. Some useful commands which we shall be using later are 
<tt>qreset_boot</tt>, <tt>qrun</tt> and <tt>qprintf</tt>. 

<p>
We note the distinction between a shell built in command and UNIX
commands. For example in a normal UNIX <em>TC-Shell</em> &nbsp;the command
<tt>echo</tt> is a built in command of the shell, while the usual
UNIX command <tt>ls</tt> is an executable program usually residing in
the directory <tt>/bin</tt>.  Hence the command <tt>ls</tt> is available to
all shells, whereas the command <tt>echo</tt> is shell specific (although
it is implemented in almost all UNIX shells). 

<p>
Like most UNIX-shell like shells the <em>QC-Shell</em> &nbsp;allows for
self initialisation through a startup file. In the case of the <em>
QC-Shell</em> this file is called <b>.qcshrc</b>. If your account has been
set up properly you should find a <b>.qcshrc</b> file in your toplevel
homedirectory. My one reads as follows:

<pre>
source ~/.cshrc
qinit
set curdir = `pwd`
source $curdir/dev
qset_qd_verbose 2
qset_qd_scsi_tree_verbose 2
qset_reset_boot f standard.qrb
qset_exit_info 5 exit.info
qreset_boot

</pre>

<p>
One of the chief functions of the <b>.qcshrc</b> file is to boot the 
QCDSP computer. This is accomplished by various commands in the 
<b>.qcshrc</b> file. 

<p>
The <tt>qinit</tt> command initialises the QCDSP system and starts up
the <tt>Qdaemon</tt> system daemon which is responsible for for booting
the QCDSP machine, loading and executing programs, performing self tests
and other important tasks.  By ``sourcing''
the <b>dev</b> file in the current directory, several variables are 
defined in the shell specifying amongst other things the boot-debug
network device (in this case SCSI ID) which is used to communicate
with the QCDSP boards. <b>Note that this .qcshrc expects you to be
in the correct machine directory at the time of invocation of the 
QC-Shell, where the file dev resides</b>.

<p>
Thereafter some boot time verbosity levels are set to specify how 
much of the various Qdaemon messages and other test results should be sent
to the standard output for boot time diagnostic purposes. These levels 
are set by the <tt>qset_qd_verbose</tt> and the 
<tt>qset_qd_scsi_tree_verbose</tt> 
commands.

<p>
The configuration (<b>.qrb</b>) file to use when booting, or resetting
the QCDSP is specified with the command <tt>qset_reset_boot</tt>. In
my case it is the <b>standard.qrb</b> file which was mentioned in the
last section. 

<p>
The <tt>qset_exit_info</tt> command itself is used to <em>what's it 
used to do then ?</em> 

<p>
Once all these settings have been put into effect the machine is 
finally booted through the command <tt>qreset_boot</tt>. Incidentally
this is also a useful bail out command. Should the QCDSP crash or deadlock,
or for whatever reason we may want to reboot the computer, it can be 
done using the <tt>qreset_boot</tt> command in the <em>QC-Shell</em>.

<p>
More information on these commands will be given in the
advances stages of this manual (if it ever gets that far...)

<p>
 <h2><a name="tth_sEc2.5">
2.5</a>&nbsp;&nbsp;Booting the QCDSP</h2>
Now that we have examined how one boots the QCDSP, let us do it
by invoking the <em>QC-Shell</em>. The magic incantation for machine <em>q_1</em>
is:

<pre>
(qcdhost:/homeqs0/bj)% cd /qcdsp/sfw/qos.5.3.3/machines/q_1
(qcdhost:/qcdsp/sfw/qos.5.3.3/machines/q_1)% ./q_1

</pre>

<p>
The first command takes to the machine directory, where the <b>dev</b>
and <b>.qrb</b> files live. Recalling that <tt>q_1</tt> is a symbolic link
the <tt>qcsh</tt> command, it can be seen that the second command invokes
the <em>QC-Shell</em>.

<p>
<b>Aside: </b>
Since getting to the correct machine directory involves a lot of typing
it might be useful to set up some sort of shell alias to allow us
reaching the directory more quickly. In my <b>&#126; .cshrc</b> file I have 
two variables set:

<pre>
set q_1 = /qcdsp/sfw/qos."$QOS_VERS"/machines/q_1
set q_2 = /qcdsp/sfw/qos."$QOS_VERS"/machines/q_2 

</pre>
Hence I can reach the <em>q_1</em> and <em>q_2</em> directories respectively
by just typing <tt>cd q_1</tt> and <tt>cd q_2</tt> respectively.

<p>
The invoking of the <em>QC-Shell</em> should start a large set of messages
scrolling up your screen, giving you the results of boot time diagnostics
and self tests. Some important ones to look out for:

<pre>
qinit:  qcsh initialized

Qdaemon state is:
        qdaemon task is INITIALIZE_DAEMON
        qdaemon abort no and resume no
        QCDSP not synchronous
        SCSI tree coordinates selected:  mb 0,  db 0,  
        Load address 0 (hex), data 0 (hex) from screen
        Read address (hex) 0, blksize 0 (hex) from screen
        Read output to screen in node tagged format
        Run entry address from file
        SCSI packet and payload size:  512  488
        Run kernels not installed on all nodes
        Hardware debugging level is 0
        Not decoding packet headers

</pre>
This message signifies that the <em>QC-Shell</em> has been initialized
and the so called <tt>Qdaemon</tt> has been started. The <tt>Qdaemon</tt>
is the primary source of interaction with the QCDSP. Note also 
the <tt>Qdaemon</tt> message has been displayed twice, once for entry 
into the specific service routine and once at the exit. This is the 
result of setting the verbosity level in the <b>.qcshrc</b> file.
Carrying on with the boot process the following messages should appear
at some point:

<pre>
qset_boot_szdevice: /dev/rsz8 open
qset_boot_szdevice:  status directory /qcdsp/machines/status/qcdhost.rsz8
qdaemon verbose level: 2
SCSI tree verbose level: 2
        exit info level and filename:  5   exit.info
Qdaemon:  PRIMARY Q-SHELL - hardware reset enabled
Qdaemon:  pause between unsuccessful SCSI bus reads is 10000 microseconds

Qdaemon state is:
        qdaemon task is RESET_BOOT
        qdaemon abort no and resume no
        QCDSP not synchronous
        SCSI tree coordinates selected:  mb 0,  db 0,  
ResetBoot::ResetBoot:  Hello

</pre>
These messages show the results of trying to talk via
the SCSI bus to the QCDSP, in particular that the SCSI bus has been 
found and that the Qdaemon has now entered the machine reset and boot
service. If all is well the QCDSP should reply as:

<pre>
Szm::inquiry:   COLUMBIA QCDSP
ResetBoot::ResetBoot:  Mb 0 found
ResetBoot:  Working on scsi layer 0
ResetBoot:  turning off LED's on layer 0
ResetBoot:  starting non SCU NGA setup on layer 0
ResetBoot:  starting DramStdTest0 on layer 0
ResetBoot:  DramStdTest0 passed for layer 0
ResetBoot:  loading run kernels to layer 0

</pre>
If you do not get the <tt>COLUMBIA QCDSP</tt> message then
something is wrong. The rest of the messages display various test 
results.

<p>
The various motherboards are arranged in a tree structure with
boot time communication being done via a SCSI bus. One of the
next tasks of the boot process is to find out about the SCSI tree.
This information is also echoed back at boot time (given the verbosity
levels in my startup files):

<pre>
SCSITree:  Summary of SCSITree object

  SCSIPath information for motherboard 0
    SCSI ID path:       
    SCSI branch path:   

  SCSIBranch information for branch 0

  SCSIBranch:  information for branch 0

    For SCSI ID 0 the device is motherboard 0 (serial number 38)
        at slot 0 and crate 0xf1

    For SCSI ID 1  no device is present

    For SCSI ID 2  no device is present

    For SCSI ID 3  no device is present

    For SCSI ID 4  no device is present

    For SCSI ID 5  no device is present

    For SCSI ID 6  no device is present

    For SCSI ID 7  no device is present

  SCSILayer information for layer 0
    SCSILayer:  Motherboards in this layer
          0

</pre>
Hence we see that in booting <em>q_1</em> there is only one motherboard
on SCSI Id 0.

<p>
The machine then proceeds to boot all the daughter boards in turn.
This is done by sending boot kernels to all the daughter boards. 
Useful messages to look out for are 

<pre>
DSPSerialInit:  getting information for all motherboards
DSPSerialInit:  All MB's responded with no errors

DBBoot:  Booting all Db's on all Mb's
        All nodes 1 to 63 on MB   0 booted and responded
DBBoot:  All MB's responded after Db boot
ResetBoot:  finished send of boot kernels to dbs

DSPSerialInit:  getting information for all motherboards
DSPSerialInit:  All MB's responded with no errors

DSPSerSwitchTest:  Starting to check status for all motherboards
        Network switched over all routes 10 times.
        Maximum of 10 reads done to clear receive buffer
        Mb   0 passed test
DSPSerSwitchTest:  All requested MB's responded.
        All DSP serial connections OK.

</pre> 
that show that all the motherboards and daughterboards booted OK and 
that the serial connections have been checked and are responding.
If the machine gets this far, the boot kernels boot the node gate
arrays (NGA-s) and perform a DRAM memory test. If this succeeds
the runtime kernels are downloaded to the daughterboards as 
evidenced by messages such as:

<pre>
ResetBoot:  starting NGA boot for dbs
ResetBoot:  finished NGA boot for dbs
ResetBoot:  starting DRAM stdtest for dbs
	Checking DRAM stdtest for dbs on Mb 0
ResetBoot:  DRAM Stdtest on all dbs passed
ResetBoot:  loading run kernels to dbs

</pre>
Finally the machine is synchronised and the Serial Communications
are set up. At this point some communications tests are performed
(even and odd wire tests). Healthy messages look along the lines
of

<pre>
ResetBoot::SCUSetup:  Beginning SCU setup of all nodes
ResetBoot::Sync:  Beginning to synchronize QCDSP
ResetBoot::Sync:  Checking that all nodes have sync set
ResetBoot::Sync:  QCDSP synchronous
ResetBoot:  running even wire send SCU test 

ResetBoot:  running odd wire send SCU test 

ResetBoot:  SCU test passed
ResetBoot::InitNodeStat:  starting send of NodeStat
ResetBoot::InitNodeStat:  starting build of NodeTable
NodeTable::NodeTable:  constructor invoked for 1 motherboards
ResetBoot::InitNodeStat:  NodeTable complete

</pre>

<p>
Finally if all goes well the Qdaemon will report that it has exited
the boot service by the message

<pre>
Qdaemon state is:
        qdaemon task is RESET_BOOT
        qdaemon abort no and resume no
        QCDSP synchronous
        SCSI tree coordinates selected:  mb 0,  db 0,  

</pre>
and the <em>QC-Shell</em> will likewise show its status message

<pre>
qcsh after RESET_BOOT:
	All nodes selected with SCSI tree coordinates

</pre>
and the <b>boot process is complete</b>. Your shell prompt should
turn into something along the lines of 

<pre>
(qcdhost/qcdsp/sfw/qos.5.3.3/machines/q_1: qcsh[q_1])% 

</pre>

<p>
Congratulations! You have now booted a QCDSP supercomputer.
Some things to be aware of

<ul>
<li>The <em>QC-Shell</em> does not really like lots of processes going on in parallel.
Recall that it is designed to interact with the QCDSP. This shell really
should be run only to submit QCDSP jobs. Compiling, editing, e-mailing
and the like should be carried out from the usual login <em>TC-Shell</em>.</li>

<li>
While in the <em>QC-Shell</em> you are blocking everyone else's access to a potential
HPC resource. (From a 3.2Gflop board up to a Tflops scale supercomputer.)
Spend your time in it wisely.</li>

<li>
If things become messy you can always type <tt>qreset_boot</tt> to reboot
the system.</li>
</ul>

<p>
 <h2><a name="tth_sEc2.6">
2.6</a>&nbsp;&nbsp;Hello World</h2> 

<h3>Compiling the Program</h3>
The time has now come to execute the <em>Hello World</em>&nbsp;application.
The easiest method is to take a copy from the directory of programming
examples. You can do this by typing:

<pre>
(qcdhost:/homeqs0/bj)% cd /qcdsp/sfw/qos.5.3.3/example/
(qcdhost:/qcdsp/sfw/qos.5.3.3/example)% tar cf - hello_world | ( cd ; tar xvf - )
x hello_world/Makefile, 608 bytes, 2 tape blocks
x hello_world/main.C, 1233 bytes, 3 tape blocks
x hello_world/hello_world.ctl, 188 bytes, 1 tape blocks
x hello_world/main.tof, 3076 bytes, 7 tape blocks
x hello_world/main.lst, 2113 bytes, 5 tape blocks
x hello_world/hello_world.map, 14453 bytes, 29 tape blocks
x hello_world/hello_world.outtof, 15276 bytes, 30 tape blocks
x hello_world/hello_world.out, 14654 bytes, 29 tape blocks

</pre>
This should copy the <b>hello_world</b> directory to your homedirectory.
A nice makefile has been provided so that we can build the application
by executing the commands:

<pre>
(qcdhost:/homeqs0/bj)% cd hello_world/

</pre>
to go to the source directory and then:

<pre>
(qcdhost:/homeqs0/bj/hello_world)% make clean

</pre> 
to remove the currently built stuff so we can do a clean 
rebuild. The computer should respond with 

<pre>
rm -f  *.tof *.lst *.map core *.qin *.out *.outtof *.ctl \ .

</pre>
We perform the build by using the command <tt>make</tt>&nbsp;:

<pre>
(qcdhost:/homeqs0/bj/hello_world)% make

</pre>
to which the computer should reply:

<pre>
tcpp -c -mb -km -kc -kl -q main.C
tcpp  -e hello_world.outtof -mb -km -kc -kl -q main.tof  \
   tcio30bs.olb 
Tartan Linker for QCDSP version 5.3.2, modified 1/11/99 by RDM
Memory = 0x80000, stack = 0x1000, heap = 0x1000

(See transcript written on "/homeqs0/bj/hello_world/hello_world.map"
for additional information.)
t2c hello_world.outtof hello_world.out

</pre>
In the first line, the <tt>make</tt> system instructs the
Tartan C++ <tt>tcpp</tt> compiler to compile the source file <b>main.C</b>
which is the source for the actual <em>hello_world</em> application. The second
invocation of <tt>tcpp</tt> links the result of the compilation with the run time 
system to produce a file in the common object format. Finally the <tt>t2c</tt>
command creates an executable format suitable for the QCDSP. The QCDSP 
executable is the one called <b>hello_world.out</b>.

<p>

<h3>Running The Application</h3>
Once the application has been built, it should be run.
First boot the QCDSP. This time around we will use machine <em>q_2</em>.

<pre>
(qcdhost:/homeqs0/bj/hello_world)% cd /qcdsp/sfw/qos.5.3.3/machines/q_2
(qcdhost:/qcdsp/sfw/qos.5.3.3/machines/q_2)% ./q_2

</pre>
after booting has completed we get the prompt:

<pre>
(qcdhost/qcdsp/sfw/qos.5.3.3/machines/q_2: qcsh[q_2])% 

</pre>

<p>
To run the <tt>hello_world</tt> application we use the <tt>qrun</tt> 
command:

<pre>
(qcdhost/qcdsp/sfw/qos.5.3.3/machines/q_2: qcsh[q_2])% cd ~/hello_world/
(qcdhost/homeqs0/bj/hello_world: qcsh[q_2])% qrun hello_world.out

</pre>
The results should be a bunch of <tt>Qdaemon</tt> messages,
indicating that the executable is being loaded to the 
QCDSP, followed by the output from Motherboard 0,
daughterboard 0:

<pre>
Hello world
Motherboard and daughterboard numbers for this node:  0 0
Unique ID for this node:  0
Physics coordinates for this node:  0, 0, 0, 0
The square of 0 is 0
The square of 1 is 1
The square of 2 is 4
The square of 3 is 9
The square of 4 is 16
The square of 5 is 25
The square of 6 is 36
The square of 7 is 49
The square of 8 is 64
The square of 9 is 81

</pre>
followed by various exit information messages.

<p>
The output of node 0 (Motherboard 0, Daughterboard 0) is always
echoed to the standard output. The output of other nodes are 
saved to various buffers on the nodes. We can retrieve the saved
output from the processors using the <tt>qprintf</tt> command, which
sends the saved messages to the standard output. After some Qdaemon
messages the results should look like

<pre>
Qdaemon state is:
        qdaemon task is PRINTF
        qdaemon abort no and resume no
        QCDSP synchronous
        All nodes selected with SCSI tree coordinates

Qdaemon:  user print buffer for Mb 0 and Db 0 (SCSI tree coordinates)
Buffer wrap count 0

Hello world
Motherboard and daughterboard numbers for this node:  0 0
Unique ID for this node:  0
Physics coordinates for this node:  0, 0, 0, 0
The square of 0 is 0
The square of 1 is 1
The square of 2 is 4
The square of 3 is 9
The square of 4 is 16
The square of 5 is 25
The square of 6 is 36
The square of 7 is 49
The square of 8 is 64
The square of 9 is 81

Qdaemon:  user print buffer for Mb 0 and Db 1 (SCSI tree coordinates)
Buffer wrap count 0

Hello world
Motherboard and daughterboard numbers for this node:  0 1
Unique ID for this node:  1
Physics coordinates for this node:  0, 0, 0, 1
The square of 0 is 0
The square of 1 is 1
The square of 2 is 4
The square of 3 is 9
The square of 4 is 16
The square of 5 is 25
The square of 6 is 36
The square of 7 is 49
The square of 8 is 64
The square of 9 is 81

</pre> 
and so on for all the processors on the machine.

<p>
Congratulations! If you have followed all that I detailed here you
have now wasted the computer time of a 3.2GFlop peak speed development
board to print ``Hello World'' and some squares of numbers on the screen.

<p>

<h3>Exiting QCDSP</h3>
To exit fromt the QCDSP simply logout of the <em>QC-Shell</em> by typing
<tt>exit</tt>.

<p>
 <h2><a name="tth_sEc2.7">
2.7</a>&nbsp;&nbsp;Summary</h2>
After discussing logging in to the QCDSP system. I said a few introductory
remarks about QOS and the environmental variables needed in the shell
to be able to use QCDSP properly. I then described the boot process for the
machine. Finally I have gone through the process of building the example
<em>Hello_World</em> &nbsp;application, running it and retrieving the standard
output from the various QCDSP processor buffers to where they were saved.

<p>
This is the minimal subset of knowledge needed to be able to write and
execute programs on the QCDSP computer.

<p>

<h3>QOS and Shell Environment Summary</h3>
The login startup files should set the environmental variables <tt>QOS_VERS</tt>
, <tt>TC_DIR</tt> and <tt>TC_BOARD</tt>. The current QOS version at the time
of writing this document is version 5.3.3.

<p>
The toplevel QOS directory is <tt>/qcdsp/sfw/qos.&lt;version&#62;</tt>. The 
available machine partitions are in <tt>/qcdsp/sfw/qos.&lt;version&#62;/machines</tt>.
The QCDSP specific include files are in <tt>/qcdsp/sfw/qos.&lt;version&#62;/usr/include</tt> and the QCDSP run time libraries are in <tt>/qcdsp/sfw/qos.&lt;version&#62;/usr/lib</tt>, where <tt>version</tt> is the value held in the <tt>QOS_VERS</tt>.

<p>

<h3>Booting Summary</h3>
Go to the relevant machine directory, and invoke the <em>QC-Shell</em> using
the symbolic link provided (usually the same as the machine name). To use
machine <em>q_2</em> for example the incantation is 

<pre>
(qcdhost:/homeqs0/bj)% cd /qcdsp/sfw/qos.5.3.3/machines/q_2
(qcdhost:/homeqs0/bj)% ./q_2

</pre>
The machine should then boot if all goes well.

<p>

<h3>Compilation Summary</h3> 
Currently we did not detail compilation. We simply used the 
makefiles provided, which set the required compilation flags,
and performed the linking. We recommend copying these makefiles
for now. 

<p>
The compiler is named <tt>tcpp</tt>, which is the Tartan C++ compiler.
There is also a utility <tt>t2c</tt> which turns the output of the 
compilation and linking into an executable suitable for the QCDSP.
The QCDSP executables produced by the makefile have the <b>.out</b>
suffix.

<p>

<h3>Running Summary</h3>
Once the executable has been built, it can be run using the <tt>qrun</tt>
command. The output from processor 0 (Motherboard 0, Daughterboard 0),
is automatically echoed to the standard output. The saved standard output
buffers from the QCDSP processors can be retrieved to the standard output
of the front end host using the <tt>qprintf</tt> command. 

<p>

<h3>Miscalleny</h3>
The QCDSP computer can be reset with the <tt>qreset_boot</tt>. The 
QCDSP machine can be freed up for others by simply logging out of 
the <em>QC-Shell</em>&nbsp;using the <tt>exit</tt> command.

<p>
This concludes the ``Hello World'' chapter. In the next chapter
we shall discuss interprocessor communications.

<p>
 <h1><a name="tth_chAp3">
Chapter 3 </a><br />Basic Programming of the QCDSP</h1>

 <h2><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Introduction</h2>
This chapter is intended as a guide to the basic
system calls implemented on the QCDSP computer.

<p>
The QCDSP itself is most simply programmed in C or 
C++, for which a commercial compiler exists with
some optimisation features. The compiler is called
the Tartan C++ compiler and the UNIX invocation of it 
is via the command <tt>tcpp</tt>. 

<p>
The machine can also be programmed at the assembler
level and  indeed such programming may be necessary to achieve
maximal computational and communication performance. However,
for the moment we shall not discuss this mode of programming. 

<p>
 <h2><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Parallelism in the QCDSP Computer</h2>
The QCDSP, whether at the level of a single development board
or at the level of several cabinets containing processor boards
is a MIMD<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a> parallel computer. 

<p>
This means, that each processor is capable of running completely
independent code. However, the machine is 
perhaps best programmed according to the SPMD<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a> programming model. In this programming model processors run the 
same program, using different datasets resident to each processor. Also
this programming model allows one to write fully MIMD programs, by executing
separate subroutines (of the same program) depending on some identification
token (a unique processor ID, processor grid coordinates or some such) 
from the local processor. 

<p>
Furthermore, the QCDSP has a distributed memory, with no current
implementation of a shared memory system. The preferred method of 
communication is via message passing between neighbouring processors.
We shall outline possible methods to implement global communications
such as broadcasts and global sums in the next chapter.
For the current chapter, we shall introduce some of the QCDSP system
calls to allow a given particular processor to identify itself, and 
to send messages to its neighbours. To make the discussion clearer,
we have to mention a few details about the architecture and network
topology of the QCDSP computer.

<p>
 <h2><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Brief description of the QCDSP Architecture</h2>
The QCDSP at the bottom level consists of a collection of Texas
Instruments TMS320C31 Digital Signal Processors (DSPs) with associated
DRAM memory (0.5Gwords of error correcting memory per processor) and
special purpose communications hardware. These components are
organised into a hierarchy of <em>daughterboards</em>, <em>motherboards</em>
and <em>crates</em>.

<p>
A daughterboard consists of a single DSP chip, its associated DRAM and 
its so called Node Gate Array (NGA), which is the communications unit
built on a custom chip. A single daughterboard is about the size of a 
credit card. A picture of a daughterboard is shown in figure <a href="#f:daughterBoard">3.1</a>

<p>
<a name="tth_fIg3.1">
</a> 
<center>
<img src="daughterboard_photo.jpg" alt="daughterboard_photo.jpg" />
<!--hbox-->
</center>

<center>Figure 3.1: Photograph of a daughterboard. The DSP chip and the NGA are shown
with a ruler to indicate size in inches</center>
<a name="f:daughterBoard">
</a>

<p>
The daughterboards are themselves mounted on motherboards. A single
motherboard holds up to 64 daughterboards. Of these, one daughterboard
(daughterboard 0) is integrated onto the motherboard and has some 
special functions that we shall describe later. A picture of a motherboard 
can be seen in figure <a href="#f:motherBoard">3.2</a>.

<p>

<p>
<a name="tth_fIg3.2">
</a> 
<center>
<img src="motherboard_photo.gif" alt="motherboard_photo.gif" />
<!--hbox-->
</center>

<center>Figure 3.2: Photograph of a motherboard containing 63 daughterboard cards and
one integrated daughterboard. The motherboard is mounted on a test rig and 
is cooled by the fan on the left hand side</center>
<a name="f:motherBoard">
</a>

<p>
The daughterboards are connected on the motherboard in a four dimensional 
(4D) mesh via a <em>serial network</em> which is intended to be the main 
medium of communications for applications and hence it has been named
<em>the physics network</em>. The physics network is driven by the NGA 
of each daughterboard. This 4D serial network wraps around in each dimension,
giving each motherboard network topology of a <em>4D-torus</em>.

<p>
All the daughterboards on a given motherboard are also connected to the 
special daughterboard 0 (the one integrated on the motherboard) via
a second serial network in a star topology. This network is part
of the so called <em>boot-diagnostic network</em>. The boot-diagnostic
network is used for hardware testing, and for downloading the various
boot and runtime kernels to the daughterboards at boot time. 

<p>
Each motherboard also has two SCSI ports which are connected to
daughterboard 0 on that board. These ports allow the connection of
daughterboards to either a front end host, to another motherboard, or
in future designs of the machine, to local disk systems. The SCSI
connections form part of the boot-diagnostic network and are not in
general expected to be heavily used in physics applications.

<p>
The motherboards are organised into crates. The <em>physics networks</em>
of the boards in a given cabinet are connected by a tagliatelle tangle
of flat ribbon serial cables into an overall physics network which
still forms a 4D torus.  The boot diagnostic networks of the boards in
a crate are connected via the SCSI interfaces on the motherboards into
a tree hierarchy. A picture of a crate is shown in figure <a href="#f:crate">3.3</a>.

<p>
<a name="tth_fIg3.3">
</a> 
<center>
<img src="crate_photo.gif" alt="crate_photo.gif" />
<!--hbox-->
</center>

<center>Figure 3.3: A QCDSP crate holding 6 motherboards</center>
<a name="f:crate">
</a>

<p>
Finally the crates are assembled into a full machine.

<p>
In summary the communications in a machine are made up of two networks:

<ul>
<li>The Physics Network - which is a serial network that to the programmers
point of view forms a 4D torus. This is the network that is intended for 
primary communications in an application.</li>

<li>
The Boot-Diagnostic network made up from a SCSI chain between motherboards,
rooted on the front end workstation. On each motherboard the boot-diagnostic
network is constructed from a serial network with a star topology rooted
on daughterboard 0.</li>
</ul>

<p>
A summary of the networks in QCDSP can be seen in figure <a href="#f:networkSummary">3.4</a>.

<p>
<a name="tth_fIg3.4">
</a> 
<center>
<img src="networks_summary.gif" alt="networks_summary.gif" />
<!--hbox-->
</center>

<center>Figure 3.4: A summary diagram of QCDSP Networks showing three motherboards
connected in a tree of depth = 2. The horizontal and vertical
black lines show the physics network (2 dimensions of it) with the black
dots showing the daughterboards. The green lines show the SCSI tree and 
the red lines show the serial boot-diagnostic network. Purple lines 
show the connections between the SCSI ports and motherboard 0 on each 
board.</center>
<a name="f:networkSummary">
</a>

<p>
 <h2><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;Programming Interface</h2>
The QCDSP at the simplest level provides a set of C++ functions
which may be called to achieve various aims. Broadly these functions
can be categorised as

<ul>
<li>Functions allowing the processor to identify itself and the machine</li>

<li>
Objects and functions for carrying out communications</li>

<li>
functions for self synchronisation</li>

<li>
miscellany - random numbers etc .</li>
</ul>

<p>

<h3>Header Files</h3>
These functions are defined in the header file <b>sysfunc.h</b> in the
directory <tt>/qcdsp/sfw/qos.&lt;version&#62;/usr/include</tt> where <tt>
&lt;version&#62;</tt> refers to the QOS revision as discussed in the previous
chapter. This directory should be listed as part of the <tt>TC_DIR</tt>
shell environment variable (see last chapter), thus making the
directory part of the default search path for the Tartan C++
compiler. The programmer merely needs to include the header file in
his source files using the directive

<pre>




</pre> 
identically to the way he/she normally includes <b>stdio.h</b>, <b>stdlib.h</b>, 
<b>math.h</b> and other standard header files.

<p>

<h3>Unsupported C++ Features</h3>
One should also be aware that not all of the standard ANSI C++ libraries
are implemented on the QCDSP. In particular the <tt>iostream</tt> classes
are unavailable. The programmer needs to use the C standard I/O routines
defined in <b>stdio.h</b>.

<p>

<h3>Compilation and Running of Examples</h3>
In the following sections we describe some of the functions provided 
in the <b>sysfunc.h</b> file. To run the example codes we recommend that
the reader copies the <em>hello_world</em> program as described in the last
section into his homedirectory and modifies the file <b>main.C</b>. The makefile
provided can then be used to build the examples by typing the command <tt>make</tt>. The resulting executable will be called <b>hello_world.out</b>. (Readers
with a knowledge of makefiles can adapt the makefile as they wish. The compiler
flags and command line options for the C++ compiler can be listed by typing
the command <tt>tcpp</tt> with no arguments.) Let us
assume from here on that the <em>hello_world</em> directory was copied to one
of identical name in the users homedirectory and that the results of all
compilations are named <b>hello_world.out</b>.

<p>
 <h2><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;Who Am I?</h2>

<h3>Knowing your identity and place in the Universe</h3>
The following functions are defined in <b>sysfunc.h</b> to enable
a processor to localise itself:

<dl compact="compact">
	<dd><tt>int UniqueID()&nbsp;: <br /></tt>
This function returns an <tt>int</tt> specifying 
the <b>unique processor ID</b> of the calling
processor. (N.B: The MPI equivalent of this call
would be <tt>MPI_Comm_Rank</tt>).</dd>

	<dd><tt>int NumNodes()&nbsp;: <br /></tt>
This function returns an <tt>int</tt> specifying 
the total number of nodes
that are in use in the current machine partition.
(N.B: The MPI equivalent of this call would be <tt>MPI_Comm_Size</tt>).</dd>

	<dd><tt>int MbNum()&nbsp;: <br /></tt>
This function returns an <tt>int</tt> specifying the <b>motherboard number</b>
of the motherboard on which the calling processor resides.</dd>

	<dd><tt>int DbNum()&nbsp;: <br /></tt>
This function returns an <tt>int</tt> specifying the <b>daughterboard number</b>
of the calling processor.</dd>

	<dd><tt>int CoorT()</tt>, <tt>int CoorX()</tt>, <tt>int CoorY()</tt>, <tt>int CoorZ()</tt> &nbsp;: <br />
These function calls return <tt>int</tt>-s specifying the T, X, Y and Z coordinates respectively, of the calling processor within the 4D torus of the physical
network.</dd>

	<dd><tt>int SizeT()</tt>, <tt>int SizeX()</tt>, <tt>int SizeY()</tt>, <tt>int SizeZ()</tt> &nbsp;: <br /> 
These functions return <tt>int</tt>-s specifying the size of the 4D torus physical
network in the T, X, Y and Z directions respectively</dd>
</dl>

<p>
Figure <a href="#f:whoamiCode">3.5</a> shows a programming example, where the processors
in the QCDSP identify themselves and size up their machine parition using
these functions:

<p>
<a name="tth_fIg3.5">
</a> <font size="-4">
<pre>






int main(int argc, char *argv[])
{
   /* ------- What is my Unique ID  ---------------------- */
   int my_id = UniqueID();
   int num_processors = NumNodes();

   /* ------- Motherboard and Daughterboard Numbers -------*/
   int my_motherboard_num = MbNum();
   int my_daughterboard_num = DbNum();

   /* - My processor grid coordinates and grid dimensions -*/
   int my_coords[4];
   int proc_grid_dims[4];

   /* --------------- Get my coordinates ----------------- */
   my_coords[0] = CoorT();
   my_coords[1] = CoorX();
   my_coords[2] = CoorY();
   my_coords[3] = CoorZ();

   /* - Get information about the processor grid size ---  */
   proc_grid_dims[0] = SizeT();
   proc_grid_dims[1] = SizeX();
   proc_grid_dims[2] = SizeY();
   proc_grid_dims[3] = SizeZ();

   /* -  Echo Back information to the user --------------- */
   printf("I am processor: %d.\n", my_id);
   printf("I live on motherboard %d, daughterboard %d\n",  my_motherboard_num,
                                                             my_daughterboard_num);

   printf("I am one of a total of %d computing elements\n", num_processors);
  
   printf("The current physical network has the following dimensions\n");
   printf("%d Processors in the T direction\n", proc_grid_dims[0]);
   printf("%d Processors in the X direction\n", proc_grid_dims[1]);
   printf("%d Processors in the Y direction\n", proc_grid_dims[2]);
   printf("%d Processorz in the Z direction\n", proc_grid_dims[3]);
  
   printf("My (T,X,Y,Z) coordinates are (%d, %d, %d, %d )\n", 
           my_coords[0], my_coords[1], my_coords[2], my_coords[3]);

   return(EXIT_SUCCESS);
}

</pre>

<center>Figure 3.5: Sample program showing use of self identification functions.</center>
<a name="f:whoamiCode">
</a>
</font>
<p>
   Running the code in figure <a href="#f:whoamiCode">3.5</a> on the 64 daughterboard 
development board <em>q_2</em> produced the following results:

<font size="-3">

<pre>
(qcdhost/homeqs0/bj/hello_world: qcsh[q_2])% qrun hello_world.out
.
.
.
I am processor: 0.
I live on motherboard 0, daughterboard 0
I am one of a total of 64 computing elements
The current physical network has the following dimensions
4 Processors in the T direction
4 Processors in the X direction
2 Processors in the Y direction
2 Processorz in the Z direction
My (T,X,Y,Z) coordinates are (0, 0, 0, 0 )
.
.
.

</pre>
</font>

<p>
Using the command <tt>qprintf</tt> command as described in the last chapter
allows one to look at the output buffers of some of the other processors:
<font size="-3">

<pre>
.
.
.
Qdaemon:  user print buffer for Mb 0 and Db 2 (SCSI tree coordinates)
Buffer wrap count 0
I am processor: 2.
I live on motherboard 0, daughterboard 2
I am one of a total of 64 computing elements
The current physical network has the following dimensions
4 Processors in the T direction
4 Processors in the X direction
2 Processors in the Y direction
2 Processorz in the Z direction
My (T,X,Y,Z) coordinates are (0, 0, 1, 0 )
.
.
.
Qdaemon:  user print buffer for Mb 0 and Db 63 (SCSI tree coordinates)
Buffer wrap count 0
I am processor: 63.
I live on motherboard 0, daughterboard 63
I am one of a total of 64 computing elements
The current physical network has the following dimensions
4 Processors in the T direction
4 Processors in the X direction
2 Processors in the Y direction
2 Processorz in the Z direction
My (T,X,Y,Z) coordinates are (3, 3, 1, 1 )

</pre>
</font>

<p>

<h3>Some useful enumerated types</h3>
You may notice<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>
if you look through the code in <a href="#f:whoamiCode">3.5</a> that
I have always ordered the indices of both the <tt>my_coords</tt> and <tt>proc_grid_dims</tt> in the order T, X, Y and Z with the T corresponding to the index
0 and Z corresponding to index 3. To make for much more
readable programs there exists an enumerated type called <tt>SCUAxis</tt>.
A variable of type <tt>SCUAxis</tt> can take on only four values

<dl compact="compact">
	<dd><tt>SCU_T - &nbsp;</tt> 
for the T direction,</dd>

	<dd><tt>SCU_X - &nbsp;</tt> 
for the X direction,</dd>

	<dd><tt>SCU_Y - &nbsp;</tt> 
for the Y direction and</dd>

	<dd><tt>SCU_Z - &nbsp;</tt> 
for the Z direction &nbsp;.</dd>
</dl>
The actual definition of the type:
<font size="-3">
<pre>
enum SCUAxis { SCU_T, SCU_X, SCU_Y, SCU_Z };

</pre></font>
ensures that the integer values of the enumerations
are <tt>SCU_T</tt>=0, <tt>SCU_X</tt>=1, <tt>SCU_Y</tt>=2 and <tt>SCU_Z</tt>=3
respectively. 

<p>
Thus we should be able to index our arrays with these enumerations
rather than with the integers 0,1,2 and 3 as before. For example
we could write
<font size="-3">
<pre>
my_coords[SCU_X]=CoorX(); /* equivalent to my_coords[1] = CoorX() */

</pre></font> 
or for example we could cycle through all the directions in the 
processor grid with the following <tt>for</tt> loop:
<font size="-3">
<pre>
int i;
for(i = SCU_T; i &lt;= SCU_Z; i++) {
  /* do something exciting here  */
}

</pre></font>

<p>
Incidentally, we note that this latter use relies on the particular
ordering of the axes defined in the enumerated type. In future releases
of QOS, the ordering of the enumerated elements maybe different from 
the current release. If this happens the above for loop may not be 
portable. Hence, <em>caveat emptor</em>. The enumerated type itself 
is defined in <tt>/qcdsp/sfw/qos.&lt;version&#62;/include/scu_enum.h</tt> which
is included in the <b>sysfunc.h</b> file. (<em>Suggestion:
perhaps a member of the enumerated type called MAX_AXIS or something
should be defined for such loops. They could then be written as
</em> <tt>for(i=0; i&lt; MAX_AXIS; i++) </tt>)

<p>
 <h2><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;Nearest Neighbour Communications</h2>
The QCDSP <b>sysfunc.h</b> header files defines several ways of carrying
out nearest neighbour communications. We will look into the simplest one
here. By communication we mean sending/receiving a certain number of bytes
from one processor to another. On the QCDSP such a communication is made up of
three stages.

<dl compact="compact">
	<dd><b>Preparation: &nbsp;</b> - the sender/receiver describes the data
to be sent/received and provides a pointer in memory to the data that
is to be sent / to where the data is to be received</dd>

	<dd><b>Initiation: &nbsp;</b> -  the sender / receiver initiates the 
communication. The sender / receiver is then free to carry out other
tasks.</dd>

	<dd><b>Completion: &nbsp;</b> - the sender / receiver wait until the 
communication is complete, in the case of the sender this means that 
all the data has been sent and in the case of the receiver it means that
the the data has arrived.</dd>
</dl>
Communication along the physical network is handled by the Serial
Communication Unit (SCU) in the NGA chip, and the communication does
not need much interaction from the CPU past the initiation
stage. Hence the time spent communicating allows the processor to
carry out computation while the communication proceeds. It is only
immediately before using the results of the communications that the
processor has to wait to make sure that the communication is
complete. (Note: This is similar in style to the MPI non-blocking
communications, however in the case of MPI the so called preparation
and initiation stages are usually rolled into one)

<p>

<h3>Preparation</h3>
In preparing to communicate we must decide upon the following things:

<ul>
<li>Who did we want to communicate with? This is generally one of our
neighbours. We have neighbours in eight directions, these being 
the positive and negative T, X, Y and Z directions respectively. An enumerated type, <tt>SCUDir</tt>, is made available to help us in writing safe, 
maintainable programs. This enumerated type is made accessible through
the header file <b>sysfunc.h</b>. The actual enumerations are

<dl compact="compact">
	<dd> <tt>SCU_TM</tt> (T, Minus): &nbsp; 
- Communicate in the negative T direction</dd>

	<dd> <tt>SCU_TP</tt> (T, Plus): &nbsp; 
- Communicate in the positive T direction</dd>

	<dd> <tt>SCU_XM</tt> (X, Minus): &nbsp;
- Communicate in the negative X direction</dd>

	<dd> <tt>SCU_XP</tt> (X, Plus) : &nbsp;
- Communicate in the positive X direction</dd>

	<dd> <tt>SCU_YM</tt> (Y, Minus): &nbsp; 
- Communicate in the negative Y direction</dd>

	<dd> <tt>SCU_YP</tt> (Y, Plus): &nbsp; 
- Communicate in the positive Y direction</dd>

	<dd> <tt>SCU_ZM</tt> (Z, Minus): &nbsp;
- Communicate in the negative Z direction</dd>

	<dd> <tt>SCU_ZP</tt> (Z, Plus) : &nbsp;
- Communicate in the positive Z direction</dd>
</dl></li>

<li> 
We must decide whether we wish to send a message or receive one.
Once again we have an enumerated type at our disposal called
<tt>SCUXR</tt>. This can have only two values:

<dl compact="compact">
	<dd> <tt>SCU_REC</tt> : &nbsp; 
receive operation</dd>

	<dd> <tt>SCU_SEND</tt> : &nbsp; 
send operation.</dd>
</dl></li>

<li>
We must describe our data. For our purposes the data shall consist 
of a number of blocks, each block having a certain length. The blocks
need not be contiguous in memory, but may have some regular spacing
between them. The distance in memory (<b>in units of blocks</b>) separating
the <b>start of one block</b> from the <b>start of the next one</b> is called
the data stride.

<p>
Hence our messages are completely described by specifying the <em>
memory address</em> of the first block, <em>the length of a block in
bytes</em>, <em>the number of blocks in the message</em> and <em>the
stride</em>.  For messages made up of a contiguous set of blocks, the
stride is always one. In other words, the start of a block in memory is
always one block-length away from the start of the previous block with the
intervening memory between the two being filled up by the body of
the first block. The idea of this data description scheme is illustrated
in figure <a href="#f:message">3.6</a>.</li>
</ul>

<p>

<p>
<a name="tth_fIg3.6">
</a> 
<center>

<img src="message.gif" alt="message.gif" /><!--hbox-->
</center>

<center>Figure 3.6: Anatomy of a message. Here the message consists of 2 blocks
(shaded) with each block having a block length of 3 bytes. The blocks
are not contiguous but have a block separation between them making the
stride value for this message 2</center>
<a name="f:message">
</a>

<p>
On the QCDSP the preparing to communicate involves the instantiation
of a so called <tt>SCUDirArg</tt> object. There are several ways of
carrying out this instantiation. Perhaps the simplest is to use the
<em>constructor</em>: 
<font size="-1">
<pre> 
SCUDirArg(void *buffer, SCUDir dir, SCUXR xr, int blklen, 
          int numblk = 1, int stride = 1).

</pre></font>
This method allows the complete description of the putative communication to be specified with one single statement. The arguments have the following meaning:

<dl compact="compact">
	<dd><tt>void *buffer &nbsp;</tt> 
this is a pointer to the start of the message in memory. It is of type <tt>void *</tt> so that the pointer can point to data of any type.</dd>

	<dd><tt>SCUDir dir &nbsp;</tt> 
this is the direction in which the communication is to proceed and should take
the value of one of the 8 enumerations of the enumerated type <tt>SCUDir </tt> listed above.</dd>

	<dd><tt>SCUXR xr &nbsp;</tt> 
indicates whether we are sending or receiving. This should take one of the two 
values of the enumerated type <tt>SCUXR</tt> listed above.</dd>

	<dd><tt>int blklen &nbsp;</tt> 
gives the length in bytes of a single block to be transmitted/received.</dd>

	<dd><tt>int numblk = 1 &nbsp;</tt>
gives the number of blocks to be communicated. This is an optional
argument to the constructor, which, if unspecified will have the
default value of 1, indicating that there is only a single block to be
communicated</dd>

	<dd><tt>int stride = 1 &nbsp;</tt>
specifies the stride of the data. This is an optional argument to the constructor, which, if unspecified will have the default value of 1 corresponding to the 
contiguous data.</dd>
</dl>

<p>
As an example, suppose I wanted to send an integer in the 
positive X direction, I could instantiate the communication description object as:

<pre>
int number_to_send = 5;
SCUDirArg send_int_x_plus((void *)&amp;number_to_send, SCU_XP, 
                          SCU_SEND, sizeof(int));

</pre>
or as:

<pre>
int number_to_send = 5;
SCUDirArg send_int_x_plus((void *)&amp;number_to_send, SCU_XP, 
                                  SCU_SEND, sizeof(int),1);

</pre>
or even as:

<pre>
int number_to_send = 5;
SCUDirArg send_int_x_plus((void *)&amp;number_to_send, SCU_XP, 
                                  SCU_SEND, sizeof(int),1,1);

</pre>
where in the last two cases I have explicitly specified the optional arguments.
In all the above cases the result of the instantiation is an
object of type <tt>SCUDirArg</tt> with name <tt>send_int_x_plus</tt>. This object
now acts as a <em>handle</em> to that particular communication.

<p>
Likewise to receive a 5-vector of floating point numbers of type <tt>float</tt>
from the negative Y direction, I would set up the communication as:

<pre>
float receive_buffer[5];
SCUDirArg rec_floats_y_minus((void *)receive_buffer, SCU_YM, 
                             SCU_REC, sizeof(float), 5, 1);

</pre>

<p>
Alternatively, I can set up the communication to send the 5 members of a 10 member integer array which have odd indices in the positive T direction using the
following instantiation:

<pre>
int send_buffer[10];
SCUDirArg send_odd_t_plus((void *)&amp;send_buffer[1], SCU_TP, 
                          SCU_SEND, sizeof(int), 5, 2);

</pre>

<p>
The <tt>SCUDirArg</tt> objects can also be instantiated and manipulated using
various other <em>class methods</em>. For example I can instantiate an
object, without a description of the communication to be performed 
by simply using the default constructor:

<pre>
SCUDirArg for_later;

</pre>
Later on I can initialise this object with the method <tt>Init</tt>
which has the same argument list as the full constructor described earlier.
Hence I can either set up the object in the previous manner as:

<pre>
int number_to_send = 5;
SCUDirArg send_int_x_plus((void *)&amp;number_to_send, SCU_XP, 
                          SCU_SEND, sizeof(int));

</pre>
or alternatively I can use the <tt>Init</tt> method:

<pre>
int number_to_send = 5;
SCUDirArg send_int_x_plus;
send_int_x_plus.Init((void *)&amp;number_to_send, SCU_XP, 
                          SCU_SEND, sizeof(int));

</pre>

<p>
Other methods by which the data description elements of the object can be
set are

<dl compact="compact">
	<dd><tt>void * Addr( void *addr) &nbsp;</tt>
the start of the data is set to <tt>addr</tt>. The address of the new
buffer is returned.</dd>

	<dd><tt>int Blklen( int blklen ) &nbsp;</tt>
the block length of the communication is set to <tt>blklen</tt>. The 
new block length is returned.</dd>

	<dd><tt>int Numblk( int numblk ) &nbsp;</tt>
the number of blocks in the transfer is set to <tt>numblk</tt>. The new
number of blocks is returned.</dd>

	<dd><tt>int Stride( int stride ) &nbsp;</tt> 
the stride of the transfer is set to <tt>stride</tt>. The new stride is returned.</dd>

	<dd><tt>void Reload(void *a, int blklen, int numblk=1, int stride = 1) &nbsp;</tt>
The new data description indicated in the argument list is set (the send/receive nature of the data or the communication direction remain as before). <tt>a</tt> holds the address of the start of the data. The remaining arguments should be
self explanatory by now. Note again that the last two arguments are optional.</dd>
</dl>

<p>
So for example to send first an <tt>int</tt>, then a <tt>float</tt> in the 
positive X direction followed by a second <tt>int</tt> communication, I can 
instantiate the communication object for the first <tt>int</tt>  and then simply
use the methods above to change the data description:

<pre>
int int_buf=5;
int float_buf=0.6;

/* Set up the integer communications */

SCUDirArg send_x_plus((void *)&amp;int_buf, SCU_XP, 
                      SCU_SEND, sizeof(int));

/* 
 * Carry out the first communications here 
 */

/* Now change to float communications -- send in the same direction */
send_x_plus.Addr((void *)&amp;float_buf);
send_x_plus.Blklen(sizeof(float));
 
/* 
 * Carry out the second communication here
 */

/* Now prepare to send  an int again -- last two arguments optional */
send_x_plus.Reload((void *)&amp;int_buf, sizeof(int));

/*
 * Carry out the third communication here
 */

</pre>

<p>

<h3>Initiating the Communications</h3>
Once we have defined the type of communication we wish to perform,
we must initiate the data transfer. This is done by the function
<tt>SCUTrans</tt>. There are several ways of using <tt>SCUTrans</tt>, here I will
describe the simplest one.

<p>
Calling <tt>SCUTrans</tt> with the address of an <tt>SCUDirArg</tt> object as the 
sole argument will initiate the communication encoded in that object.

<p>
As an example, suppose we want to send the integer 4 in the positive X
direction and an <tt>SCUDirArg</tt> object <tt>int_x_plus</tt> has been
instantiated to describe this communication (<em>Exercise:
Instantiate an SCUDirArg object to encode this communication.</em>) The
communication could then be initiated by the following call:

<pre>
SCUTrans( &amp;int_x_plus );

</pre>
However the results of the communication will not be available until the
communication completes.

<p>

<h3>Completing the Communication</h3>
To complete the communication the program should call the function
<tt>SCUTransComplete</tt>. One can call this function with the address
of an <tt>SCUDirArg</tt> object to complete to communication encoded in 
that, or without any arguments to complete all outstanding communications.
There is also another way to call <tt>SCUTransComplete</tt> to match a 
particular way of calling <tt>SCUTrans</tt> which will not be detailed here.

<p>
Hence to complete the previously initiated transfer encoded in the object
<tt>x_int_plus</tt> of the last subsection, one should call

<pre>
SCUTransComplete( &amp;x_int_plus);

</pre>

<p>
To complete all outstanding communications on a given processor (<b>
this does not imply a synchronisation across processors</b>) one should
instead call 

<pre>
SCUTransComplete();

</pre>

<p>
 <h2><a name="tth_sEc3.7">
3.7</a>&nbsp;&nbsp;Getting To Know Your Neighbours</h2>
Before concluding this chapter, we present the code for a complete program
designed to show the use of some of the communication routines presented
in the last section. 

<p>
The program discovers the processor ID's of its neighbours in every direction.
For each axis, T, X, Y and Z, the processors send their unique ID's in the
positive direction, and receive the ID's of their neighbours from the negative
direction.

<p>
Once this is done for all four axes, the communication pattern is
repeated but in the opposite direction. That is, for all four axes,
each processor will send its unique ID in the negative direction and
receives the ID of its neighbour from the positive direction.  When
this process is done for all the axes, the processor will have the ID's of
all its neighbours.

<p>
<font size="-3">
<pre>






// --------------------------------------------------------------------
// This function, when given the direction to send in (send direction)
// will send the contents of its send_buffer in that direction and 
// will receive into its receive buffer from the negative direction
// -------------------------------------------------------------------
void neighbourSend(int *send_buffer, int *recv_buffer,
                   SCUDir send_direction)
{

   SCUDir recv_direction;

   // ------------------------------------------------------------- //
   // Figure out the receive direction                              //
   // ------------------------------------------------------------- //

   switch( send_direction ) {

        case SCU_TM : recv_direction = SCU_TP;
                        break;

        case SCU_TP : recv_direction = SCU_TM;
                        break;

        case SCU_XM : recv_direction = SCU_XP;

                      break;

        case SCU_XP : recv_direction = SCU_XM;
                      break;

        case SCU_YM : recv_direction = SCU_YP;
                      break;

        case SCU_YP : recv_direction = SCU_YM;
                      break;

        case SCU_ZM : recv_direction = SCU_ZP;
        break;

        case SCU_ZP : recv_direction = SCU_ZM;
        break;

        default: fprintf(stderr, "P%d: Error Invalid Send Direction\n");
                         exit(EXIT_FAILURE);
                         break;
   }
   // ------------------------------------------------------------- //
   // Set up SCUDirArg objects, one for send and one for receive    //
   // ------------------------------------------------------------- //

   // ------------------------------------------------------------- //
   // Send an integer in the send direction                         //
   // ------------------------------------------------------------- //
   SCUDirArg send( send_buffer,
                   send_direction,
                   SCU_SEND,
                   sizeof(int));

   // ------------------------------------------------------------- //
   // Recieve an integer from the opposite direction                //
   // ------------------------------------------------------------- //
   SCUDirArg recv( recv_buffer,
                   recv_direction,
                   SCU_REC,
                   sizeof(int));

   // ------------------------------------------------------------- //
   // Initiate the transfer                                         //
   // ------------------------------------------------------------- //

   SCUTrans( &amp;send );
   SCUTrans( &amp;recv );

   // ------------------------------------------------------------- //
   // Wait for these two specific transfers to complete             //
   // ------------------------------------------------------------- //

   SCUTransComplete( &amp;send );
   SCUTransComplete( &amp;recv );

   // ------------------------------------------------------------- //
   // Done                                                          //
   // ------------------------------------------------------------- //
}

int main(int argc, char *argv[])
{
   // ------------------------------------------------------------ //
   // Details about myself                                         //
   // ------------------------------------------------------------ //

   int my_id=UniqueID();
   int my_coords[4] = { CoorT(), CoorX(), CoorY(), CoorZ() };

   // ------------------------------------------------------------ //
   // Print out information about the grid                         //
   // ------------------------------------------------------------ //

   printf("Processor grid has dimensions: T=%d X=%d Y=%d Z=%d\n",
          SizeT(),
          SizeX(),
          SizeY(),
          SizeZ());

   // ------------------------------------------------------------ //
   // Print out information about ourselves                        //
   // ------------------------------------------------------------ //


   printf("P%d, T=%d, X=%d, Y=%d, Z=%d\n",
          my_id,
          my_coords[SCU_T],
          my_coords[SCU_X],
          my_coords[SCU_Y],
          my_coords[SCU_Z]);

   // ------------------------------------------------------------ //
   // Now Send my ID to my neighbour in each dimension             //
   // ------------------------------------------------------------ //

   int neighbour_id[8];         // -- Array to hold information about
                                //    neighbours

   SCUDir counter;              // A direction counter variable

   // ----------------------------------------------------------- //
   // This next bit is a little naughty as it relies on the fact  //
   // Ordering of the members of the enumerated types             //
   // ----------------------------------------------------------- //
   // Transmit my ID in  the positive directions                  //
   // and receive ID from the negative direction                  //
   //                                                             //
   // Note that Axis_plus = Axis_minus + 1 in the enumeration     //
   // hence the choices of the counter                            //
   // ----------------------------------------------------------- //
    
   // -----------------------------------------------------------------
   // First send our ID-s to the +ve  directions (receive from -ve)
   // -----------------------------------------------------------------

   for(counter = SCU_TM; counter &lt;= SCU_ZM; counter+=2) {
     neighbourSend( &amp;my_id,
                    &amp;neighbour_id[ counter ],
                    counter + 1 );
                    
   }
 
   // ------------------------------------------------------------------
   // Second send our ID-s to the -ve directions (receive from +ve)
   // ------------------------------------------------------------------
  
   for(counter = SCU_TP; counter &lt;= SCU_ZP; counter+=2) {
     neighbourSend( &amp;my_id,
                    &amp;neighbour_id[ counter ],
                    counter - 1 );
   }

   // ---------------------------------------------------------- //
   // Print out my neighbours IDs                                //
   // -----------------------------------------------------------//

   printf("P%d:  T-Neighbour (-,+): (%d, %d)\n",
          my_id,
          neighbour_id[ SCU_TM ],
          neighbour_id[ SCU_TP ] );


   printf("P%d:  X-Neighbour (-,+): (%d, %d)\n",
          my_id,
          neighbour_id[ SCU_XM ],
          neighbour_id[ SCU_XP ] );

   printf("P%d:  Y-Neighbour (-,+): (%d, %d)\n",
          my_id,
          neighbour_id[ SCU_YM ],
          neighbour_id[ SCU_YP ] );

   printf("P%d:  Z-Neighbour (-,+): (%d, %d)\n",
          my_id,
          neighbour_id[ SCU_ZM ],
          neighbour_id[ SCU_ZP ] );

}

</pre>
</font>

<p>
 <h2><a name="tth_sEc3.8">
3.8</a>&nbsp;&nbsp;Summary of Chapter</h2>
In this chapter we have outlined some of the basic system
calls provided by the QCDSP <b>sysfunc.h</b> and how they
can be used for processors to identify themselves and to 
perform simple nearest neighbour communications.

<p>

<h3>Architecture summary</h3>
The main point to stress about the computer architecture is that
there are two main networks in the QCDSP. One is the boot-diagnostic
network and the other is the physics network. The boot-diagnostic 
network is partly made up of a SCSI tree structure, partly of a 
serial network with a star topology rooted on the special embedded
daughterboard on each motherboard. The physics network is a 4-D
torus.

<p>

<h3>Self Identification Summary</h3>
Several routines are provided in the header file <b>sysfunc.h</b>.
These include the functions 

<dl compact="compact">
	<dd><tt>int UniqueID() &nbsp;</tt> - returns the processor ID</dd>

	<dd><tt>int NumNodes() &nbsp;</tt> - returns the number of processors</dd>

	<dd><tt>int MbNum()    &nbsp;</tt> - returns the processors motherboard number</dd>

	<dd><tt>int DbNum()    &nbsp;</tt> - returns the processors daughterboard number</dd>

	<dd><tt>int CoorT(), int CoorX(), int CoorY(), int CoorZ() &nbsp;</tt> - returns
the processors coordinates in the physical network.</dd>

	<dd><tt>int SizeT(), int SizeX(), int SizeY(), int SizeZ() &nbsp;</tt> - returns
the sizes of the physical network in the respective dimensions.</dd>
</dl>

<p>

<h3>Enumerated Types Summary</h3>
The following enumerated types are defined in the hearder file <b>sysfunc.h</b>

<dl compact="compact">
	<dd><font size="-2"><tt>enum SCUAxis = { SCU_T, SCU_X, SCU_Y, SCU_Z }; &nbsp;</tt></font> - a type to describe the four axes of the physical network</dd>

	<dd><font size="-2"><tt>enum SCUDir = { SCU_TM, SCU_TP, SCU_XM, SCU_XP, SCU_YM, SCU_YP, SCU_ZM, SCU_ZP }; &nbsp;</tt></font> - a type to enumerate the 8 communication
channels available on each processor. The naming convention is <tt>
SCU_&lt;Axis&#62;&lt;P/M&#62;</tt> where <tt>&lt;Axis&#62;</tt> is one of T, X, Y or Z and <tt>
&lt;P/M&#62;</tt> is either P for the positive (plus) direction along the axis or
M for the negative (minus) direction along the axis</dd>

	<dd><font size="-2"><tt>enum SCUXR = { SCU_REC, SCU_SEND= 8}; &nbsp;</tt></font> - enumerates
the two types of communications, sending or receiving. Note that <tt>
SCU_SEND</tt> has an integer value of 8 rather than 1.</dd>
</dl>

<p>

<h3>Nearest Neighbour Communications Summary</h3>
Nearest neighbour communications can be initiated by the <tt>SCUTrans</tt>
function and completed by the <tt>SCUTransComplete</tt> function. The description
is specified via an <tt>SCUDirArg</tt> object.

<p>
The <tt>SCUDirArg</tt> objects can be instantiated through invoking the 
constructor

<pre>
SCUDirArg(void *buffer, SCUDir dir, SCUXR xr, int blklen, 
          int numblk = 1, int stride = 1);

</pre> 
where the arguments respectively are the address of the start of the
data, the direction of the communication, the mode of communication
(SEND/RECEIVE), the blocklength of the data to be communicated (in
bytes), the number of blocks to communicate and the data stride. The
last two of these parameters are optional. The default number of blocks
is 1 indicating a single item transfer. The default stride is 1 indicating
contiguous blocks.

<p>
Other forms of the <tt>SCUDirArg</tt> constructor are also available.
(See more advanced documentation if I ever write it).

<p>
The <tt>SCUTrans</tt> function call has a prototype

<pre>
void SCUTrans( SCUArgDir *arg );

</pre>
where <tt>arg</tt> is a pointer to the <tt>SCUArgDir </tt> object describing
the communication. A call to <tt>SCUTrans </tt> initiates a communication.
The communication should not be considered complete until a corresponding
<tt>SCUTransComplete</tt> call returns. The <tt>SCUTrans </tt> function has
other (overloaded) prototypes which were not discussed here. (See more
advanced documentation if I ever write it).

<p>
The <tt>SCUTransComplete</tt> function call has prototypes

<pre>
void SCUTransComplete( SCUArgDir *arg );
void SCUTransComplete();

</pre>
The first of these takes as its argument a pointer to an <tt>SCUArgDir</tt> object.
In this case the function returns when the communication encoded in the
object pointed to by <tt>arg</tt> completes. In the second case the function
has no arguments. In this case the function returns when all the 
communications currently pending complete.

<p>
In the next chapter we shall discuss simple global communication algorithms
and their implementation using the functions detailed in this chapter.

<p>
 <h2><a name="tth_sEc3.9">
3.9</a>&nbsp;&nbsp;Programming Exercise</h2>

<h3>The Problem: - More efficient Neighbours</h3>
The program for discovering our neighbours can be made more efficient. Currently, a node only performs two communications at a time in each direction; one send and one receive. In principle, a processor could send its ID along all 8
available direction. Likewise, its neighbour could receive along all 8 of its
communication channels. The goal of this exercise is for you to write a
program that discovers its neighbours in this manner.

<p>

<h3>Checkerboard Partitioning</h3>
Checkerboard partitioning of processors (also known as even-odd partitioning
or red-black partitioning) assigns a parity (colour) to each processor which
can be either even (red) or odd (black). The name checkerboard partitioning
comes from the fact neighbouring processors have opposite parities (colours).
See figure <a href="#f:checkerboard_proc">3.7</a> for a picture of a two dimensional 
processor grid separated into even and odd (red and black) sites.

<p>
<a name="tth_fIg3.7">
</a> 
<center>
<img src="checkerboard_proc.gif" alt="checkerboard_proc.gif" />
<!--hbox-->
</center>

<center>Figure 3.7: A 4x4 grid of processors with checkerboard partitioning. Note that
any one processor has oppositely coloured neighbours</center>
<a name="f:checkerboard_proc">
</a>

<p>
The idea here that in the end processors of one colour (say red) can
send their ID's to all their neighbours of the other colour (in this
case black), while processors of the other colour (black) can receive
along all 8 of their wires. Hence half of all the processors (the
black ones) can discover the identities of all their neighbour in one
single communication step. The communication could then be repeated, with
the colours interchanged. In other words, in the second communication,
all the processors of the second colour (black in this case) can transmit
their IDs to processors of the first colour (red).

<p>
Thus all the nearest neighbours can be discovered using in effect two
communication steps.

<p>

<h3>Exercise 1: Am I red or am I black</h3> 
Let the two parities be denoted 0 (for red say) and 1 (for black). First
thing the processor has to do is identify its parity. It could do this 
for example based on its coordinates in the physics network. Implement
a routine using the relevant system calls by which each processor determines
its parity.

<p>

<h3>Exercise 2: Do the transfer</h3>
Implement the neighbour discovery algorithm outlined above.

<p>
 <h1><a name="tth_chAp4">
Chapter 4 </a><br />Collective Communication</h1>

 <h2><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;What are Collective Communications ?</h2>
In the previous chapter we have briefly described the basic <tt>SCU</tt> 
calls for nearest neighbour point to point communication. This 
kind of communication is fine if we want to program communications
between processors that are reminiscent of the HPC <tt>CSHIFT</tt> 
function for example, or if we wish to build systolic array like 
systems.

<p>
Occasionally however we may want to perform certain global communications
such as a sum of data items held across all the processors. An immediate
example of such a situation is the case of taking the scalar product of two vectors. Imagine that the vector
components are distributed amongst the nodes of the parallel computer. Each 
processor could work out the sum of the squares of its local vector components
but to accumulate the dot product, these local results would have to be
globally summed. 

<p>
 <h2><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Who Communicates?</h2>
The distinguishing feature of global communications also known
sometimes as collective communications is that all the processors make
the call to the communication routines, whereas in the case of a point
to point communication, usually only the sending and the receiving
node call a communication routine.

<p>
In the case of MPI and other message passing standards usually one has
a way of selecting subgroups of processor nodes from a given available
set. In MPI for example the so called 'communicator' <tt>
MPI_COMM_WORLD</tt> refers to all available processors and subgroups of
these can be identified by defining new communicators (using such
routines as <tt>MPI_Comm_split</tt>.)

<p>
In the case of the QCDSP, selecting processor partitions is non
trivial. Machines are often 'manually hardware partitioned' ( a
technical process involving graduate student plugging wires on the
backplanes of crates ).  Alternatively, in a given hardware partition,
one may select a certain set of processors using the QOS command <tt>
qset_nodes </tt>.  Once a given set of nodes is selected by either method
however, it is non-trivial to sub-select again from within a running
program.  Consequentially, our description of collective
communications will refer to situations when all available processor
nodes take part in the communication. These kinds of collective
communications are referred to as global communications. From here on
we shall use the two phrases interchangeably.

<p>
 <h2><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Global Communication in General</h2>
We now describe some common types of collective communication.
Since a lot of these are in the MPI message passing interface
specification I shall refer frequently to MPI equivalents. If
you know MPI this should make things easy for you. It should
also clear up ambiguities (I hope) in other situations.

<p>

<h3>Barrier</h3> 
A <em>barrier</em> routine is used to synchronise a set of processors.
All the nodes call the barrier routine. The routine does not exit
until all the processes participating in the communication have
entered it. In MPI one would require a call to the function <tt>
MPI_Barrier</tt>. In the case of the QCDSP the functionality is provided
through the system call <tt>sync()</tt>, which is defined in the system
header file <tt>sysfunc.h</tt>.

<p>

<h3>Broadcast</h3>
There are two general kinds of broadcast routines. They are 

<dl compact="compact">
	<dd><b>One To All Broadcast: &nbsp;</b>
This is procedure where a given processor node (usually referred to as
the root processor) contains some information. This information 
is sent to all other processors during a one to all broadcast routine.</dd>

	<dd><b>All to All Broadcast: &nbsp;</b>
This is a procedure where at the outset each processor has an item
of data, and during the broadcast procedure each processor makes available
its data to all other processors. At the end of the broadcast, all
the processors are in possession of the data elements from all the other
processors.</dd>
</dl>

<p>
The idea of the two kinds of broadcasts are illustrated in figures
<a href="#f:oneToAllBroadcast">4.1</a> and <a href="#f:allToAllBroadcast">4.2</a> respectively.

<p>
<a name="tth_fIg4.1">
</a> 
<center>
<img src="one_to_all_bcast.gif" alt="one_to_all_bcast.gif" />
<!--hbox-->
</center>

<center>Figure 4.1: One to all broadcast. The circles represent
processor nodes. Before the broadcast, the root node holds the data
item to be distributed, in this case the number 1. After the
broadcast, the data item is found on all processors</center>
<a name="f:oneToAllBroadcast">
</a>

<p>

<p>
<a name="tth_fIg4.2">
</a> 
<center>
<img src="all_to_all_bcast.gif" alt="all_to_all_bcast.gif" />
<!--hbox-->
</center>

<center>Figure 4.2: All to all broadcast: The circles represent processor nodes.
Before the broadcast all items hold their own data (the numbers inside 
them). After the broadcast, each processor has a copy of everybody 
else's data.</center>
<a name="f:allToAllBroadcast">
</a>

<p>
Important uses of broadcast operations can include the distribution
of parameters from a source processor as well as situations where 
one processor has to be a 'master' and has to make global decisions.
These decisions then probably need to be broadcast out to the other processors.

<p>

<h3>Gather and Scatter</h3>
The <em>gather</em> operation is one in which all processors send their
data to a nominated root processor. Its opposite is the so called 
<em>scatter operation</em> where the nominated root processor distributes
a vector of data, to the whole processor grid. The operations are illustrated
in figure <a href="#f:gatherscatter">4.3</a>.

<p>
<a name="tth_fIg4.3">
</a> 
<center>
<img src="gatherscatter.gif" alt="gatherscatter.gif" />
<!--hbox-->
</center>

<center>Figure 4.3: Above: Scatter operation. One processor 'scatters' its data
amongst the complete set. Below: Gather operation: The data from all
processors is 'gathered' onto a root processor.</center>
<a name="f:gatherscatter">
</a>

<p>
Sometimes the terms <em>gather</em> and <em>scatter</em> are generalised, to
mean that one processor distributes its data to some subset of other
processors (for example its nearest neighbours in the processor
grid). In this sense the corresponding gather would be the collection
of data from the same subset of processors.

<p>
In fact the broadcast operation can be implemented as a scattering
operation, where all processors receive the same data item. Likewise
the neighbour discovery exercise at the end of the last exercise (have
you attempted it?)  is an example where we combine a generalised
gather and a generalised scatter.  The generalised gather is that each
node (of a given parity) receives the processor ID of its nearest
neighbours, whereas the generalised scatter is the part where every
node (of the opposite parity) sends its ID to its nearest
neighbours. The MILC collaboration, in their code<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a> has refined the
generalisation of gathering and scattering to such a level where a
user can actually define his or her own gather and scatter mapping.

<p>
Scatter and Gather operations are useful for example to distribute data
that has just been read from disk by a master processor (assuming of course
that the master processor can hold all the data in memory) or to pass out
processor specific decisions. It can also be used, as mentioned before
to implement the broadcast operation. Generalised scatters can be useful
for exchanging data boundaries between processors for example.

<p>

<h3>Global Reduction</h3>
Global reduction operations generally take data from each node and
produce one single (reduced) result. Examples of global reduction are
global sums, global products, global XOR operations, finding global
minima and maxima. In fact any associative operation can be used as a
reducing operation. It perhaps for this reason that MPI has only two
functions <tt>MPI_Reduce</tt> and <tt>MPI_Allreduce</tt> to carry out all
their reduction operations<a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>, instead of having separate global sum, global XOR and
other global routines.

<p>
Once again there are two kinds of global reduction operations.

<dl compact="compact">
	<dd><b>All to One Reduction: &nbsp;</b> - these are reduction operations
where the final answer is left with one nominated (root) processor. 
These correspond to <tt>MPI_Reduce</tt>.</dd>

	<dd><b>All to All Reduction: &nbsp;</b> - these are reduction operations
where the final answer is given to every processor. These correspond 
to <tt>MPI_Allreduce</tt>.</dd>
</dl>

<p>
It should be clear for example that one can implement all to all 
reduction operations as an all to one reduction operation followed 
by a broadcast.

<p>
An important use of global sums for example is in the computation
of scalar products. A use of a global maximum operation for example
would be to find the infinity norm of a distributed vector. Global
XOR operations may be needed for checksumming a distributed dataset.
A quick and dirty floating point broadcast routine could be written
using a global sum where the root node contributes to the sum the 
amount it wishes to broadcast and all the other processors contribute
0. 

<p>
A <b>warning</b> about global sums and other global operations which
are susceptible to cancellation errors and or bit overflow problems:
The QCDSP system can contain anything from between 64 nodes to
O(10<sup>5</sup>) nodes. Even if a single node has only component to contribute
to a particular reduction, it is possible that when for example 16K 
processors are involved in an operation there is a serious chance
of overflow or that cancellation errors have a serious effect.
There are two ways to address this problem:

<ul>
<li>The implementors should implement their reduction operations in 
such a way as to minimise the problems of rounding error accumulation/
overflow/underflow. They could for example carry out sums in a logarithmic
manner etc.</li>

<li>
The implementors could throw extra bits of precision at the problem,
and provide status registers indicating overflow underflow.</li>
</ul>

<p>
 <h2><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Global Communication on the QCDSP</h2>
The QCDSP was designed to run simulations of lattice QCD. The predominant
communication pattern for this application is nearest neighbour, with
the occasional need for global operations. In fact lattice QCD does
not really require more in terms of communications than
broadcasts, nearest neighbour gather and scatter operations, global
sums, global minima and maxima. 

<p>
Consequentially, the design of the hardware and the software reflect
these needs. The hardware design is such as to favour efficient
nearest neighbour communications. Although the hardware does have
support for performing global reduction operations, accessing them is
not entirely straightforward. Also, since these global reduction
operations were found not to be a major performance bottleneck, little
effort has been made to optimise them. Even worse, the global
communication routines that are optimised are part of the
Columbia/Brookhaven Physics system and are not available for general
use.

<p>
Distributed data is loaded to the processors by the QOS before applications
start running. (More details in the Chapter on I/O) This sidesteps the
need for routines that gather and scatter data to and from some
root processor for the purposes of file I/O. Furthermore these are not
entirely straightforward for a general user to code up as there is no
hardware support for routing a message from any given processor to the
root processor directly. An implementer would have to pass the message 
through intermediate processors, which are neither senders nor receivers
of this information possibly having to stop computation on the intermediate
processors for this purpose.

<p>
All that remains for a user to implement then are global reduction
routines and broadcasts. We now look at some algorithms for
performing these global communications. We then present a simple
library that performs global sums, minima and maxima for numbers of
type <tt>float</tt>. Users are welcome to use this library in their own
programs, or can use the library merely as an example to aid in
writing their own routines.

<p>
 <h2><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Global Reduction Algorithms for Ring Architectures</h2>
We now discuss some global reduction algorithms for 1D ring architectures.
A 1D ring is simply a set of processors connected in series with 
wrap around edges at the ends of the line. A picture of a ring can
be seen in figure <a href="#f:1Dring">4.4</a>.

<p>
<a name="tth_fIg4.4">
</a> 
<center>
<img src="1Dring.gif" alt="1Dring.gif" />
<!--hbox-->
</center>

<center>Figure 4.4: A 1D ring. The circles represent processors and the lines
represent connections.</center>
<a name="f:1Dring">
</a>

<p>
Although the QCDSP has a network connectivity that is a four dimensional 
torus it can also be viewed as a collection of rings. We illustrate
the idea for a two dimensional torus in figure <a href="#f:TorusRing">4.5</a>.
Here we can look at a two dimensional torus as a collection of rings in
either the <em>x</em> or <em>y</em> directions

<p>
<a name="tth_fIg4.5">
</a> 
<center>
<img src="torusRing.gif" alt="torusRing.gif" />
<!--hbox-->
</center>

<center>Figure 4.5: (a)A 2D torus as a set of 1D rings in the (b) <em>x</em> direction and (c) the <em></em> direction</center>  
<a name="f:TorusRing">
</a>

<p>
One general way of programming global reduction algorithms on a 4D mesh
is to perform the operation first on all rings in the <em>x</em> direction,
then on all the rings in the 'y' direction and so on in the remaining two
directions. 

<p>

<h3>Ring all to all reduction algorithm</h3>
Consider the following reduction algorithm:

<p>
Each processor in the ring sets up a buffer to store the result of the
reduction. The result buffer is initialised with the processors own data.

<p>
Each ring then transmits its data in one direction along the ring
and receives data from the opposite direction. (We shall refer to these 
as the positive and negative directions respectively). The data that
has been received is combined with the data in the result buffer, to 
generate a new intermediate result..

<p>
The process of transmitting the local data in the positive direction
and receiving data from the negative direction and combining it with the
result is repeated until each data item has visited each processor once.
For a ring containing <i>n</i> processors exactly <i>n</i><font face="symbol">-</font
>1 steps are needed.
When all the steps are complete, the result buffer should contain the
final answer.

<p>
The process is illustrated for addition in a 4 processor ring in figure
<a href="#f:ring_addition">4.6</a>.

<p>
<a name="tth_fIg4.6">
</a> 
<center>
<img src="1Dring_addition.gif" alt="1Dring_addition.gif" /><!--hbox-->
</center>

<center>Figure 4.6: 1D Ring Addition Algorithm: At each step data is passed in 
the positive direction (right) and received from the negative direction (left).
The data is then added to the results buffer. After 4-1 = 3 steps
all the processors have the global sum</center>
<a name="f:ring_addition">
</a>

<p>
Note that in this particular algorithm, each processor performs the
sum in a different order from its neighbour. This is one of the
reasons why reduction operations need to be associative. Also since
floating point arithmetic is not really associative due to roundoff
errors, it is possible that rounding errors will affect different
processors differently and for a floating point global sum using the
above algorithm, it is possible that the answers on individual
processors are not bit-identical.

<p>
This can be a problem for example if one is trying to decide whether one 
meets the stopping criteria for some iterative process based on the result
of a global sum (such as in the case of an iterative solver, where the 
stopping criteria depends on a scalar product). Clearly it is possible
that some processors meet this criteria and some, due to rounding errors
do not. 

<p>
The problem can be solved by nominating one processor as the master of
the others. The decision as to whether to stop the solver will then
depend on the result held by the master node. One can either broadcast
the master's result and let each processor make its decision based on
that, or alternatively the master can make the decision and broadcast
it instead in the form of a token, a flag or in some other encoding.
Alternatively one can formulate the global sum so that the results are
guaranteed to be bit identical across all the processors, say by using
a different algorithm where the sum is first reduced to some single root 
processor in all the rings which then transmit the sum back along their
respective rings before going on to the next dimension.

<p>

<h3>Mesh Global reduction algorithm</h3>
As mentioned before, the generalisation of the ring algorithm to the 
mesh is simply to perform the global operation along each ring in
parallel for a given direction, and to repeat this process for 
all directions. 

<p>
Figure <a href="#f:2DMeshsum">4.7</a> shows the idea for a two dimensional mesh.

<p>
<a name="tth_fIg4.7">
</a> 
<center>
<img src="mesh_sum.gif" alt="mesh_sum.gif" />
<!--hbox-->
</center>

<center>Figure 4.7: 2D Mesh Global sum. First the sum is performed along both 
rings in the horizontal direction. Second it is performed along 
both rings in the vertical direction.</center>
<a name="f:2DMeshsum">
</a>

<p>

<h3>Coding the Routines For the QCDSP</h3>
We show below the QCDSP C++ code for finding the global maximum
using similar the algorithms described above.

<pre>
// ------------------------------------------------------
// Include Files
// ------------------------------------------------------





// ------------------------------------------------------
// Macros for picking local min/max
// ------------------------------------------------------
#define max(A, B) ((A) &#62; (B) ? (A) : (B))

// -------------
// Buffer space 
// -------------
static float transmit_buf;
static float receive_buf;
static float max_buf;

// ------------------------------------------------------
// Function glb_max
//
// Argument: A pointer to the local number that is to
// be considered for being the Global Maximum. At the end
// of the function, the pointer points to the global maximum
// ------------------------------------------------------
void glb_max(float * float_p)
{
  // ---------------------------------------------
  // Size of the Processor Grid in each dimension
  // ---------------------------------------------
  int NP[4] = {SizeT(), SizeX(), SizeY(), SizeZ()};

  // ---------------------------------------------
  // Array to hold SCU send and receive directions
  // We will later index into this.
  // ---------------------------------------------
  const SCUDir dir[] = { SCU_TP, SCU_TM, SCU_XP, SCU_XM,
                         SCU_YP, SCU_YM, SCU_ZP, SCU_ZM };
  // ---------------------------------------------
  // Place the local number in the comparison buffer
  // ----------------------------------------------
  max_buf = *float_p;

  // ----------------------------------------------
  // Loop over the processor grid dimensions
  // ----------------------------------------------
  int dim;
  for(dim = 0; dim &lt; 4; dim++) {

      // -----------------------------------------
      // Send our local minimum in the +ve direction
      // (NP[ 2 * dim ]) direction and receive from the
      // -ve (NP[ 2 * dim ]) direction with wraparound
      // at the pe grid boundary. Do this NP - 1 times
      // so that everyone can compare everybody's data
      // in this dimension
      // -----------------------------------------
      transmit_buf = max_buf;

      int tmp;
      for (tmp = 1; tmp &lt; NP[ dim ]; tmp++) {
        // -----------------------------------------
        // Set up the communications handles:
        // -----------------------------------------

        SCUDirArg send(&amp;transmit_buf, dir[ 2*dim ],
                       SCU_SEND, sizeof(float));
        SCUDirArg rcv(&amp;receive_buf, dir[ 2*dim+1 ],
                      SCU_REC, sizeof(float));


        // -----------------------------------------
        // Perform the transfers
        // -----------------------------------------
        SCUTrans(&amp;send);
        SCUTrans(&amp;rcv);

        SCUTransComplete();

        // -----------------------------------------
        // Keep the maximum of what you had and what
        // you just received
        // -----------------------------------------
        max_buf = max(max_buf, receive_buf) ;

        // -----------------------------------------
        // Pass on the received data
        // -----------------------------------------
        transmit_buf = receive_buf;
      }
  }

  // --------------------------
  // Store the global max
  // --------------------------
  *float_p = max_buf;
}

</pre>
The global minimum and sum routines would follow a similar pattern.

<p>
 <h2><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;A simple collective communications library</h2>
In a manner similar to the <em>hello_world</em> program a simple
global communications library is available on the QCDSP (once 
Bob puts it in place). It can be found in <tt>/qcdsp/sfw/qos.5.3.3/example/glb</tt>.This directory has subdirectories <tt>include</tt>, <tt>lib</tt>, <tt>src</tt> and <tt>test</tt>. There is also a makefile in this directory of which more later.

<p>
The <tt>include</tt> directory contains the file <tt>glb.h</tt> which defines
the global communication subroutines. This has to be included in any 
user programs using the <tt>
subdirectory contains the source files for the library plus a makefile
to build the libraries. The <tt>lib</tt> directory is where the compiled
library gets placed after it is built in the <tt>src</tt> subdirectory. 
This is the library that has to be linked with the user code and
is called <tt>glblib.olb</tt> on the QCDSP. Finally, the <tt>test</tt> 
directory contains a simple program that uses the library.

<p>
To build the library and the tests, go to the toplevel directory 
and type <tt>make all</tt>. Once this process is finished, you should
find <tt>glblib.olb</tt> in the <tt>lib</tt> subdirectory and an
executable called <tt>glb_test.out</tt> in the <tt>test</tt> subdirectory.

<p>

<h3>The Library Routines</h3>
The library provides the following routines.

<dl compact="compact">
	<dd> <tt>void glb_sum(float * float_p)</tt> : &nbsp; This routine
performs a global sum over all the processors. On entry, <tt>float_p</tt> 
should point to each node's own contribution to the sum. On exit
<tt>float_p</tt> will point to the result of the global sum. The algorithm
for the sum is as detailed in the last section. The sum is actually 
performed in 64 bits of precision through a user defined type. This
aspect of the operation is completely hidden from the user. At the 
end of the operation the result is rounded back to a 32bit result.</dd>

	<dd> <tt>void glb_max(float * float_p)</tt> : &nbsp; This routine 
finds the global maximum across all the processors. On entry <tt>float_p</tt>
points to the each processor's own data. On exit <tt>float_p</tt> points
to the maximum of these elements. This subroutine was listed explicitly in
the last section.</dd>

	<dd> <tt>void glb_min(float * float_p)</tt> : &nbsp; This routine
finds the global minimum across all the processors. On entry <tt>float_p</tt>
points to each processor's own data. On exit <tt>float_p</tt> points
to the minimum of these elements.</dd>

	<dd> <tt>void glb_bcast(float * float_p, int root_id)</tt> : &nbsp; This 
routine broadcasts the number pointed to by <tt>float_p</tt> on the node
with unique ID <tt>root_id</tt> (as determined from <tt>UniqueID()</tt>) to
all the processors.  The broadcast is implemented as a global sum with
node <tt>root_id</tt> contributing the number to be broadcast at the end
of <tt>float_p</tt> and all the other nodes contributing 0 to the sum.</dd>
</dl>

<p>
We recommend that the reader takes a look at the source code to be
found in the <tt>src</tt> subdirectory to look at the code for the above 
library routines. However most of them are similar to the global
maximum routine listed earlier.

<p>

<h3>Using the Library</h3>
We list below the test program from the <tt>test</tt> subdirectory which 
shows all of the library routines in use. The program first sums the 
unique IDs of all the nodes, then finds the maximum and minimum of these.
Finally it broadcasts the ID's of each processor in turn and sums 
them accross the processor grid. The code is shown below:
<font size="-1">

<pre>







int main(int argc, char *argv[])
{
  float sum_serial = 0;
  int i;

  // -----------------------------
  // Serial sum of processor ID's
  // -----------------------------
  for(i = 0; i &lt; NumNodes(); i++) {
    sum_serial += (float) i;
  }

  // ----------------------------
  // Put Unique ID into buffer
  // ----------------------------
  static float my_buf = (float)UniqueID();

  // ----------------------------
  // Sum Unique IDs
  // ----------------------------
  glb_sum(&amp;my_buf);

  // ----------------------------
  // Output results
  // ----------------------------
  printf("Serial Sum of IDs = %g  Global Sum = %g\n", sum_serial, my_buf);


  // ----------------------------
  // Find Minimum ID
  // ----------------------------
  my_buf = (float)UniqueID();
  glb_min(&amp;my_buf);

  printf("Minimum Unique ID should be 0. It is %g\n", my_buf);

  // ----------------------------
  // Find Maximum ID
  // ----------------------------
  my_buf = (float)UniqueID();

  glb_max(&amp;my_buf);

  printf("Maximum Unique ID should be %g. It is %g\n", 
         (float)(NumNodes()-1), my_buf);

  // ----------------------------
  // Do some broadcasting
  // ----------------------------
  for ( i = 0; i &lt; NumNodes(); i++ ) {

    // -------------------------------
    // Process I will broadcast its ID
    // to everyone
    // -------------------------------
    if( UniqueID() == i ) {
      my_buf = (float)i;
    }
    else { 
      my_buf =(float) 200;
    }

    // -------------------------------
    // Broadcast with proc i as root: 
    // Should end up with i on each node
    // -------------------------------
    glb_bcast(&amp;my_buf,i);
    
    // -------------------------------
    // Do a global sum on the result 
    // (should be NumElems()*i)
    // -------------------------------
    glb_sum(&amp;my_buf);

    printf("Global sum of buffers should be %g. It is %g\n", 
          (float)(NumNodes()*i), my_buf);

  }
  return(EXIT_SUCCESS);

}

</pre>
</font>
When printing the result of each operation the program also prints
out what it expects the real result to be.

<p>
Why not compile up the library as indicated before and try out the test
program. On <tt>q_1</tt>, which is a 64 node development board I got
the following output.

<pre>
Serial Sum of IDs = 2016  Global Sum = 2016
Minimum Unique ID should be 0. It is 0
Maximum Unique ID should be 63. It is 63
Global sum of buffers should be 0. It is 0
Global sum of buffers should be 64. It is 64
Global sum of buffers should be 128. It is 128
.
.
.

</pre>

<p>

<h3>Using the Library in your own programs</h3>
To use the library in your own programs you must do two things.

<ul>
<li>Firstly, you must include the header file <tt>glb.h</tt> in every
source file that uses the routines.</li>

<li>
Secondly, you must link to the library <tt>glblib.olb</tt>. This
may involve having to edit the Makefile. If you dislike this
idea (its not that bad really) simply copy the files ending in
<b>.C</b> from the <tt>src</tt> subdirectory into the directory 
you are working in. The default makefiles should compile
them up for you.</li>
</ul>

<p>
We shall say discuss compilation and linking in more detail in 
a later chapter. For now suffice it to say that both are done
using the <tt>tcpp</tt> command. 

<p>
To include the <tt>glb.h</tt> header file, it is perhaps easiest 
if you leave it in some sensible (Perhaps Bob will leave it
in a sensible place where it can stay forever). You can then do 
one of two things.

<ul>
<li>You can include it with the directive <tt>
where for <tt>sensible_path</tt>, you should substitute the path
of the sensible place where the header file lives.</li>

<li>
You can include it with the directive <tt>
case you have to make sure that the compiler will look in the sensible
place where the <tt>glb.h</tt> file is by default. You can specify
a list of directories for the compiler to search with the <tt>-i</tt>
compiler flag.</li>

<li>
If you feel really unhappy about either of the above options you can
always copy the <tt>glb.h</tt> file into the directory that you are working
in and just include it as <tt>
neither edit the makefile nor mess with compiler flags. Its the 
chicken way out tho' and it may leave you open to having
different versions of the header file in different projects. A real
nightmare...</li>
</ul>
I prefer the latter method personally, as then I only have to 
type the name of the directory in which the file lives once, in
the makefile.

<p>
However I do repeat: <b>If you fear and loath makefiles, do not
panic for we shall clarify them in a later chapter. Until then, just
copy the files from the <tt>src</tt> subdirectory and <tt>glb.h</tt> to the
directory where you are coding and use the default makefiles.</b>

<p>
 <h2><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;Summary of Chapter</h2>
In this chapter, we have discussed collective communications.
After outlining some of the most common global communication techniques,
the barrier, the broadcast, gather, scatter and reduction operations
we discussed which of these may be implemented on the QCDSP. 
We then outlined some simple algorithms for performing global reduction
operations on a mesh parallel architecture. Finally, we discussed a
simple library for the QCDSP which defines global sums, maxima and minima
for floating point numbers.

<p>
 <h2><a name="tth_sEc4.8">
4.8</a>&nbsp;&nbsp;Exercise</h2>
Can you think of more efficient ways of doing global sums on the 
QCDSP ? You should be able to get some ideas from the QCDSP WWW page:
<tt>http://www.phys.columbia.edu/&#126;cqft/qcdsp.htm</tt> where they describe
the hardware support for global sums. You can also get some ideas
from the book ``Introduction to Parallel Computing'' by Vipin and Kumar
who have gone to great lengths to describe network topologies and 
routing algorithms in use in general parallel computers.

<p>
 <h1><a name="tth_chAp5">
Chapter 5 </a><br />I/O on the QCDSP</h1>

 <h2><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Introduction</h2>
In this chapter we discuss the facilities afforded by QCDSP to perform
input and output (I/O). We consider three aspects: parallel I/O. 
Serial File I/O and I/O to the terminal screen during job runtime.

<p>
 <h2><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Parallel I/O</h2>
The QCDSP is a massively parallel supercomputer. Hence there is a high
likelihood (in the case of Lattice QCD it is virtually a certainty) that data
is in some way distributed amongst the numerous QCDSP nodes. The question
then is, how to collect data from the nodes of the QCDSP so that it 
can be written to disk, or alternatively, how to get data from a disk
onto the nodes of QCDSP.

<p>
A complication is that on the QCDSP only one processor, to which we
shall refer hereafter as the root node (Motherboard 0, Daughterboard 0,
Unique ID=0) is allowed to actually perform I/O onto a disk on the
host computer. The other nodes can output to what in a UNIX system
would be the <em>standard output</em> stream. This however is merely a
storage buffer on the memory of the node in question, that has to be
retrieved later using the <b>qprintf</b> command (as discussed in
section one).  In fact only node 0 can write to the output stream
during run time in a way that it is echoed on the screen of a user or
can be redirected into a file.  The QOS has no concept of other
streams such as the UNIX <em>standard input</em> and <em>standard
error</em>. On the other hand the <b>qrun</b> command does allow the
passing of <em>command line arguments</em> to executing programs as will
be demonstrated later.

<p>
Hence, one would think that the best way to read a serial file and
distribute its data amongst processors is for the root node to read
the data and perform various scatter operations to distribute the
data.  Alternatively, saving of data could be done by the root
processor gathering data from the other processors and then writing it
out to disk. This is all very well, as long as the root processor can
hold the whole overall dataset in memory. However, a the amount of
DRAM memory on a single node is quite small, a mere
0.5Mwords<a href="#tthFtNtAAH" name="tthFrefAAH"><sup>7</sup></a>. Of this the run time operating
system occupies 128Kwords leaving a mere 384Kwords to the user. This
has to include the user code as well as the user data. Hence one
would be reduced to communicating the data from the nodes to the root node, at 
a rate of one pair of processors at a time. Since the QCDSP has no general
point to point communication routines, this process would have to be implemented
using the usual nearest neighbour communications.

<p>
Another alternative would be to use a parallel file system. There is 
such a system currently under development for the QCDSP, however it
is not yet an integral part of the QOS, and hence it shall not be 
discussed any further here. 

<p>
The question then remains: How can parallel data be loaded and
distributed in a straightforward manner on the QCDSP, and how can the
data be saved from amongst all the processors into one file. On the
QCDSP this is done via the <b>qread</b> and <b>qload</b> commands using
objects called Node Tagged Tiles (NTFs). An NTF is a single serial
file written in ASCII (can we do binary Bob?) that contains the
relevant data from all the nodes of the QCDSP. Preceeding the data
from a given node is a tag identifying the node which is to host the
data. We will discuss their detailed. One can then develop
workstation tools to convert between these NTFs and regular serial
files. For those readers who intend to load and save lattices to and
from the Columbia Physics environment (stored in the Gauge Connection
Archive Format<a href="#tthFtNtAAI" name="tthFrefAAI"><sup>8</sup></a>) QOS provides the more specialised commands: <b>
qload_lattice</b> and <b>qunload_lattice</b>. 

<p>
 <h2><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Parallel I/O with NTFs, qread and qload</h2>
When a QCDSP program exits and the QOS returns control to the front end,
the memory space of the program prior to exit is left untouched. The 
<b>qread</b> and <b>qunload_lattice</b> routines access this memory directly
and dump a user specified number of data blocks from a 
user specified memory address to a file. The <b>qread</b> command can 
dump either to a screen or to a NTF. Its output is always in ASCII
format. The <b>qunload_gauge</b> command writes directly to a file
in the Gauge Connection Archiver format.

<p>
The <b>qload</b> command can be used to place data into processor
memory prior to execution. It works in two ways:

<ul>
<li>One can specify a memory address and the value to be placed there
as command line arguments to <b>qload</b>. The <b>qload</b> command will
then place the given value into the given memory address. The user program
can then be run. It can be passed the address of the data and the number
of data blocks as command line parameters. Once running the code can set
a pointer to the given address and copy the relevant data to some 
of its own memory.</li>

<li>
The qload command can be given the name of an NTF. The NTF contains
the starting address and the number of blocks for the data,as well as the
data itself, for each processor.
The program can access the data by setting a pointer to the  address.
which can be passed as a command line argument.</li>
</ul>

<p>
The <b>qload_lattice</b> command works similarly to the <b>qload</b>
command. However the gauge connection format lattice file is not node tagged. 
The user passes the address where the first lattice site is to be placed
on each processor, and the name of the lattice file to the <b>qload_lattice</b>
command. The lattice sites are then placed into processor memory. A 
lattice object can then be instantiated giving the address of the first
lattice element to the lattice object constructor.

<p>
Of course in both the above cases dealing with <b>qload</b>, the data
may be copied directly into the program data area. This can be made to
be safe, as the linker produces resolved code. This means that the
code produced by the linker will not be relocated afterwards at the
start of execution. Hence one can print out the address of a declared
array in the program, safe in the knowledge that the next time the
program will run, the array will have the same address. <b>WARNING:
This behaviour is peculiar to the QCDSP.</b> Furthermore one can glean
information about the addresses of symbols after the compilation and
linking by looking through the linker map file. We shall discuss this
in more detail in the next chapter.

<p>
Before describing the details of the NTFs, and giving examples of using
the <b>qload</b> and <b>qread</b> lattices we should say a few words about
the organisation of memory on each node of the QCDSP. Even before that
here is possibly our most severe <b>WARNING: The command <b>qload</b>
can (and will) if incorrectly used, overwrite memory used by  the QOS 
operating system. This can have UNPREDICTABLE results ranging from no
effect, through subtle bugs, to system crashes. Be careful with it!!!</b>.

<p>

<h3>The DSP memory Map Part 1</h3>
The complete memory map of the DSP is quite complicated. In this section
we shall just describe a small part of it, that pertains to compiling
and running programs. 

<p>
The memory addresses on a single QCDSP node can range from 000000 to 
FFFFFF (remember your hexadecimal numbers?). This space however is 
not all memory and some of it is not accessible. In particular 
the 0.5Mwords of DRAM are mapped between addresses 001000
to 07FFFF. The addresses from 000000 to 001000 are not accessible by 
the DSP in the mode it is used. Memory addresses 080000 and upwards
are special. They either contain views of the data in real memory
(ie that between 000000 and 07FFFF) for use by other hardware such
as the circular buffer, or they contain the memory mapped
images of the DSP internal memory and control registers. We may
deal with some of these latter in the chapter on optimisation.

<p>
The run time operating system starts at 060000 and can stretch
until 07FFFF. Consequently <b>only the memory area from address
001000 to 05FFFF (inclusive) is available for user programs.</b>

<p>
This rough sketch of the memory map is illustrated in figure 
<a href="#f:MMap1">5.1</a>.

<p>

<p>
<a name="tth_fIg5.1">
</a> 
<center>


<table border="1">
<tr><td align="center"><b>Address Range</b> </td><td><b>Function </b> </td></tr>
<tr><td align="center">D00000 - FFFFFF </td><td>
<table>
<tr><td>Used on node 0. Unused elsewhere. Generally reading </td></tr>
<tr><td>from or writing to here will cause the DSP to hang </td></tr></table>
 </td></tr>
<tr><td align="center">880000 - CFFFFF </td><td>
<table>
<tr><td>Various images of the 0.5Mwords of DRAM between </td></tr>
<tr><td>000000 - 07FFFF for use of the circular buffer </td></tr></table>
  </td></tr>
<tr><td align="center">820000 - 87FFFF </td><td>Not used </td></tr>
<tr><td align="center">810000 - 81FFFF </td><td>Addresses of registers for controlling the NGA </td></tr>
<tr><td align="center">800000 - 80FFFF </td><td>Inernal DSP Memory and control register area </td></tr>
<tr><td align="center">080000 - 7FFFFF </td><td>
<table>
<tr><td>Images of 0.5Mwords of DRAM between 000000 - 07FFFF </td></tr>
<tr><td>for use of the circular buffer </td></tr></table>
 </td></tr>
<tr><td align="center"><b>060000 - 07FFFF</b> </td><td><b>128Kwords of DRAM reserved for Operating system</b> </td></tr>
<tr><td align="center"><b>001000 - 05FFFF</b> </td><td><b>384Kwords of DRAM for User programs</b> </td></tr>
<tr><td align="center">000000 - 000FFF </td><td>Inaccessible </td></tr></table>
<!--hbox-->
</center>

<center>Figure 5.1: Memory Map of a DSP node. The Memory is word addressed.</center>
<a name="f:MMap1">
</a>

<p>

<h3>Program Images</h3> 
If you have been using the default Makefiles you should find that 
usually a file is produced with the <b>.map</b> suffix alongside your
executable. In the case of the ``Hello Wold'' program this file would
be called something like <tt>hello_world.out</tt>. (The default makefile
always names output files after the directory in which the source files live).

<p>
The map file is quite useful as it tells you about how much memory 
your program has allocated statically during compilation, allowing you
to figure out how much space you have to <em>qload</em> your NTF into. 

<p>
Your program, as far as the linker is concerned consists of 6 parts 
of which 3 are negligible. The important three parts go by the names of
<em>data segment</em>, <em>binary stack segment (BSS)</em> and the <em>text segment</em>.
The unimportant parts are there mostly to supply information to debugging tools.
In the case of the Tartan Linker these are called the <em>debug directives</em> 
segment, the <em>debug strings</em> segment and the <em>debug source location</em>
segment. You need not care about these right now. Unless you switch on the
option on the compiler to produce debugging information, these latter three
segments will be empty.

<p>
The BSS contains amongst other things your runtime stack, on 
which C++ allocates automatic variables. The data segment is used
to hold various constant data items and the text segment holds the
actual machine level instructions of your program. Any free memory outside
these segments is unallocated and should be placed onto the heap when your
program starts running so that you can allocate memory from it dynamically.

<p>
The map file tells you about how your program is laid out in memory.
It starts off by telling you how much space is allocated to the various
segments. For example here are some excerpts from my <b>hello_world.map</b>
file

<p>
<font size="-1">
<pre>
Tartan Linker, SPARC/C40, v5.1.0        4/4/100 13:33:37                Page   1
Copyright (c) 1986-1992 by Tartan, Inc., All Rights Reserved


Allocation to Output Section ".bss" in module *unnamed* in file
"/homeqs0/bj/hello_world/hello_world.outtof"

  Offset   Length               Input Section

    1000      162       "TL.Init" in module "main" in file
                        "/homeqs0/bj/hello_world/main.tof"
    1162        1       ".bss" in module "qcdsp_tcroot" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    1163       21       "OWN" in module "inifin" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    1184     1000       ".stack" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/link.lcf"

  Total Allocation = 1184 (hex)

Allocation to Output Section ".data" in module *unnamed* in file
"/homeqs0/bj/hello_world/hello_world.outtof"
  Offset   Length               Input Section

    2184        D       "DEFALT" in module "qcdsp_tcroot" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    2191      16E       ".cinit" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/link.lcf"

  Total Allocation = 17B (hex)

Allocation to Output Section ".text" in module *unnamed* in file
"/homeqs0/bj/hello_world/hello_world.outtof"

  Offset   Length               Input Section

    22FF       6C       "_main" in module "main" in file
                        "/homeqs0/bj/hello_world/main.tof"
    236B       2A       ".text" in module "sysfunc" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcio30bs.olb"
    2395       56       ".text" in module "qcdsp_tcroot" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    23EB       26       "dbgrpc" in module "tcrpc" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    2411        7       ".text" in module "tcrpc" in file
                         "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    2418       32       ".text" in module "tcinit" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    244A       22       "_exit" in module "inifin" in file

Tartan Linker, SPARC/C40, v5.1.0        4/4/100 13:33:37                Page   2
Copyright (c) 1986-1992 by Tartan, Inc., All Rights Reserved

                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"
    246C        2       "__main" in module "inifin" in file
                        "/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/tcrt30bs.olb"

  Total Allocation = 16F (hex)

</pre>
</font>
You can clearly identify the three sections for the BSS, data and text segments.
(They are referred to as output sections <tt>.bss</tt>, <tt>.data</tt> and <tt>.text</tt>.)

<p>
Following all this information is a summary of the output sections that
tells you the total amount of memory allocated to each individual section.
In my <b>hello_world.map</b> file this looks like:
<font size="-1">

<pre>

                Output Sections

Section List for Module *unnamed* in file
"/homeqs0/bj/hello_world/hello_world.outtof"

Number  Physical   Start   Length  Kind         Access  Name
  1                  1000     1184 data                 ".bss"
  2                  2184      17B constant             ".data"
  3                  22FF      16F code                 ".text"
  4                     0        0 debug                "debug_directives"
  5                     0        0 debugstring          "debug_strings"
  6                     0        0 line number          "debug_source_location"
}

</pre></font>
This is perhaps the most useful piece of information in the map file.
It tells me the starting addresses of each of my program segments and 
how long they are (the columns Start and Length). I can see from here that 
my program uses memory from address 001000 to 0022FF + 16F = 00246E inclusive.
Hence if this program were to take any input via <tt>qload</tt> I would 
know that it should be safe to fill up memory from 0246F upwards.

<p>
The remainder of the map file lists every single symbol used in your
program. You may find it amusing to see how few of them you recognise.
Here are some symbols from the <b>hello_world.map</b> file that you 
may recognise
<font size="-1">

<pre>
Kind  Offset Sect Virtual Physical      Name
          6F   3     236E          "_CoorT"
          70   3     236F          "_CoorX"
          71   3     2370          "_CoorY"
          72   3     2371          "_CoorZ"
          93   3     2392          "_CurrentStatus__FiPc"
 W        97   3     2396          "_c_int00"
          6D   3     236C          "_DbNum"
         14C   3     244B          "_exit"
         14B   3     244A          "_exit$LAJ"
          8E   3     238D          "_fclose"
          8C   3     238B          "_fopen"
          8D   3     238C          "_fprintf"
          91   3     2390          "_HdwCheck__Fi"
          94   3     2393          "_InterruptExit__FiPc"
           1   3     2300          "_main"
           0   3     22FF          "_main$LAJ"
          6C   3     236B          "_MbNum"
          90   3     238F          "_NodeStatUpdate__Fv"
          77   3     2376          "_NumNodes"
          7C   3     237B          "_printf"

</pre>
</font>
You may be worried here that at startup, spurious memory allocation
might overwrite your qloaded data. This is not a worry here as the
map file includes the heap area as well. Hence if you place something
above the last address in the map file, it is guaranteed that it 
will not be malloced over. 

<p>
You can configure the size of the heap and other program layout
options in a file called the Linker Control File. If you do not 
use one of these the program will be linked under the control of 
a default linker control file which allocates a pitifully small heap.
(0x1000 words). Hence when you come to code bigger projects you
will have to allocate the heap yourself in your own LCF. This will
involve a partitioning of the available memory between room for 
your program, data you intend to allocate dynamically (heap) and data
you intend to qload. 

<p>
The standard procedure is to qload data very high in memory, just
below the operating system. Suppose you have data of say 32Kwords per
processor (0x8000 words (hex)). The operating system starts at address
0x060000 and so you might want to load the data to 0x06000 - 0x008000
= 0x058000. Then you can set up your LCF so that your program cannot
extend beyond 0x057fff (heap included). It is of course prudent to
leave a bit of room here and there in case you modify your program. In
the words of investment brokers ``The size of your program can go down
as well as up.''.

<p>
We will discuss linking, program sections and control files in more detail
in the next chapter about compiling and linking.

<p>

<h3>Node Tagged File Formats</h3>
We now discuss node tagged files.
Node tagged files are written in ASCII and contain hexadecimal numbers.
Although this can cause the files to be large and slow to read and write,
it does have the advantage that the files are readable without needing
specialist dump programs.

<p>
The file format consists of one hexadecimal entry on each line 
written in ASCII. The structure of the entries is given below.
below. Each heading and sub-heading corresponds to an entry 
in the NFT.

<dl compact="compact">
	<dd><b>A 'Magic Number' : &nbsp;</b> - This is an integer for identifying
which of the 3 types of node tagged files one is dealing with. The
three types are: 
<dl compact="compact">
	<dd>tree &nbsp; - the nodes are
tagged according to their position on the SCSI tree by a pair of
numbers (M,D) representing the node's motherboard and daughterboard
number respectively. Each of these numbers corresponds to a new entry
on a new line in the NTF. The magic number for this mode is 2.  This
is the 'default' tag mode. Node tagged files in this format usually
have a <b>.tree</b> file suffix.</dd>

	<dd>Machine 4D &nbsp; - the nodes are
tagged with their 4D coordinates within the processor grid (A
four-tuple of integers, each of these on a new line in the NTF). The
magic number for this tag mode is 3. Node tagged files in this mode
usually have a <b>.m4d</b> file suffix.</dd>

	<dd>Physics 4D &nbsp; - to all
intents and purposes this format the same as the machine 4D. Nodes are
tagged by their 4D coordinates. The meaning of fields however is
different. In terms of machine coordinates, everything is
fixed. However the machine coordinates can be re mapped at boot time to
interchange the order of coordinates. Hence (T,X,Y,Z) coordinates can
be re mapped to (X,Y,Z,T) coordinates etc. The machine 4D file never
changes the data layout. However the physics 4D file can shift the
data around depending on the current 4D mapping. The magic number for
this mode is 4. Node tagged files in this mode usually have the <b>
.p4d</b> file suffix.</dd>
</dl></dd>

	<dd><b>A sequence of Node Records</b> - for each node in the processor there is
a record. A record has the following structure.
	
<dl compact="compact">
	<dd>A Node Tag &nbsp; - A tag identifying the node. For the tree structure this consists of the  motherboard number followed by the daughterboard
number. For the 4D modes this is a four tuple of integers identifying the
4D coordinates of the node.</dd>

	<dd>The number of blocks for the Node &nbsp; - An integer indicating
how many blocks of data are to be loaded into the memory of the node (Hexadecimal without leading 0x)</dd>

	<dd>Base Address &nbsp;-  A hexadecimal address (without leading 0x) specifying the location in memory where the first data item is to be placed.</dd>

	<dd>Data Blocks &nbsp; - An ASCII representation of each data block. In the case of integers this is quite readable. In the case of floats it is not</dd>

	<dd>A terminator &nbsp; - An ASCII zero follows the final record as a 
record termination signal.</dd>
</dl></dd>
</dl>

<p>
The formats of the NTFs, the magic numbers, node tags and file extensions
are summarised in figures <a href="#f:NTFStructure">5.2</a>, <a href="#f:NTFRecStructure">5.3</a> 
and <a href="#f:NTFTypeSummary">5.4</a>.

<p>

<p>
<a name="tth_fIg5.2">
</a> 
<center>

<table border="1">
<tr><td align="center">Magic Number </td></tr>
<tr><td align="center">Record No 1 </td></tr>
<tr><td align="center">Record No 2 </td></tr>
<tr><td align="center"> : </td></tr>
<tr><td align="center">Last Record </td></tr></table>
<!--hbox-->
</center>

<center>Figure 5.2: Structure of a Node Tagged file - Components are sequential in an ASCII file. Each component starts on a new line</center>
<a name="f:NTFStructure">
</a>

<p>

<p>
<a name="tth_fIg5.3">
</a> 
<center>

<table border="1">
<tr><td align="center">Node Tag </td></tr>
<tr><td align="center"><i>n</i> - Number of blocks </td></tr>
<tr><td align="center">Base Address </td></tr>
<tr><td align="center">block[0] </td></tr>
<tr><td align="center">block[1] </td></tr>
<tr><td align="center">: </td></tr>
<tr><td align="center">block[ <i>n</i><font face="symbol">-</font
>1 ] </td></tr>
<tr><td align="center">0 (terminator) </td></tr></table>
<!--hbox-->
</center>

<center>Figure 5.3: Structure of a Node tag record - Each component is in ASCII on a new line</center>
<a name="f:NTFRecStructure">
</a>

<p>

<p>
<a name="tth_fIg5.4">
</a> 
<center>

<table border="1">
<tr><td align="center"> <b>File Type</b>  </td><td align="center"><b>Magic Number</b> </td><td align="center"><b>Node Tag Components</b> </td><td align="center"><b>File Suffix </b> </td></tr>
<tr><td align="center">Tree </td><td align="center">2 </td><td align="center">
<table>
<tr><td align="center">Motherboard No </td></tr>
<tr><td align="center">Daughterboard No </td></tr></table>
 </td><td align="center"><tt>.tree</tt> </td></tr>
<tr><td align="center">Machine 4D </td><td align="center">3 </td><td align="center">
<table>
<tr><td align="center">T Coordinate </td></tr>
<tr><td align="center">X Coordinate </td></tr>
<tr><td align="center">Y Coordinate </td></tr>
<tr><td align="center">Z Coordinate </td></tr></table>
 </td><td align="center"><tt>.m4d</tt> </td></tr>
<tr><td align="center">Physics 4D </td><td align="center">4 </td><td align="center">
<table>
<tr><td align="center">T Coordinate </td></tr>
<tr><td align="center">X Coordinate </td></tr>
<tr><td align="center">Y Coordinate </td></tr>
<tr><td align="center">Z Coordinate </td></tr></table>
 </td><td align="center"><tt>.p4d</tt> </td></tr></table>
<!--hbox-->
</center>

<center>Figure 5.4: Magic Number Node Tag and File Suffix information for the three node tagged file types. The magic number is the first number of any node tagged
file. It should be an ASCII integer on the first line. The node tag
fields should be ASCII integers. Each entry should take a separate
line in the file.</center>
<a name="f:NTFTypeSummary">
</a>

<p>
Perhaps the easiest way of creating a node tagged file is to dump
some memory from a program. We now proceed to demonstrate how this is done.

<p>
 <h2><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;Creating Node Tagged files using qread</h2>
Consider the following little program:
<font size="-3">

<pre>








int main( int argc, char *argv[] ) 
{
  float i[5]={1.0,2.0,3.0,4.0,5.0};

  printf("The address of i is %x and its length is %x blocks\n",
           i, 5*sizeof(int));

  return(EXIT_SUCCESS); 
}

</pre>
</font>

<p>
The code itself does nothing, but prints out the address of the first 
element of the floating point number array <tt>i</tt>. We can use this 
information to dump the floating point array into an NTF.

<p>

<h3>Setting options for qread</h3>
There are several options that allow you to control how you want to
perform the dump. For example, you can dump to a screen or a named 
file. You can dump into an NTF of either the tree, machine 4D or 
of the physics 4D variety. You can rewrite an existing file or 
append to it. These options are set by the following <tt>qcsh</tt> commands:

<dl compact="compact">
	<dd><tt>qset_read_output_filename</tt> : &nbsp; This command takes one 
argument which is the name of the file you want <tt>qread</tt> to 
dump your data to.</dd>

	<dd><tt>qset_read_output_file_access</tt> : &nbsp; This command 
takes a single argument to determine whether you wish to use
the append write mode or the overwrite mode. The possible arguments
are 
	
<dl compact="compact">
	<dd><tt>a &nbsp;</tt> - append mode</dd>

	<dd><tt>w &nbsp;</tt> - write mode</dd>
</dl></dd>

	<dd><tt>qset_read_output_select </tt> : &nbsp; This command determines 
whether you wish your dump to go to the screen or to a named file
(that you have to name using <tt>qset_read_output_filename</tt>.
It takes a single argument. The argument can have the following values:

<dl compact="compact">
	<dd><tt>f &nbsp;</tt> - dump to named file</dd>

	<dd><tt>s &nbsp;</tt> - dump to screen</dd>
</dl></dd>

	<dd><tt>qset_read_output_tagged</tt> : &nbsp; This command determines
the tag type of your dump file. It takes a single argument. Allowed 
argument values are

<dl compact="compact">
	<dd> <tt>no &nbsp;</tt> - Do not node tag the file. I do not describe the
results of this option.</dd>

	<dd> <tt>yes &nbsp;</tt> - Place node tags into file. Use default tag mode (tree).</dd>

	<dd> <tt>tree &nbsp;</tt> - Use tree tag mode.</dd>

	<dd> <tt>m4d &nbsp;</tt> - Use machine 4D tag mode.</dd>

	<dd> <tt>p4d &nbsp;</tt> - Use physics 4D tag mode.</dd>
</dl></dd>
</dl>

<p>

<h3>Using qread to dump to a file</h3>
Let us now have a go at dumping the floating point array in the previous
code snippet. Create a directory called <tt>dump</tt> somewhere and copy
the program listing above into a file named <tt>main.C</tt> (alternatively
the directory may be available under <tt>&lt;QOS_VERS&#62;/examples/ParIO/dump</tt>).

<p>
If you are doing things by hand, you probably want to copy a 
default <tt>Makefile</tt> from the <tt>hello_world</tt> directory and
build the program by typing <tt>make</tt>. This should produce a program
called <tt>dump.out</tt>. If you are copying the directory structure it should
have a Makefile with it.

<p>
Boot the machine and enter the QC-Shell.I will use the machine <tt>
q_1</tt>.  Now let us suppose that we want to dump the <tt>float</tt> array
from each PE into a file called <tt>foo</tt>.  Let us try first with the
tree node tag mode. We set up the dump using the following <tt>qcsh</tt>
commands (I removed the Qdaemon responses to save space).

<pre>
(dump: qcsh[q_1])% qset_read_output_select f
(dump: qcsh[q_1])% qset_read_output_filename foo.tree
(dump: qcsh[q_1])% qset_read_output_file_access w
(dump: qcsh[q_1])% qset_read_output_file_tagged tree

</pre>

<p>
Now run the program using <tt>qrun</tt> as before (Qdaemon messages removed):

<pre>
(dump: qcsh[q_1])% qrun dump.out
The address of i is 105d and its length is 5 blocks

</pre>
Now I can dump to the NTF using <tt>qread</tt>. This command takes the 
base memory address and the number of blocks as two hexadecimal numbers
respectively (without the leading 0x in terms of notation). I dump the 
array with the command (of course you may find a different base 
address to 105d in which case you have to substitute that in what
follows) :

<pre>
(dump: qcsh[q_1])% qread 105d 5

</pre>
to which the machine responds:

<pre>
Qdaemon state is:
        qdaemon task is READ
        qdaemon abort no and resume no
        QCDSP synchronous
        All nodes selected with SCSI tree coordinates

Qdaemon:  Parameters for read from QCDSP:
        Read address:           0x105d
        Read blocksize:         0x5
        Filename:               foo.tree
        File access:            write
        File format:            node tagged tree


Qdaemon state is:
        qdaemon task is READ
        qdaemon abort no and resume no
        QCDSP synchronous
        All nodes selected with SCSI tree coordinates

</pre>
and the file <tt>foo.tree</tt> magically appears in the directory.

<p>
We can actually look at the <b>foo.tree</b> file. My one looks like:
<font size="-1">

<pre>
2
0
0
5
105d
0
1000000
1400000
2000000
2200000
0
0
1
5
105d
0
1000000
1400000
2000000
2200000
0
.
.
.
0
3f
5
105d
0
1000000
1400000
2000000
2200000
0

</pre>
</font>

<p>
You can clearly see the structure here. The first number in the file
is the magic number 2. The next two are the node tag for the tree
coordinates.  These are motherboard and daughterboard identifiers (the
last daughterboard identifier is 3f which is hex for 63.  This is
because I am using only a 64 PE single motherboard machine).  After
this you have the number of blocks - 5 - followed by the base
address 105d. You have 5 lines of data. They are the hex
representations of the bit pattern that makes up our 5 floating point
numbers. Finally you have a 0 as an end of record marker.

<p>
 <h2><a name="tth_sEc5.5">
5.5</a>&nbsp;&nbsp;Loading data with qload</h2>

<h3>Poking individual words with qload</h3>
The command <tt>qload</tt> allows you to either load node tagged files or to place
individual words into memory. Like qread it also has a number of options
you can set. In this subsection we discuss first how to place individual 
words in memory (ever hear of the POKE keyword in BASIC? This is kind of
the same stuff).

<p>
The incantation to load a word into a particular location in memory is
of the format 

<pre>
qload &lt;address&#62; &lt;data&#62;

</pre>
where both the address and the data are hexadecimal values. For example
to load the value 5 into the memories of all the processors at address
04EFFF I would type a magic incantation like:

<pre>
(qcdhost/homeqs0/bj/QCDSP/IO/load: qcsh[q_1])% qload 04EFFF 5

</pre>

<p>
To that this has worked consider the following program:
<font size="-3">

<pre>







int main( int argc, char *argv[] )
{
  // -----------------------------------------------
  // qload will put (poke?) the distributed memory
  // into the data. User passes in the address the
  // data has been load to through command line
  // arguments
  // -----------------------------------------------
  int *loaded_ints;
  int nblocks;

  // -----------------------------------------------
  // Check command line arguments
  // -----------------------------------------------
  if( argc != 3) {
    printf("Usage: qrun load.out &lt;base address(in hex)&#62; &lt;no of blocks(in hex)&#62;\n
");
    return(EXIT_FAILURE);
  }

  // -------------------------------------------------------------
  // Convert HEX base address string into an integer pointer value
  // and point loaded_ints there
  // -------------------------------------------------------------
  loaded_ints = (int *)strtol(argv[1],  (char **)NULL, 16);

  // -------------------------------------------------------------
  // Convert no_of_blocks string into an integer value
  // -------------------------------------------------------------
  nblocks = (int)strtol(argv[2], (char **)NULL, 16);

  // -------------------------------------------------------------
  // Confirm values to the user
  // -------------------------------------------------------------
  printf("%x (%d) blocks of data at %x\n", nblocks, nblocks,
         (unsigned int)loaded_ints);

  // -------------------------------------------------------------
  // Print back the data
  // -------------------------------------------------------------
  for(int i = 0; i &lt; nblocks; i++) {
    printf("%d ",loaded_ints[i]);
  }
  printf("\n");

  return(EXIT_SUCCESS);
}

</pre>
</font>

<p>
This program basically checks your <tt>qload</tt>.You need to  pass it the base
address to where you have loaded your data as well as the number of blocks 
comprising the data. These are passed on to the program as strings
in the <tt>argv</tt> array, so first we have to convert them to addresses.
This is done using the <tt>strtol</tt> function call which converts a 
string to a long integer.

<p>
The number 16 in the third argument tells <tt>strtol</tt><a href="#tthFtNtAAJ" name="tthFrefAAJ"><sup>9</sup></a> that the string is supposed to
represent a hexadecimal number. We set a pointer <tt>loaded_ints</tt> to
the results of the string conversion, in other words to our base
address.

<p>
We then also need to convert the number of blocks to an integer. This is
done by the second call to <tt>strtol</tt>. 

<p>
After confirming to the user that the input values have been read correctly,
the code proceeds to list the specified number of words from the base 
address, treating them as integers and prints them to the screen.

<p>
Compile up this little program. You should also find it already written
on the QCDSP in the directory <tt>&lt;QOS_VERS&#62;/examples/ParIO/load</tt> with
a suitable default Makefile (Replace this with wherever we put it...)
Now lets have a look in the map file (in my case its called <tt>load.map</tt>):
<font size="-3">

<pre>
                Output Sections

Section List for Module *unnamed* in file
"/homeqs0/bj/QCDSP/intro/IO/load/load.outtof"

Number  Physical   Start   Length  Kind         Access  Name
  1                  1000     110C data                 ".bss"
  2                  210C      102 constant             ".data"
  3                  220E      26F code                 ".text"
  4                     0        0 debug                "debug_directives"
  5                     0        0 debugstring          "debug_strings"
  6                     0        0 line number          "debug_source_location"

</pre>
</font>
This tells me that it is safe for me to load things above the address 220E+26F = 247D. However it is good practice to load things high in the memory so I will
load the data to 05FFE0. I do this by typing

<pre>
(qcdhost/homeqs0/bj/QCDSP/intro/IO/load: qcsh[q_1])% qload 05FFE0 5

</pre>
Now I run my program 

<pre>
(qcdhost/homeqs0/bj/QCDSP/intro/IO/load: qcsh[q_1])% qrun load.out 05FFE0 1

</pre>
The computer replies

<pre>
1 (1) blocks of data at 5ffe0
5 

</pre>
on all the processors.

<p>

<h3>Loading NTFs using qload</h3>
The qload command can also be used to load NTFs. Since all the information
about the data is in the NFT (processor coordinates, base addresses, number of blocks and the actual data) is present in the NTF file. There is no need
to specify these. The command is simply

<pre>
qload &lt;filename&#62;

</pre>
The command can identify the tag type used in the file from the magic number.

<p>
Consider the little program above but now converted to dump floats instead 
of ints:
<font size="-3">

<pre>







int main( int argc, char *argv[] )
{
  // -----------------------------------------------
  // qload will put (poke?) the distributed memory
  // into the data. User passes in the address the
  // data has been load to through command line
  // arguments
  // -----------------------------------------------
  float *loaded_floats;
  int nblocks;

  // -----------------------------------------------
  // Check command line arguments
  // -----------------------------------------------
  if( argc != 3) {
    printf("Usage: qrun load.out &lt;base address(in hex)&#62; &lt;no of blocks(in hex)&#62;\n
");
    return(EXIT_FAILURE);
  }

  // -------------------------------------------------------------
  // Convert HEX base address string into an integer pointer value
  // and point loaded_ints there
  // -------------------------------------------------------------
  loaded_float = (float *)strtol(argv[1],  (char **)NULL, 16);

  // -------------------------------------------------------------
  // Convert no_of_blocks string into an integer value
  // -------------------------------------------------------------
  nblocks = (int)strtol(argv[2], (char **)NULL, 16);

  // -------------------------------------------------------------
  // Confirm values to the user
  // -------------------------------------------------------------
  printf("%x (%d) blocks of data at %x\n", nblocks, nblocks,
         (unsigned int)loaded_ints);

  // -------------------------------------------------------------
  // Print back the data
  // -------------------------------------------------------------
  for(int i = 0; i &lt; nblocks; i++) {
    printf("%f ",loaded_floats[i]);
  }
  printf("\n");

  return(EXIT_SUCCESS);
}

</pre>
</font>

<p>
We can use this to load our floating point NFT (<tt>foo.tree</tt>) that 
we created before, but first another word about memory.

<p>

<h3>Manual Data Relocation</h3>
Usually it will be the case, that a program loads an NTF at the start
to a memory location, then processes it and then dumps it at the end.
In this case the address in the node tag file is fine both for reading 
and dumping. However we are now at an advanced stage, where one program
produced the NTF but another program wants to load it.

<p>
 In the program that made the NFT, the data was in a standard
statically defined array that started (in my case) at address
105d. Now however, we want to load it into a different program.  After
converting the dump program to deal with floats, a quick look at the
map file tells me that memory is still free from above 247D - this is
a consequence of the fact that the <tt>int</tt> on the DSP is the same
size as the <tt>float</tt>. It is desirable to load the data to a high address,
say 05e000. This can be achieved by editing the NTF and replacing 105d
everywhere with 05e000. In my case the it is simply a question of a global
edit. This is one of the advantages of the NTF being in ASCII format.

<p>

<h3>Example of loading an NTF</h3>
So, edit the previous program to deal with floats as I have done above.
Edit your file <tt>tree.foo</tt> replacing the base addresses everywhere with
05e0000. Load the NTF using the command

<pre> 
(qcdhost/homeqs0/bj/QCDSP/intro/IO/load: qcsh[q_1])% qload foo.tree

</pre>
and run the program, it should probably be called <tt>load.out</tt>:

<pre>
(qcdhost/homeqs0/bj/QCDSP/intro/IO/load: qcsh[q_1])% qrun load.out 05e000 5

</pre>
The computer should reply:

<pre>
5 (5) blocks of data at 5e000
1.000000 2.000000 3.000000 4.000000 5.000000 

</pre>
on all the processors.

<p>

<h3>Setting up qload options</h3>
You should now be able to use <tt>qload</tt> to load parallel data. However
just like the case of <tt>qread</tt> there are some options that you can
set. These allow you to specify the filename to <tt>qload</tt> or simply 
just the address and value to <tt>qload</tt> (for poking single data). Then 
you can use <tt>qload</tt> with no arguments at all. The commands to set 
the options are

<dl compact="compact">
	<dd> <tt>qset_load_select</tt> : &nbsp; Specifies whether <tt>qload</tt> should
read from a file or from the screen. The command can have up to 1 argument
whose value is either <tt>file</tt> or <tt>screen</tt> (alternatively <tt>f</tt> or
<tt>s</tt> respectively). If no arguments are given, the current value of
the option is shown. I generally found that this option reset itself to 
file every time <tt>qload</tt> is invoked with an explicit filename.</dd>

	<dd> <tt>qset_load_screen</tt> : &nbsp; Specifies an address and a data 
item. This option sets things up so that a subsequent call to <tt>qload</tt> 
will load the specified data to the specified address. The command can 
have either  two arguments or none. Invoking the command with no arguments
causes it to print the current values for the address and the data value.
When the command is invoked with two arguments, the meaning of the arguments
are

<dl compact="compact">
	<dd><tt>address &nbsp;</tt> specifies the address to load to.</dd>

	<dd><tt>data value &nbsp;</tt> specifies the value of the data to be loaded.</dd>
</dl>
Notes:

<ul>
<li> The following are equivalent: <tt>qload &lt;address&#62; &lt;value&#62;</tt> and <tt>qset_load_select s ; qset_load_screen &lt;address&#62; &lt;value&#62; ; qload</tt>.</li>

<li>
If one selects to load from the screen, and sets the address and value and
then invokes <tt>qload &lt;filename&#62;</tt>, then <tt>qload</tt> will switch to 
reading from the file instead. If one has set a filename to load from 
using <tt>qset_load_filename</tt> and has switched <tt>qload</tt> to read from 
file using <tt>qset_load_filename file</tt>, if one now executes <tt>qload &lt;address&#62; &lt;value&#62;</tt> then <tt>qload</tt> will switch to screen mode and the last option
will be valid.</li>
</ul></dd>

	<dd><tt>qset_load_filename : </tt> This command sets the name of the file
that qload will use to load data from. It can have either one or no arguments.
If the command is invoked with no arguments it will echo the current value
of the filename. If invoked with one argument the argument, the argument
should be the name of the file to load from.
Note: The following are equivalent: <tt>qload &lt;file&#62;</tt> and <tt>qset_load_select file ; qset_load_filename &lt;file&#62; ; qload </tt>.</dd>
</dl>

<p>
 <h2><a name="tth_sEc5.6">
5.6</a>&nbsp;&nbsp;Digression for Lattice Folk</h2>
There are two specialised commands to load and unload lattice gauge fields to
and from the QCDSP. These are, as mentioned previously <tt>qload_lattice</tt>
and <tt>qunload_lattice</tt>. Before describing these I should say a few 
words about the lattice file format.

<p>

<h3>Gauge Connection Format</h3>
Currently NERSC provides an archive area called the <tt>Gauge Connection</tt>.
They use a particular format for lattices there. This format consists
of a header section and a data section. The header section consists of
a whole lot of fields. This is useful for keeping track of where the 
lattices came from. The header file also keeps information about the
average plaquette to assist in validation.

<p>
The command <tt>qload_lattice</tt> simply takes a configuration in the NERSC
archive and loads it into memory at a user supplied starting address.
For example, prior to running a certain piece of code. I have obtained
(actually output from another program) a lattice called <tt>lattice.ieee.full </tt>. The <tt>.ieee</tt> part of the naming convention indicates that the floating point format of the lattice is IEEE 32Bit big-endian. The <tt>.full</tt> part indicates that all the link matrices are stored in full (as opposed to compressed 2 row
format).

<p>
I would like to load this lattice prior to computation. It has a volume
of 8<sup>4</sup> sites, which is to be distributed over 64 processors. My processor
grid is a 4 &times;2 &times;2 &times;4 lattice (the order of the dimensions
in this case is <i>X</i> &times;<i>Y</i> &times;<i>Z</i> &times;<i>T</i>. This implies that the local 
lattice size per processor is 2 &times;4 &times;4 &times;2 = 64 sites. On
each site there are 4 link matrices each of these being a full SU(3) matrix
consisting of 9 complex numbers which are represented as 18 real numbers.
Hence the size of the local data is 64 &times;4 &times;18 = 4608 numbers
and since each number is word sized this means that the data requires 
4608 words of storage which in hexadecimal is 1200. Thus the highest I can
load this data in memory is to address 060000 - 001200 = 5ee00. To be 
a little conservative I choose to load it to 5ed00.

<p>
The instruction I give to the QCDSP is:

<pre>
(qcdhost/homeqs0/bj/QCDSP/sfw/hello_world: qcsh[q_1])% qload_lattice 5ed00 lattice.ieee.full

</pre>
Apart from the usual qdaemon messges, the response of the computer was 
as follows:
<font size="-3">

<pre>
DoLoadLattice:  a copy of the header from lattice.ieee.full
        BEGIN_HEADER
        CHECKSUM =  1649a43
        LINK_TRACE = +0.0020214
        PLAQUETTE = +0.5132502
        DATATYPE = 4D_SU3_GAUGE_3x3
        HDR_VERSION = 1.0
        STORAGE_FORMAT = 1.0
        DIMENSION_1 = 8
        DIMENSION_2 = 8
        DIMENSION_3 = 8
        DIMENSION_4 = 8
        BOUNDARY_1 = PERIODIC
        BOUNDARY_2 = PERIODIC
        BOUNDARY_3 = PERIODIC
        BOUNDARY_4 = ANTIPERIODIC
        ENSEMBLE_ID = BALINT_LAT_1
        ENSEMBLE_LABEL = Balint's first test lattice 8x8x8x8 pure gauge beta=6.0
        SEQUENCE_NUMBER = 100
        CREATOR = Columbia
        CREATOR_HARDWARE = QCDSP 
        CREATION_DATE = Fri Apr 28 15:50:26 2000
        ARCHIVE_DATE = Fri Apr 28 15:50:26 2000
        FLOATING_POINT = IEEE32BIG
        END_HEADER

DoLoadLattice:  keywords used to load lattice
        CHECKSUM = 1649a43
        LINK_TRACE = 0.0020214
        PLAQUETTE = 0.5132502
        DATATYPE = 4D_SU3_GAUGE_3x3
        DIMENSION_1 = 8
        DIMENSION_2 = 8
        DIMENSION_3 = 8
        DIMENSION_4 = 8
        FLOATING_POINT = IEEE32BIG

DoLoadLattice:
        Loading 4608 words per node to address 0x5ed00
        Total transfer of 294912 words to 64 nodes of QCDSP
        Starting to read 294912 words from host disk
        Finished loading 1/4 of lattice to QCDSP
        Finished loading 2/4 of lattice to QCDSP
        Finished loading 3/4 of lattice to QCDSP
        Finished loading 4/4 of lattice to QCDSP
        Converting from IEEE32BIG to TIDSP32 on QCDSP
DoLoadLattice:
        Loading plaq.qin to calculate plaq and trace on QCDSP

Output from plaq.qin running on QCDSP
        Machine size (X,Y,Z,T) (4,2,2,4)
        Lattice size per node (2,4,4,2)
        Total lattice size (8,8,8,8)
        Lattice address 0x5ed00

        plaq            0.5132502
        link trace      0.0020214

MkerExecAck:  starting to check program exit status
AnalyzeQCDSP::SCUCheck:  SCUDebug mode 0 doesn't allow analysis
MkerExecAck:  SCUCheck could not be run

DoLoadLattice:
        Plaquette from header and QCDSP (0.5132502) agree to 0.000001
        Link trace from header and QCDSP (0.0020214) agree to 0.000001
        Checksum from header and QCDSP agree (0x1649a43)

</pre></font>
The messages are quite self explanatory. First qload lattice echoed back
the contents of the header file. Then it loaded the lattice, partitioned
it amongst the processors. Thereafter it converted from IEEE 32Bit big
endian format to the DSPs internal format denoted TIDSP32. A separate
program was then run to calculate the plaquette and the average link trace
to validate the data. Finally QCDSP responded indicating that the
lattice has been loaded, that the plaquette and link trace have been
found to be correct to 4dp and that the checksum test has been passed.

<p>
At this point one can start one's computation. To be able to use the
lattice in the Columbia Physics System, one has to set the members of a global
instance of a <tt>GlobalJobParameter</tt> class (it is required to have
one of these called GJP declared globally).  One has to set the
private <tt>start_conf_kind</tt> member of the <tt>
GlobalJobParameter</tt> class to have value <tt>START_CONF_LOAD</tt>, and
one has to set the private <tt>start_conf_load_addr</tt> pointer to
point in memory to first word of the loaded lattice.

<p>
Currently this can only be done through the public <tt>Initialize</tt> member 
function of the <tt>GlobalJobParameter</tt> class. This function takes as 
an argument a reference to a <tt>DoArg</tt> class. The <tt>DoArg</tt> class
has public member variables <tt>start_conf_kind</tt> and <tt>start_conf_load_addr</tt>. The former of these has to be set to <tt>START_CONF_LOAD</tt> 
and the latter to the address of the first word of the loaded data.

<p>
The address can be passed to the program as a command line argument, 
making it available to each processor, or it could be read by node 0
using the usual C style file I/O and then broadcast to the rest of the
system. An example snippet of code to set up the lattice may look something
like as follows:
<font size="-3">

<pre>
// ------------------------ 
// Standard headers
// ------------------------






// ------------------------
// QCDSP Non Physics Includes
// ------------------------





// ------------------------
// QCDSP Physics Includes
// ------------------------









// ------------------------
// These are always defined Globally
// -------------------------
GlobalJobParameter GJP;
Verbose            VRB;
Error              ERR;

// -----------------------------------
// PE 0 is boss
// -----------------------------------
#define BOSS_ID  0

main(int argc, char *argv[]) 
{
  // ----------------------------
  // Check Arguments 
  // Can call with either no arguments (ordered start) =&#62; argc = 1
  // Or with  one argument, being hex address of gauge field 
  // ----------------------------
  if ( argc &#62; 2  ) {
    printf("Usage: qrun prog.out [hex address (no leading 0x)]\n");
    exit(EXIT_FAILURE);
  }

  // ----------------------------
  // Initialize the Global Job Params
  // -----------------------------
  DoArg do_arg;

  int my_id = UniqueID();


  // --------------------------------
  // Global lattice      X  Y  Z  T 
  // --------------------------------
  int g_latt_size[4] = { 8, 8, 8, 8 };
  // --------------------------------
  //  Local lattice      X  Y  Z  T 
  // ---------------------------------

  int l_latt_size[4] = { 2, 4, 4, 2 };

  printf("Local Lattice Size is: %d %d %d %d\n", 
	 l_latt_size[0],l_latt_size[1],l_latt_size[2], l_latt_size[3]);
  

  // -----------------
  // Use Whole Machine
  // -----------------
  do_arg.x_nodes = SizeX();
  do_arg.y_nodes = SizeY();
  do_arg.z_nodes = SizeZ();
  do_arg.t_nodes = SizeT();

  // ----------------------------
  // We are in 4D by I set the 5th dimension anyway
  // ----------------------------
  do_arg.s_nodes = 1;

  // -----------------
  // Set the lattice volume -- Sites per node
  // -----------------
  do_arg.x_node_sites = l_latt_size[0];
  do_arg.y_node_sites = l_latt_size[1];
  do_arg.z_node_sites = l_latt_size[2];
  do_arg.t_node_sites = l_latt_size[3];
  do_arg.s_node_sites = 1;

  // -----------------
  // Set Boundary Conditions
  // -----------------
  do_arg.x_bc = BND_CND_PRD;  // Periodic
  do_arg.y_bc = BND_CND_PRD;  // Periodic
  do_arg.z_bc = BND_CND_PRD;  // Periodic
  do_arg.t_bc = BND_CND_APRD; // Antiperiodic

  // ----------------
  // Set lattice start depending on no of arguments
  // ----------------
  if( argc  == 1 ) {         // No user supplied arguments
     do_arg.start_conf_kind = START_CONF_ORD;
  }
  else {  // User supplied load address
     
     do_arg.start_conf_kind = START_CONF_LOAD;

     // -------------------------------------
     // Hex String to address convertion
     // -------------------------------------
     do_arg.start_conf_load_addr = (Matrix *)strtol(argv[1],(char **)NULL, 16);
  }
  do_arg.start_seed_kind = START_SEED_FIXED;
  do_arg.verbose_level = VERBOSE_RESULT_LEVEL + 1;

  // ---------------------------------------
  // Quenched QCD -- 3 colours, beta = 6
  // --------------------------------------- 
  do_arg.colors = 3;
  do_arg.beta = 6.0;

  // ------------------------
  // Initialise GJP Structure
  // ------------------------

  GJP.Initialize(do_arg);
  
  // -----------------------
  // Set verbosity
  // -----------------------

  VRB.Level(VERBOSE_RESULT_LEVEL+1);

  // ---------------------------
  // Grab a Wilson Gauge Lattice. with possibly wilson fermions in future
  // This gets initialised from GJP
  // ---------------------------

  GwilsonFwilson lat;

  // --------------------------
  // Calculate The Global Trace of the plaquette
  // --------------------------

  Float t;
  Float normal; // Plaquette normalization factor

  normal = g_latt_size[0]*g_latt_size[1]*g_latt_size[2]*g_latt_size[3];
  normal *= 6 * 3; // No of planes * 3 to normalize unit gauge to 1
  t=lat.SumReTrPlaq()/normal;

  // Print Plaquette
  if( my_id == BOSS_ID ) {
    printf("Boss: Startup Gauge Field    --  Sum Tr Plaq = %f\n",(float)t);
  }

  // ---------------------------------------------
  // Do your world beating calculation below
  // ---------------------------------------------


  // ---------------------------------------------
  // Your world beating calculation ends
  // You want to store gauge field perhaps
  // --------------------------------------------- 
  // --------------------------------------------- 
  // Print Gauge Field -- for saving
  // ---------------------------------------------
  printf("Local Gauge field starts at %x\n",(int)lat.GaugeField());
  exit(EXIT_SUCCESS);
}

</pre>
</font>

<p>
Running this program with no arguments produced the following output

<pre>
ocal Lattice Size is: 2 4 4 2
Boss: Startup Gauge Field    --  Sum Tr Plaq = 1.000000
Local Gauge field starts at 137c8

</pre>
which is the correct output a unit gauge.
I could recover the gauge field by using <tt>qunload_lattice</tt>
as I have printed out the address of the start of the gauge field data.

<p>
Now I load the gauge field as before (I have decided to omit the output
from <tt>qload_lattice</tt> as I have already included it in full earlier.
I then run the program giving the starting address (5ED00) as my 
first argument. I get the following reply from the QCDSP:

<pre>
Local Lattice Size is: 2 4 4 2
Boss: Startup Gauge Field    --  Sum Tr Plaq = 0.513250
Local Gauge field starts at 5ed00

</pre>
Indicating that I managed to initialize the lattice correctly.

<p>

<h3>Unloading Gauges</h3><a name="s:GaugeUnload">
</a>
Now we can try to unload the gauge and keep it. A few things need to be 
borne in mind. It is a local convention, that gauge fields in use here
at Columbia be kept in the DSP native representation (<tt>TIDSP32</tt>) whereas
fields that are to be shipped off to the gauge connection should really be
in the IEEE big-endian format (<tt>IEEE32BIG</tt>).

<p>
Also, gauge fields can be kept in compressed format (2 of the 3 rows stored
 only) for each SU(3) matrix or in full format.

<p>
While the <tt>qload_lattice</tt> command can learn all this from the header 
part of the gauge field configuration file, and the user program 
has knows about the lattice through the <tt>GlobalJobParameter</tt> structure,
the <tt>qunload_lattice</tt> command, running on the front end, knows nothing
about our lattice and has to be told via a parameter file.

<p>
The parameter file essentially provides the header information part of the
gauge configuration data file. It consists of an ordered list of entries, 
which we shall describe below. Each entry lives on a single line of the file.
Lines containing no text are ignored. Lines starting with a <tt>#</tt> character
are treated as comments and ignored. The <tt>#</tt> character does not 
need to be in the first column of the line. However it may not follow
an entry. There are therefore no trailing comments. There should be 
no trailing spaces following entries. <b>The order of entries is important.</b>

<p>
The entries of the file, in order are

<dl compact="compact">
	<dd><b>T Size &nbsp;</b> - this is a single integer giving the global lattice size in the T (Euclidean Time direction)</dd>

	<dd><b>X Size &nbsp;</b> - this is a single integer giving the global lattice size in the X direction</dd>

	<dd><b>Y Size &nbsp;</b> - this is a single integer giving the global lattice size in the Y direction</dd>

	<dd><b>Z Size &nbsp;</b> - this is a single integer giving the global lattice size in the Z direction</dd>

	<dd><b>Boundary condition for T &nbsp;</b> - This entry specifies the boundary condition for the T direction. The boundary conditions can be either periodic or
antiperiodic. This entry can take the values <tt>PERIODIC</tt> or <tt>ANTIPERIODIC</tt> respectively.</dd>

	<dd><b>Boundary condition for X &nbsp;</b> - This entry specifies the boundary condition in the X direction.  The entry can take the values <tt>PERIODIC</tt> or <tt>ANTIPERIODIC</tt>.</dd>

	<dd><b>Boundary contidion for Y &nbsp;</b> - This entry specifies the boundary condition in the Y direction.  The entry can take the values <tt>PERIODIC</tt> or <tt>ANTIPERIODIC</tt>.</dd>

	<dd><b>Boundary contidion for Z &nbsp;</b>  - This entry specifies the boundary condition in the Z direction.  The entry can take the values <tt>PERIODIC</tt> or <tt>ANTIPERIODIC</tt></dd>

	<dd><b>Lattice Base Address &nbsp;</b> - The address in memory where the data
for the lattice starts on each processor. Can be found using the <tt>GaugeField()</tt> member function of the <tt>lattice</tt> base class in the Physics system. The number should be entered in hexadecimal without any preceeding 0x.</dd>

	<dd><b>Lattice Output Filename &nbsp;</b> - The filename where the lattice
configuration is to be dumped. Be aware of the the file name suffix convention.

<dl compact="compact">
	<dd> <tt>.dsp.full &nbsp;</tt> Gauge field is stored  in DSP internal floating point representation. All three rows of the link matrices are stored in the file.</dd>

	<dd> <tt>.dsp  &nbsp;</tt> Gauge field  is stored in DSP internal floating point representation. The link matrices are stored in compressed 2 row format. The third row is removed.</dd>

	<dd> <tt>.ieee.full &nbsp;</tt> Gauge field is stored in IEEE 32Bit Big Endian representation. All three rows of the link matrices are stored.</dd>

	<dd> <tt>.ieee &nbsp;</tt> Gauge fields are stored in IEEE 32Bit Big Endian format. The link matrices are stored in compressed 2 row format. The third row is removed.</dd>
</dl></dd>

	<dd><b>Ensemble ID &nbsp;</b> - This is some label uniquely identifying the simulation. It can be any string. On the Gauge Connection, this label is displayed
when your ensemble is listed. By convention configurations from Columbia 
have ensemble ID's of the form <tt>CU_XXXX </tt> where <tt>CU</tt> identifies
Columbia University (MILC have <tt>MILC</tt> and Ohio State University use 
<tt>OSU</tt>) and <tt>XXXX</tt> is a unique number identifying the ensemble from 
which the gauge is from.</dd>

	<dd><b>Ensemble Label &nbsp;</b> - This should be a more human readable label
giving some details about the ensemble such as the parameters that
were used to generate it. This entry takes a string value.</dd>

	<dd><b>Sequence Number &nbsp;</b> - This is an integer value identifying 
the configuration in a given ensemble (for example an HMC trajectory number,
or a Heat bath sweep number).</dd>

	<dd><b>Creator String &nbsp;</b> - A string describing the group responsible
for the generation of the gauge configuration. Columbia uses <tt>Columbia</tt>.</dd>

	<dd><b>Creator Hardware &nbsp;</b> - The machine used to create the lattices.
If the configurations were generated by QCDSP, this field should either be
<tt>CU-QCDSP</tt> for Columbia or <tt>RBRC-QCDSP</tt> for the RIKEN-Brookhaven
machine.</dd>

	<dd><b>Datatype &nbsp;</b> - An entry to describe how to save the configuration.
This can take one of the following values

<dl compact="compact">
	<dd><tt>4D_SU3_GAUGE &nbsp;</tt> Gauge field is to be saved in compressed 2 row
format.</dd>

	<dd><tt>4D_SU3_GAUGE_3x3 &nbsp;</tt> Gauge field is to be saved in full 3 row format.</dd>
</dl></dd>

	<dd><b>Floating point type &nbsp;</b> - Specifies whether the gauge should be
saved in DSP native format or in IEEE format.This can take values:

<dl compact="compact">
	<dd><tt>TIDSP32 &nbsp;</tt> Gauge configuration to be saved in Texas Instruments
DSP 32bit format.</dd>

	<dd><tt>IEEE32BIG &nbsp;</tt> Gauge configuration is to be saved in 32 bit IEEE
Big Endian format.</dd>
</dl></dd>

	<dd><b>Creation Date &nbsp;</b> - A character string specifying the date of 
creation. It entry has the value <tt>now</tt> it will be timestamped automatically
when <tt>qunload_gauge</tt> is invoked.</dd>
</dl>

<p>
For example to dump the gauge we have just loaded in the previous section
I would need the following file: 

<pre>
# size in T
8

# size in X
8

# size in Y
8

# size in Z
8

# boundary condition for T
ANTIPERIODIC

# boundary conditionf for X
PERIODIC

# boundary condition for Y
PERIODIC

# boundary condition for Z
PERIODIC

# lattice base address
05ed00

# lattice output file
lattice.ieee.full

# Ensemble ID
BALINT_LAT_1

# Ensemble label
Balint's first test lattice 8x8x8x8 pure gauge beta=6.0

# Sequence number 
100

# Creator string 
Columbia

# Creator Hardware 
QCDSP 

# Datatype 
4D_SU3_GAUGE_3x3

# Floating point type
IEEE32BIG

# Creation Date 
now

</pre>

<p>
Before you can use <tt>qunload_lattice</tt> to unload a configuration
you must tell it about the lattice. If you have created a file such as
above you can tell <tt>qunload_lattice</tt> to use it as a desctiption file
with the QC-Shell command:

<pre>
qset_unload_lattice f &lt;file&#62;

</pre>
where <tt>&lt;file&#62;</tt> is the name of your description file.

<p>
Alternatively you can enter all the fields manually from the command 
line by typing:

<pre>
qset_unload_lattice m

</pre>
and enter answers to the various prompts.

<p>
There is a default mode for <tt>qunload_lattice</tt> which you 
can set with the command:

<pre>
qset_unload_lattice d

</pre>
The default settings however refer to a lattice of 2<sup>4</sup> sites with 
periodic boundaries in each direction. Hence the default mode is probably
not very useful.

<p>
Once you have executed one of the <tt>qset_unload_lattice</tt> commands
and have got no error messages, you are ready to unload the lattice.
It is a simple matter of typing 

<pre>
qunload\_lattice

</pre>

<p>
For example, I now try to unload the unit gauge lattice I can produce
by running my gauge reading program with no arguments.  I use the example 
lattice description I have listed above except I've changed the output filename
to <tt>unit_gauge_8888.ieee.full</tt>.  The description is in a file I call <tt>
qunload.in</tt>.

<p>
I first run the program without arguments to produce the unit gauge

<pre>
(qcdhost/homeqs0/bj/QCDSP/sfw/hello_world: qcsh[q_1])% qrun simple_test.out 

</pre>
I get the response

<pre>
Local Lattice Size is: 2 4 4 2
Boss: Startup Gauge Field    --  Sum Tr Plaq = 1.000000
Local Gauge field starts at 137c8

</pre>

<p>
I edit my description file <tt>qunload.in</tt> to change the base address to 137C8.
I execute the commands: <font size="-3">

<pre>
(qcdhost/homeqs0/bj/QCDSP/sfw/hello_world: qcsh[q_1])% qset_unload_lattice f qunload.in
(qcdhost/homeqs0/bj/QCDSP/sfw/hello_world: qcsh[q_1])% qunload_lattice

</pre></font>
To which the QCDSP replies:
<font size="-3">

<pre>
DoUnloadLattice:
        Unloading 4608 words per node from address 0x137c8
        Total transfer of 294912 words from 64 nodes of QCDSP
        Starting to write out 294912 words to host disk
        Finished writing out 1/4 of lattice
        Finished writing out 2/4 of lattice
        Finished writing out 3/4 of lattice
        Finished writing out 4/4 of lattice
        Loading plaq.qin to calculate plaq and trace on QCDSP

Output from plaq.qin running on QCDSP
        Machine size (X,Y,Z,T) (4,2,2,4)
        Lattice size per node (2,4,4,2)
        Total lattice size (8,8,8,8)
        Lattice address 0x137c8

        plaq            1.0000000
        link trace      1.0000000

MkerExecAck:  starting to check program exit status
AnalyzeQCDSP::SCUCheck:  SCUDebug mode 0 doesn't allow analysis
MkerExecAck:  SCUCheck could not be run

DoUnloadLattice:
        copy of header written to lattice.ieee.full

        BEGIN_HEADER
        CHECKSUM =        0
        LINK_TRACE = +1.0000000
        PLAQUETTE = +1.0000000
        DATATYPE = 4D_SU3_GAUGE_3x3
        HDR_VERSION = 1.0
        STORAGE_FORMAT = 1.0
        DIMENSION_1 = 8
        DIMENSION_2 = 8
        DIMENSION_3 = 8
        DIMENSION_4 = 8
        BOUNDARY_1 = PERIODIC
        BOUNDARY_2 = PERIODIC
        BOUNDARY_3 = PERIODIC
        BOUNDARY_4 = ANTIPERIODIC
        ENSEMBLE_ID = BALINT_LAT_1
        ENSEMBLE_LABEL = Balint's first test lattice 8x8x8x8 pure gauge beta=6.0
        SEQUENCE_NUMBER = 100
        CREATOR = Columbia
        CREATOR_HARDWARE = QCDSP 
        CREATION_DATE = Fri Apr 28 18:29:07 2000
        ARCHIVE_DATE = Fri Apr 28 18:29:07 2000
        FLOATING_POINT = IEEE32BIG
        END_HEADER

</pre>
</font>

<p>
 <h2><a name="tth_sEc5.7">
5.7</a>&nbsp;&nbsp;Serial I/O</h2>
We have spent some time dealing with parallel I/O. It should of course
be obvious, that since saving and loading of parallel data is not done
from the user program, that the user program must stop its computation
when parallel IO needs to be performed. This leads to the model of running
Monte Carlo simulations where observables are computed on the fly rather
than the one where one just produces configurations, archives them 
and measures observables later, although this latter model could be 
uses if driven by a shell script say.

<p>
Naturally after computing observables on the fly the user would wish to 
store them in a file on the front end. Generally (except for propagators
and things) observables tend to be small objects that can fit into the 
memory of a single node. 

<p>
The QCDSP provides the standard C file access mechanism for reading and 
writing to files. <tt>The C++ iostream class is not implemented.</tt>
Hence one can use <tt>fprintf</tt> and <tt>fscanf</tt> to read from a file
and <tt>printf</tt> and <tt>scanf</tt> to read from a terminal. (Bob are the 
binary file functions <tt>fread</tt> and <tt>fwrite</tt> implemented?)

<p>
There are however several things that the user has to be aware of:

<ul>
<li>There is no concept of <tt>stdin</tt>, <tt>stdout</tt> and <tt>stderr</tt> streams
on the QCDSP (although there is on the front end). These are UNIX concepts.
On the QCDSP one can either write to the screen or to a file.</li>

<li>
The <tt>printf</tt> command will output on all the processors. The output
of processor 0 is sent to the terminal. The output of other processors
is buffered and can be retreived using the <tt>qprintf</tt> command.</li>

<li>
<b>Access to files on the front end is currently available from node 0 
only. If other nodes wish to read or write files. They must arrange for
node 0 to do it and transfer the results.</b></li>

<li>
One can turn off I/O by running a program with the command <tt>qrun_no_io</tt>.
In this case I/O produced by <tt>printf</tt> and <tt>fprintf</tt> commands is lost.</li>
</ul>

<p>
 <h2><a name="tth_sEc5.8">
5.8</a>&nbsp;&nbsp;Summary</h2>
In this section we have discussed the main parallel and serial I/O 
capabilities of the QCDSP. We now summarise some of the chief results
of this chapter.

<p>

<h3>Memory Summary</h3> 
User code should reside between addresses 001000 and 05FFFF. The memory
layout of a compiled and linked code is given by the appropriate map file.
This file also includes the heap area so the highest used address in the 
map file will be the highest address used by the program as there will
be no runtime relocation of symbols, since the linker has already resolved
everything.

<p>

<h3>Parallel I/O General Summary</h3> 
Parallel I/O has to be performed before execution of user programs
or after the completion of user programs. Parallel input involves placing
data directly into the QCDSP node memory above the user code but 
below the operating system. Parallel output proceeds by reading directly
the memory of the nodes after a program has stopped executing. 

<p>
Parallel output can proceed via the <tt>qread</tt> command for NTFs
or via the <tt>qunload_lattice</tt> command for lattice gauge fields.

<p>
Parallel input can proceed via the <tt>qload</tt> command for NFTs
or via the <tt>qload_lattice</tt> command for lattice gauge fields in the
Gauge Connection archive format. 

<p>

<h3>Summary of <tt>qread</tt></h3>
The basic command is <tt>qread &lt;address&#62; &lt;no of blocks&#62;</tt> which will
cause qread to read <tt>&lt;no of blocks&#62;</tt> data words to be read from
each processors memory starting at address <tt>&lt;address&#62;</tt>. Both <tt>
&lt;address&#62;</tt> and <tt>&lt;no of blocks&#62;</tt> are hexadecimal numbers without
any leading 0x.  The behaviour of <tt>qread</tt> can be controlled by the following
QC-Shell Commands

<dl compact="compact">
	<dd><tt>qset_read_output_filename : &nbsp;</tt> Set name of file to dump to.
If no arguments are supplied the command prints the currently set name
of the dump file. If the command is run with one argument it must be
the name of the dump file. Bear in mind that there is a file suffix
convention (see figure <a href="#f:NTFTypeSummary">5.4</a>.</dd>

	<dd><tt>qset_read_output_file_access : &nbsp;</tt> Set the access mode of the
dump file. If called with no arguments the currently set mode is displayed.
If called with one argument the argument must be a valid access more. 
Valid access modes are <tt>w</tt> for write mode and <tt>a</tt> for append mode.</dd>

	<dd><tt>qset_read_output_select : &nbsp;</tt>
Select output to which the dump will be sent. Dump output can be sent to 
the screen or to a file. If called with no arguments the command displays
the current setting. If called with 1 argument, the argument has to be
either <tt>f</tt> or <tt>s</tt> for dumping to a file or screen respectively.</dd>

	<dd><tt>qset_read_output_tagged : &nbsp;</tt>
Select the tagging mode for the dump if output is going to a file (Node Tagged File). Valid tagging modes are 

<dl compact="compact">
	<dd><tt>no</tt> Do not tag nodes.</dd>

	<dd><tt>yes</tt> Use default node tagging mode (tree)</dd>

	<dd><tt>tree</tt> Use tree node tagging mode</dd>

	<dd><tt>p4d</tt> Use physics (re-mappable) 4D coordinate tagging mode.</dd>

	<dd><tt>m4d</tt> Use machine (non-remappable) 4D coordinate tagging mode.</dd>
</dl></dd>
</dl>

<p>

<h3>Summary of <tt>qload</tt></h3>
The <tt>qload</tt> command can be used either to load NTFs or to poke
individual words into memory. It can be invoked in three separate modes

<dl compact="compact">
	<dd><tt>qload &lt;address&#62; &lt;data&#62; &nbsp;</tt> - loads <tt>&lt;data&#62; </tt> to address
<tt>&lt;address&#62;</tt> on all processors. Both <tt>&lt;data&#62;</tt> and <tt>&lt;address&#62;</tt> 
are hexadecimal values without any preceeding 0x in the notation.</dd>

	<dd><tt>qload &lt;file&#62; &nbsp;</tt> - will cause the loading of the NTF <tt>&lt;file&#62;</tt>.
The memory addresses are hardwired into the NTF so manual relocation may 
be necessary.</dd>

	<dd><tt>qload &nbsp;</tt> - will cause <tt>qload</tt> to execute according to the 
behaviour set with previous commands. Commands affecting <tt>qload</tt> are

<dl compact="compact">
	<dd><tt>qset_load_select &nbsp;</tt> Takes 0 or 1  arguments. Selects whether <tt>
qload</tt> operates in screen mode (poking a single data into an address)
or file mode (reading an NFT). When called without an argument, the 
command will print the current selection. The mode will be altered by 
calling <tt>qload</tt> with multiple arguments to load files or data directly.</dd>

	<dd><tt>qset_load_screen &nbsp;</tt> Can be called with 2 or no arguments.
If called with two arguments, argument 1 must be a hexadecimal address
and argument 2 must be a hexadecimal data value. A subsequent call to 
<tt>qload</tt> will load the data value to the address on all processors if
screen mode has been selected with <tt>qset_load_select</tt>, unless
the behaviour of <tt>qload</tt> is altered by some other command.</dd>

	<dd><tt>qset_load_filename &nbsp;</tt> Can be called with 1 or no arguments.
If called with 1 argument, the argument must be a filename. A subsequent
call to <tt>qload</tt> will attempt to load the specified file if <tt>qload</tt>
has been put into file mode using <tt>qset_load_select</tt>, unless the 
behaviour of <tt>qload</tt> has been altered by some other subsequent command.</dd>
</dl></dd>
</dl>
XS

<h3>Node Tag File (NTF) Summary</h3>
Node tag files (NTFs)are ASCII files containing data from all the nodes of the
currently selected set of processors. A given NTF contains a magic number
and a sequence of records, one for each processor. Each record contains
some data to identify its processor, the starting address and the number
of blocks of that processors data followed by the data itself. The record
is terminated by a 0. Each entry in an NTF needs to be on a new line.
All numbers are in hexadecimal. For a summary of Node Tag Files see
figures <a href="#f:NTFStructure">5.2</a>, <a href="#f:NTFRecStructure">5.3</a> and <a href="#f:NTFTypeSummary">5.4</a>.

<p>

<h3>Summary of <tt>qload_lattice</tt></h3>
The command <tt>qload_lattice</tt> takes two arguments. Argument one
is the address on each processor where the first word of lattice data
is to reside. The second argument is the name of a lattice gauge configuration
file in the Gauge Connection archive format. 

<p>
Executing the command will cause <tt>qload_lattice</tt> to distribute the 
lattice amongst the currently selected nodes. Any conversion from 
IEEE floating point representation to DSP representation is done at this time.
Various diagnostic information is also printed to the screen, including the
value of the plaquette and the average of the traces of the gauge field 
link matrices.

<p>

<h3>Summary of <tt>qunload_lattice</tt></h3>
The command <tt>qunload_lattice</tt> takes no arguments. Details of the lattice
have to be made known to it previously using the <tt>qset_unload_lattice</tt> 
command.

<p>
The <tt>qset_unload_lattice</tt> command can take 0, 1 or 2 arguments.
If <tt>qset_unload_lattice</tt> is called with no arguments it will display
its current settings. If called with 1 argument the argument has to be 
either <tt>d</tt> in which case the default settings will be chosen or <tt>m</tt>
in which case the user will be prompted to enter details manually. If called
with 2 arguments the first argument has to be an <tt>f</tt> followed by the name
of a file containing a description of the lattice to be dumped. This file
must be in the format described in section <a href="#s:GaugeUnload">5.6</a>.

<p>

<h3>Gauge Connection Format Summary</h3>
See <tt>http://qcd.nersc.gov</tt>.

<p>

<h3>Serial I/O Summary</h3>
The C Standard I/O file interface is partially implemented. In particular
<tt>printf</tt>, <tt>scanf</tt>, <tt>fprintf</tt>, <tt>fscanf</tt>, <tt>fopen</tt>, <tt>
fclose</tt>, <tt>fread</tt> and <tt>fwrite</tt> are implemented (I am not sure of the
last 2). Apart from <tt>printf</tt> calling these functions only makes sense
from node 0. The <tt>printf</tt> output of processors are saved in a buffer
and can later be recovered using <tt>qprintf</tt> unless the program was run
with <tt>qrun_no_io.</tt> in which case all serial I/O is lost.

<p>

<h3>Miscellany</h3>
In this section we have used rather a lot of the QC-Shell (QOS) built
in commands. It is possibly helpful to know that a brief summary of all 
the QC-Shell commands can be listed using the QC-Shell command <tt>qhelp</tt>.
It is recommended that the output is piped through a pager such as <tt>less</tt>
or <tt>more</tt>.

<p>
 <h1><a name="tth_chAp6">
Chapter 6 </a><br />Compiling, Linking and Libraries</h1>

 <h2><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Overview</h2>
Until now, we have been able to do all our compilation and linking
with the default makefiles. In the last chapter I discussed that
for QCDSP applications we may also need an idea of where free memory
starts (where I mean free in the sense, that runtime dynamic memory 
allocation shall not encroach upon it), so that we can use the 
commands for parallel IO effectively. This information is given by
the linker <em>map</em> file as discussed previously.

<p>
I have mentioned briefly that our control of the stack and the heap 
sizes is affected through the use of a <em>linker control file</em>. This 
file is also important as it lets us define so called <em>overlays</em>
which we need to be able to run subroutines in on chip RAM.

<p>

<h3>What this chapter does not do</h3>
However, <b>this chapter is not intended to be a full Tartan C++ manual</b>.
There is a perfectly good Tartan C++ Manual out there<a href="#tthFtNtABA" name="tthFrefABA"><sup>10</sup></a> which explains everything in gory detail.

<p>
Secondly <b>this chapter is not documentation for the UNIX <tt>make</tt></b>
system. There are hundreds (thousands) of other documents describing the 
workings of <tt>make</tt> available out there<a href="#tthFtNtABB" name="tthFrefABB"><sup>11</sup></a>.

<p>
However we will explain the compiler flags used in the default makefiles, 
and also mention a few other switches which might be useful. 

<p>

<h3>What this chapter does cover</h3>
Basically, we would like to cover the following areas in this chapter

<ul>
<li>What tools are available</li>

<li>
What do these tools do</li>

<li>
What comprises your program.</li>

<li>
How to control linking via linker control files</li>

<li>
Where you can find exemplar files that you can hack.</li>
</ul>

<p>
 <h2><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Tartan C++ Software Tools</h2>
The Tartan C++ Software suite includes a supposedly industry standard C++
compiler (although its probably not compliant to the level of the latest 
ANSI standard. Very few C++ compilers are) a linker and a set of object file
utilities including an archiver for creating libraries. We now describe 
some of these utilities in turn.

<p>
 <h2><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;The C++ Compiler</h2>
The compilation and linking environment is controlled through the so
called Tartan C++ Shell. However this is not an interactive shell in the 
UNIX sense. Rather one should think about it as akin the standard <tt>cc</tt> 
command that in turn calls the preprocessor, the various compilation 
stages and then finally the linker to link all the object files and libraries.

<p>
The command name for invoking the Tartan C++ shell is <tt>tcpp</tt>. Invoking
the command with no arguments lists a help-screen giving all the command
line options and flags. According to the manual, the standard invocation is

<center>
<tt>tcpp</tt> <em>options... </em> <em>filename... </em>
</center>
where

<ul>
<li><em>options...</em> is zero or more options defining the behaviour of the
compilation and linking</li>

<li>
<em>filename...</em> is on or more C or C++ source files, assembly source files, object files or library files.</li>
</ul> 

<p>

<h3>File Suffices</h3>
Certain file suffixes are recognised by the shell. For example files
with suffices <tt>.C</tt> or <tt>.cpp</tt> are treated as C++ files. Files
with suffix <tt>.c</tt> are assumed to be C source files. The full set
of standard suffices are listed in figure <a href="#f:SuffixTable">6.1</a>.

<p>
<a name="tth_fIg6.1">
</a> 
<center>


<table>
<tr><td>Extension </td><td>File Type </td><td>Input or Output </td></tr>
<tr><td><tt>.cpp</tt>, <tt>.C</tt> </td><td>C++ Source file (.C recognised under UNIX only) </td><td>Input </td></tr>
<tr><td><tt>.c</tt> </td><td>C Source file </td><td>Input </td></tr>
<tr><td><tt>.asm</tt> </td><td>Assembly source file </td><td>Input and output </td></tr>
<tr><td><tt>.tof</tt> </td><td>TOFF (Tartan) object file </td><td>Input and output </td></tr>
<tr><td><tt>.obj</tt> </td><td>COFF (Texas Instruments) object file </td><td>Input </td></tr>
<tr><td><tt>.olb</tt> </td><td>TOFF (Tartan) library file </td><td>Input </td></tr>
<tr><td><tt>.lib</tt> </td><td>COFF (Texas Instruments) object file </td><td>Input </td></tr>
<tr><td><tt>.lcf</tt> </td><td>Linker Control File </td><td>Input </td></tr>
<tr><td><tt>.ctl</tt> </td><td>Object file list used with linker control file </td><td>Output </td></tr>
<tr><td><tt>.i</tt>   </td><td>Preprocessed file </td><td>Output </td></tr>
<tr><td><tt>.map</tt> </td><td>Linker map file </td><td>Output </td></tr></table>
<!--hbox-->
</center>

<center>Figure 6.1: The conventional file suffixes for the Tartan Shell. Input
or output refers to whether the files are input or output of the shell</center>
<a name="f:SuffixTable">
</a>

<p>

<h3>Some Common Flags</h3>
We now list a few flags commonly used by the shell.

<dl compact="compact">
	<dd><tt>-c &nbsp;</tt> Compile / assemble only. Input source files are compiled
into TOFF <tt>.toff</tt> object files</dd>

	<dd><tt>-fa</tt> <em>file</em> &nbsp; Treat <em>file</em> as an assembly source file</dd>

	<dd><tt>-fc</tt> <em>file</em> &nbsp; Treat <em>file</em> as a C source file</dd>

	<dd><tt>-fp</tt> <em>file</em> &nbsp; Treat <em>file</em> as a C++ source file</dd>

	<dd><tt>-fl</tt> <em>file</em> &nbsp; Treat <em>file</em> as a linker control file</dd>

	<dd><tt>-e </tt> <em>file</em> &nbsp; Produce executable named <em>file</em>. Analogue 
of <tt>-o</tt> flag on Standard UNIX compilers.</dd>

	<dd><tt>-d</tt><em>name=
<br clear="all" /><table border="1" width="95%"><tr><td>
<table border="1" align="center"><tr><td nowrap="nowrap" align="center">
<i>value</i></td></tr></table>
</td></tr></table>

</em>&nbsp; Define preprocessor variable <em>name</em>.</dd>

	<dd><tt>-u</tt><em>name</em> &nbsp; Undefine preprocessor variable <em>name</em>.</dd>

	<dd><tt>-i</tt><em>dir</em>&nbsp; Include directory list <em>dir</em> in the default
include path. A directory list is a colon (:) separated list of directories.
Analogue of the <tt>-I</tt> flag on standard UNIX compilers.</dd>

	<dd><tt>-lk</tt>&nbsp; All C files are assumed to be in K&amp;R style.</dd>

	<dd><tt>-lc</tt>&nbsp; All C++ files are assumed to be in <tt>cfront</tt> mode.</dd>

	<dd><tt>-ln</tt>&nbsp; Normal mode. C and C++ files may contain Tartan's ``normal'' extensions to the ANSI/ISO standard (default).</dd>

	<dd><tt>-ka</tt>&nbsp; Keep assembly files.</dd>

	<dd><tt>-kc</tt>&nbsp; Keep local control file (<tt>.ctl</tt>).</dd>

	<dd><tt>-ke</tt>&nbsp; Keep the compiler error file</dd>

	<dd><tt>-kl</tt>&nbsp; Keep the compiler listing and cross reference file (<tt>.lst</tt>).</dd>

	<dd><tt>-km</tt>&nbsp; Keep the linker map file.</dd>

	<dd><tt>-v30</tt>&nbsp; Generate code for TMS320C3x DSP processors (defaul). These are the ones we use.</dd>

	<dd><tt>-lxs</tt> &nbsp; I see this in the Makefile but can't find in manual.<em>Bob can you help out?</em></dd>

	<dd><tt>-mb</tt> &nbsp; Use big memory model.</dd>

	<dd><tt>-o0 &nbsp;</tt> Use no optimisation.</dd>

	<dd><tt>-o1 &nbsp;</tt> Use low optimisation.</dd>

	<dd><tt>-o &nbsp;</tt> Optimise; space and time (memory and speed) optimisations
are balanced (defaul).</dd>

	<dd><tt>-os &nbsp;</tt> Use space (memory) optimisation.</dd>

	<dd><tt>-ot &nbsp;</tt> Use time (speed) optimisation.</dd>

	<dd><tt>-q &nbsp;</tt> Be quiet; display the minimum amount of information.</dd>
</dl>

<p>

<h3>Sensible/Necessary Compiler Flags</h3>
We need to produce (<tt>.ctl</tt>) files if we are to link. It is not unhelpful
to keep these. We also definitely want a map file at the end of the day so 
we need to set that. It is often useful to have the listing file (<tt>.lst</tt>)
file around as well and we use the big memory model so a reasonable minimal
set of compiler flags is ``<tt>-km -kc -kl -mb</tt>''. 
Hence I usually have the following Makefile macros and rules for compilation.

<pre>
TCPP 	= tcpp
TCPPFLAGS = -km -kc -kl -mb -q
# Set this to your own include path 
INCFLAGS  = -i.

.SUFFIXES: .C .tof
.C.tof:
	$(TCPP) $(INCFLAGS) $(TCPPFLAGS) -c $&lt;

</pre>

<p>
 <h2><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;QCDSP Runtime and IO Libraries</h2>
The QCDSP runtime library is called <tt>tcrt30bs.olb</tt> and lives in the 
directory <tt>/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3</tt>. This program is usually automatically linked into your applications so you need not worry about it.

<p>
The QCDSP I/O libraries (necessary if you want to go and use things like <tt>printf</tt>) is called <tt>tcio30bs.olb</tt>. <b>This file is in the default link path
but is not automatically linked at run time. You have to do it manually</b>. If you
do not link this file you will not be able to do serial IO from your programs.
This file is usually linked in by the default makefiles if you use those, but
be aware that you have to link it by hand if you start building your
own makefiles.

<p>
 <h2><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;Converting TOFF to COFF</h2>
The Tartan C++ compiler in general produces code in the TOFF object format.
However the QCDSP nodes prefer executables to be in the Texas Instruments
COFF format. A utility <tt>t2c</tt> is available to convert from one form to
the other. The invocation syntax is:

<center>
<tt>t2c</tt> <em>TOFF file</em> <em>COFF file</em>
</center>
where the <em>TOFF</em> file is a Tartan object file, and the <em>COFF file</em>
is the desired name of the executable. The filename convention is for executable
files to have the <tt>.out</tt> file suffix.

<p>
 <h2><a name="tth_sEc6.6">
6.6</a>&nbsp;&nbsp;A typical Makefile</h2>
A typical makefile (named <tt>Makefile</tt>) to produce an executable would start to look something like this:
<font size="-3">

<pre>
# Name of makefile so we can recompile if changed
MAKEFILE = Makefile
# The tartan C++ compiler
TCPP	= tcpp
# The minimal set of flags
TCPPFLAGS = -km -kc -kl -mb -q
# My custom include directories
INCFLAGS  = -i .:./include
# Base (Unsuffixed) name of the executable 
EXEC_BASE = my_executable
# My C++ Sources
SRCS        = foo.C bar.C main.C
# My Include dependencies
INCLUDES    = foo.h bar.h
# My object files: (all my .C files with suffix changed to .tof) 
TOF_OBJS    = $(SRCS:.C=.tof)
# My Custom libraries
LIBS	    = mylib1.olb mylib2.olb
# System IO library (Run time library is linked automaticaly)
SYSLIBS     = tcio30bs.olb
# Define suffixes
.SUFFIXES: .C .tof

# Build executable
$(EXEC_BASE).out: $(MAKEFILE) $(INCLUDES) $(TOF_OBJS) $(LIBS) $(SYSLIBS)
	$(TCPP) -e $(EXEC_BASE).outtof $(INCFLAGS) $(TCPPFLAGS) \
	        $(SYSLIB) $(LIBS)
	t2c $(EXEC_BASE).outtof $(EXEC_BASE).out

# Default C++ to .tof compilation rule
.C.tof:
	$(TCPP) $(INCFLAGS) $(TCPPFLAGS) -c $&lt;

# Remove pesky intermediate files 
clean:
	rm -rf *.tof *.lst *.map core *.outtof *.ctl

</pre>
</font>

<p>
 <h2><a name="tth_sEc6.7">
6.7</a>&nbsp;&nbsp;Linker Control Files</h2>
Linker Control files allow us to have fine tuning over how the linker
links our numerous object files into an overall executable. Amongst 
other things it lets us change the size of the stack and the heap, 
and allows us to define overlays to use the on chip memory of a node
(The so called CRAM).

<p>
Before going further a word or two must be said about the linker. It
treats your program as a series of modules, containing sections. A module
from the linker point of view is an object file. A section can be 
a defined data section, or a given function entry point. The linker
contro file not only gives you power over the memory layout of the 
program but also, you can individually select (should you so choose)
which sections to use, not use etc.

<p>
Perhaps the easiest way to explain a linker control file is to examine
the default one. You can find it in <tt>/usr/local/tartan/v2.1/etc/qcdsp_v5.3.3</tt>. The actual file itself is called <tt>link.lcf</tt>.

<p>
I list it below:
<font size="-3">

<pre>
/*
//
// C and C++ Linker Control File
// for the TI TMS320C30 Application Board
// Startup Configuration
//
// Modified by RDM 9/8/96 for qcdsp.  Assume here that the
// boot kernels have already been used to initialize the hardware,
// including the NGA.
//
// Modified by RDM 10/9/97.
// Changed banner to read version 5 
//
*/

link  

/*
// Display Banner
*/

banner "Tartan Linker for QCDSP version 5.3.2, modified 1/11/99 by RDM";
banner "Memory = 0x80000, stack = 0x1000, heap = 0x1000";

/*
// Options
*/

resolve sections;                       // optimize linking
options romcopy;                        // init RAM variables from ROM

/*
// Configuration Constants
*/

define __STACK_SIZE     = 0x1000;       // 1K stack

define __SYSMEM_SIZE    = 0x1000;       // 1K heap

// These constants define bus control register values loaded at startup
define tc_PBCR_startup  = 0xF00;        // primary bus control value
// define tc_EBCR_startup       = 0x0;          // expansion bus control value

// These constants define ST, IE registers during initialization
define tc_ST_startup    = 0x2800;       // status register
define tc_IE_init       = 0x7FFF;       // interrupt mask

/*
// System Configuration
*/

define TDB_BREAKPOINT   = 0x66000000;   // breakpoint for Tartan debugger

control "*.ctl";                        // list of obj/lib files to link
                                        // *.ctl file built by Tartan shell

list "*.map";                           // default extension for link maps

space .stack, __STACK_SIZE;             // declare memory for program stack
space .sysmem, __SYSMEM_SIZE;           // declare memory for program heap

/*
// Explicit Modules
*/

use module = qcdsp_tcroot;              // general startup code
use module = tcrpc;                     // needed for Tartan debugger
use section = .cinit nowarn;            // link in .cinit tables

use kind = debug;                       // include debug information
use kind = dstring;                     // include debug strings
use kind = linenumber;                  // include debug line mapping
/*
// Define Memory Layout
*/

memory (
        limit = 0x80000;                //
        avoid = 0x0, 0x1000;            // 0x1000 - 0x7FFFF
);
 
/*
// Define Program Layout
*/

allocate ".bss" kind = data image (
                origin = 0x1000 kind=data
        );

allocate ".data" kind = constant image (
                kind=constant
        );

allocate ".text" kind = code image   (
                kind = code 
        );

/*
// Debug Directives
//
// These commands are for debugger symbol information, and do
// not affect the size or location of the program
*/

allocate debug_directives image kind = debug
        (origin = 0 kind = debug);

allocate debug_strings image kind = dstring
        (origin = 0 kind = dstring);

allocate debug_strings image kind = dstring
        (origin = 0 kind = dstring);

allocate debug_source_location image kind = linenumber
        (origin = 0 kind = linenumber);

end link;

</pre>
</font>
You can see that the LCF has a C like command syntax. This file begins
with a bunch of comments. The banner instructions are displayed on screen
at link time so as to supply you with information about what is going on.

<p>
After the banner section you come to the options section. The first command
there <tt>resolve sections</tt> is an instruction to the linker that it
should try to optimize the link by missing out (eliminating) sections
that have not been referenced. The <tt>options romcopy</tt> command indicates
a particular way of initialising constants. I tend to leave these two well
alone.

<p>
Next comes the configuration section where we can set the stack and heap
sizes. These are done through defining system labels <tt>__STACK_SIZE</tt>
for the stack and <tt>__SYSMEM_SIZE</tt> for the heap. You can see that
the default link file specifies a measly 1K for stack and 1K for heap.
In the Columbia physics system __STACK_SIZE is usually set to 0x010000
(64K) and __SYSMEM_SIZE is usually set to 0x030000 (192K).
The following symbol definitions deal with breakpoints and interrupts and 
are probably best left alone. 

<p>
Then follow two commands <tt>control "*.ctl"</tt> and <tt>list "*.map"</tt>.
The first of these has been built by the compiler during the compilation
process. It contains statements like <tt>"WITH xxxxxx"</tt> where
the <tt>xxxxx</tt> refers to section names. By specifying that the control should
come from all the <tt>.ctl</tt> files, I as a user don't have to type <tt>"WITH xxxx</tt> manually for each section I want linked into the file. Instead all the 
referenced sections will be automatically linked for me. The <tt>list</tt> 
command merely specifies that the default extention for output map files
is <tt>.map</tt>.

<p>
Following these statements come the commands that reserve space
for the stack and the heap. These are <tt>space .stack, __STACK_SIZE</tt>
and <tt>space .sysmem, __SYSMEM_SIZE</tt>. They create two sections named
<tt>.stack</tt> and <tt>.sysmem</tt> and these will each have the requisite number
of words reserved for them.

<p>
After this are a couple of <tt>use</tt> statements. These include entire modules
that are I presume part of the run time environment. All this is best left
alone.

<p>
The command 

<pre>
memory (
        limit = 0x80000;                //
        avoid = 0x0, 0x1000;            // 0x1000 - 0x7FFFF
);

</pre>
defines the virtual address space. This happens to be the same as the
physical address space except when you deal with overlays - see next chapter.
The statement is that we have a limite of 0x080000 words which sets the 
upper limit of memory to 0x07FFFF. The second line states that we must
avoid locating code between 0x000000 and 0x001000 which is the lower 1K
of the memory.

<p>
Thereafter we define the layout of the program using allocate statements.
Here only the standard sections were allocated, namely the BSS area 
the constant data area and area for the program text. The total allocation
will include the stack and the heap as well. The first <tt>allocate</tt> command
specifies an explicit origin, so that the BSS will start
at 0x001000,. The other sections will follow it in memory. Note that
each allocated section also has a kind value specifying whether it 
holds data, constant data or code.

<p>
This control file also contains some allocate statements to do with 
debugging, before it is finished off with the final command
<tt>END LINK;</tt>.

<p>

<h3>Linking With a Linker Control file</h3>
To link with a particular linker control file add it to the <tt>tcpp</tt> 
command with the <tt>-fl</tt> flag. A Makefile that uses a linker control
file might look something like this:
<font size="-3">

<pre>
# Name of makefile so we can recompile if changed
MAKEFILE = Makefile
# The tartan C++ compiler
TCPP	= tcpp
# The minimal set of flags
TCPPFLAGS = -km -kc -kl -mb -q
# My custom include directories
INCFLAGS  = -i .:./include
# Base (Unsuffixed) name of the executable 
EXEC_BASE = my_executable
# My C++ Sources
SRCS        = foo.C bar.C main.C
# My Include dependencies
INCLUDES    = foo.h bar.h
# My object files: (all my .C files with suffix changed to .tof) 
TOF_OBJS    = $(SRCS:.C=.tof)
# My Custom libraries
LIBS	    = mylib1.olb mylib2.olb
# System IO library (Run time library is linked automaticaly)
SYSLIBS     = tcio30bs.olb
# Set up the flags to specify a linker control file
LINK_CONTROL= -fl mylink.lcf
# Define suffixes
.SUFFIXES: .C .tof

# Build executable
$(EXEC_BASE).out: $(MAKEFILE) $(INCLUDES) $(TOF_OBJS) $(LIBS) $(SYSLIBS)
	$(TCPP) -e $(EXEC_BASE).outtof $(INCFLAGS) $(TCPPFLAGS) \
	        $(SYSLIB) $(LIBS) $(LINK_CONTROL)
	t2c $(EXEC_BASE).outtof $(EXEC_BASE).out

# Default C++ to .tof compilation rule
.C.tof:
	$(TCPP) $(INCFLAGS) $(TCPPFLAGS) -c $&lt;

# Remove pesky intermediate files 
clean:
	rm -rf *.tof *.lst *.map core *.outtof *.ctl

</pre></font>

<p>
 <h2><a name="tth_sEc6.8">
6.8</a>&nbsp;&nbsp;The Tartan Archiver</h2>
The Tartan software suite comes with an archiver/librarian called <tt>olib</tt>,
which is the analogue of the UNIX <tt>ar</tt> command. It can be invoked without
any arguments in which case it will present a list of its command line
options. Otherwise the syntax is similar to the <tt>ar</tt> command:

<center>
<tt>olib &lt;options&#62; &lt;library file&#62; &lt;files&#62;</tt>
</center>

<p>
For example the command

<pre>
olib -create foo.olb foo1.tof foo2.tof foo3.tof

</pre>
will create the library file <tt>foo.olb</tt> containing the modules
in <tt>foo1.tof</tt> <tt>foo2.tof</tt> and <tt>foo3.tof</tt>.

<p>
 <h2><a name="tth_sEc6.9">
6.9</a>&nbsp;&nbsp;Summary</h2>
In this short chapter we have given some of the more important compiler
flags for the tartan C++ compiler and explained meanings of the basic 
default Linker Control file. We also pointed out how this file could
be changed to change the stack and heap sizes used by a given user program.

<p>
 <h1><a name="tth_chAp7">
Chapter 7 </a><br />Single Processor Optimisation I - Using CRAM</h1>

 <h2><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Introduction</h2>
The greatest performance gains on the QCDSP can be made through
judicious use of the fast on-chip RAM that is built onto the 
processor and through the circular buffer.

<p>
The on-chip RAM, referred to from now on as CRAM is 2Kwords
worth of memory that can be immediately accessed
by the DSP processor. (It has a memory latency of 0 cycles).

<p>
The circular buffer can be thought of as another level of fast
memory. It can hold 32Kwords and deliver them to the processor
with a latency of a single cycle after some initial setup overhead.

<p>
Apart from these features, the DSP itself can overlap one floating
point addition with one floating point multiplication. This however
requires assembly coding of routines. 

<p>
One can take advantage of the CRAM and the circular buffer
from within C++ at the expense of knowing some magic numbers to set
the circular buffer modes. However using the CRAM requires the 
technique of ``overlay programming''.

<p>

<h3>What this chapter covers</h3>
In this chapter we wish to explain the process of using the CRAM.
We will do this in three stages. Firstly, we will construct a 
simple SU(3) matrix-vector multiplication routine and time it.

<p>
We will then explain how to relocate the C++ routine into the fast
CRAM, and time the resulting performance.

<p>
Finally, we will give an assembler optimised version of the same
routine and locate it into CRAM. At each stage, we should see the
number of clock cycles needed to perform the routine decrease<a href="#tthFtNtABC" name="tthFrefABC"><sup>12</sup></a>. 

<p>

<h3>What this chapter does not cover</h3>
We do not cover the following:

<ul>
<li>DSP Architecture and Assembly language - see the following:

<dl compact="compact">
	<dd><b>TMS320C3x User's Guide</b>: &nbsp; <br />
&nbsp;<tt>http://www-s.ti.com/sc/psheets/spru031e/spru031e.pdf</tt></dd>

	<dd><b>TMS320C3x/C4x Assembly Language Tools User's Guide</b>: &nbsp; <br />
&nbsp;<tt>
http://www-s.ti.com/sc/psheets/spru035c/spru035c.pdf</tt>. NOTE this site
contains details of the Texas Instruments assembler and linker, not the 
Tartan Linker described in the last chapter.</dd>

	<dd><b>TMS320C3x General-purpose applications User Guide</b>: &nbsp; <br />
 <tt>
http://www-s.ti.com/sc/psheets/spru194/spru194.pdf</tt></dd>
</dl></li>

<li>
Use of the Circular Buffer. See future addenda/re-releases of this 
document.</li>
</ul>

<p>
 <h2><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Overlay Programming and the Linker Control File</h2>
Overlay programming harks back to the days when computers had a limited
amount of memory and kept a lot of their code either in memory
that was too slow to access or somewhere else. The premise of the method
was that when a piece of code was not actually executed, it could be 
overwritten by another piece which could then be run. Designing a program so
that it split neatly into sets of overlays was a magic artform.

<p>
Nowadays of course workstations have effectively unlimited amounts of memory
and virtual memory management systems in operating systems take care
of paging memory and swapping memory out to disk (a kind of automatic
overlaying process). 

<p>
In embedded systems however overlay programming is still common and in
fact for the QCDSP it is necessary. The idea is that the overlays are
stored in the slow DRAM, but the linker resolves all the addresses in them
as if they were in the CRAM. Before use, a user copies the routines from 
DRAM into the CRAM and calls them there. 

<p>

<h3>Virtual Addresses and the Linker Control File</h3><a name="s:ModLCF">
</a>
In the last chapter we mentioned that the <tt>ALLOCATE</tt> statements in 
a linker control file refer to the allocation of <em>virtual addresses</em>, 
but it just so happens that by default the virtual addresses and physical
addresses are the same. Now our CRAM is <em>memory mapped</em> into the 
the DSP address space. The lower part  of the CRAM contain interrupt
and status register areas so effectively from our point of view, the 
lowest address we can use to access the CRAM is 0x809800.

<p>
Hence routines that use the CRAM must be told that their (virtual) addresses
begin at 0x809800 or higher. We can do this with an <tt>ALLOCATE</tt>
statement in the linker control file. The following <tt>ALLOCATE</tt> statement
defines an overlay called <tt>mvmult_overlay</tt> (for a matrix vector multiply
routine) which will take relocatable object code and resolve it as if it
began at address 0x809800:

<pre>
ALLOCATE "mvmult_overlay" kind = code image (
        origin = 0x809800 define "_mvmult_dest"
        kind = code module = matvecmult
);

</pre>

<p>
The <tt>ALLOCATE</tt> statement defines a linker section called <tt>
mvmult_overlay</tt> containing code. The addresses in this linker section
will start from <tt>0x809800</tt> (the <tt>origin</tt>) statement and the
linker symbol <tt>_mvmult_dest</tt> has been defined to contain this
address (the <tt>define</tt> statement). This symbol will be visible from
our C++ programs (and the leading underscore is important). The <tt>
kind</tt> statement defines that the section will contain code, and the
<tt>module</tt> command means that the code to be resolved lives in the
<tt>matvecmult</tt> module which in this case means that the object code
for this section will be in the <b>matvecmult.tof</b> file or any
library containing the modules from the <b>matvecmult.tof</b> file.

<p>
So far so good. The address space of the <tt>matvecmult</tt> module will
begin at 0x809800, however we do not want the code to be linked here.
We want the actual code section to be in the DRAM. Then, we could
copy it to 0x80980 before execution. We can't link it to this address
because the loader program (that loads our programs to the QCDSP nodes)
can only load to addresses in the DRAM which has an upper limit of 0x07FFFF.

<p>
Hence we have to tell the linker control file that our virtual and 
physical memory addresses are no longer the same and specify the order
in which linker sections should be laid out in physical memory. This 
can be done by the <tt>physical</tt> statement just before the end of our
linker control file. 

<p>
Consider the following <tt>physical</tt> definition:

<pre>
PHYSICAL ( 
   origin = 0x1000
   section = ".bss"
   next section = ".data"
   next section = ".text"
   define "_mvmult_begin"
   next   section = "mvmult_overlay"
   define "_mvmult_end"
   next remaining
);

</pre>

<p>
This tells the linker that real (physical) memory starts at 0x1000
and that in the executable image, the <tt>.bss</tt> section should start
at 0x1000, followed by the <tt>.data</tt> and <tt>.text</tt> sections. This
should immediately be followed by the code for the <tt>mvmult_overlay</tt>
section, however we wish to define linker symbols <tt>_mvmult_begin</tt>
to point to the address where the overlay section will start and the 
<tt>_mvmult_end</tt> symbol to point to the first address after it ends.
Finally, the <tt>next remaining</tt> statement just tells the linker to 
put all the remaining sections to follow from the address <tt>_mvmult_end</tt>.

<p>
The idea is that the code will be laid out in physical memory starting
at 0x1000. If we want to use the overlay we will have to copy the
contents of the DRAM from between the addresses of the <tt>
_mvmult_begin</tt> symbol and the <tt>_mvmult_end</tt> symbol to the
address of the <tt>_mvmult_dest</tt> symbol. We can then call the 
subroutine and the code will start executing at the CRAM address because
that is what the linker set to be the origin of the routine.

<p>
To illustrate how the extra <tt>ALLOCATE</tt> and <tt>PHYSICAL</tt> statements
fit into the scheme of the usual linker control file, we now show the 
full file. You should be able to find it in <tt>/qcdsp/sfw/qos.5.3.3/example/optimise2/link.lcf</tt>.
<font size="-3">

<pre>
/*
// QCDSP Modified Default Linker Control File
// Taken from /usr/local/tartan/v2.1/etc/qcdsp_v5.3.3/link.lcf 
// and the physics system &lt;phys_root&#62;/mem/include/link_p2v.lcf
// Modifed By BJ
*/

link  

/*
// Display Banner
*/

banner "Tartan Linker for QCDSP version 5.3.3, modified 1/11/99 by RDM";
banner "Customised by BJ 4/29/2000";
banner "Memory size:  0x80000 (512 Kwords)";
banner "Stack  size:  0x10000 ( 64 Kwords)";
banner "Heap   size:  0x30000 (192 Kwords)";
banner "----------------------------------";
banner "Remaining  :  0x20000 (128 Kwords) for code and qloaded data";

/*
// These are standard
*/

resolve sections;                       // Eliminate unused sections
options romcopy;                        // init RAM variables from ROM

/*
// Configuration Constants
*/

define __STACK_SIZE     = 0x10000;      //  64K stack
define __SYSMEM_SIZE    = 0x30000;      // 192K heap

// These constants define bus control register values loaded at startup
define tc_PBCR_startup  = 0xF00;        // primary bus control value
// define tc_EBCR_startup       = 0x0;  // expansion bus control value

// These constants define ST, IE registers during initialization
define tc_ST_startup    = 0x2800;       // status register
define tc_IE_init       = 0x7FFF;       // interrupt mask
 
/*
// System Configuration
*/

define TDB_BREAKPOINT   = 0x66000000;   // breakpoint for Tartan debugger

control "*.ctl";                        // list of obj/lib files to link
                                        // *.ctl file built by Tartan shell

list "*.map";                           // default extension for link maps

space .stack, __STACK_SIZE;             // declare memory for program stack
space .sysmem, __SYSMEM_SIZE;           // declare memory for program heap

/*
// Explicit Modules
*/

use module = qcdsp_tcroot;              // general startup code
use module = tcrpc;                     // needed for Tartan debugger
use section = .cinit nowarn;            // link in .cinit tables

use kind = debug;                       // include debug information
use kind = dstring;                     // include debug strings
use kind = linenumber;                  // include debug line mapping

/*
// Define Memory Layout
*/

memory (
        limit = 0x80000;                //
        avoid = 0x0, 0x1000;            // 0x1000 - 0x7FFFF
);
 
/*
// Define Program Layout
*/

/*
// Create an overlay so that we can put matvecmult into
// On Chip RAM. 0x80980 is start of Memory mapped image
// of CRAM.

 */
allocate "mvmult_overlay" kind = code image (
        origin = 0x809800 define "_mvmult_dest"
        kind = code module = matvecmult
);

allocate ".bss" kind = data image (
                origin = 0x1000 kind=data
        );

allocate ".data" kind = constant image (
                kind=constant
        );

allocate ".text" kind = code image   (
                kind = code 
        );

allocate image (
        remaining
);

/*
// Debug Directives
//
// These commands are for debugger symbol information, and do
// not affect the size or location of the program
*/

allocate debug_directives image kind = debug
        (origin = 0 kind = debug);

allocate debug_strings image kind = dstring
        (origin = 0 kind = dstring);

allocate debug_source_location image kind = linenumber
        (origin = 0 kind = linenumber);


/* Specify physical memory  */
physical ( 
   origin = 0x1000
   section = ".bss"
   next section = ".data"
   next section = ".text"
   define "_mvmult_begin"
   next   section = "mvmult_overlay"
   define "_mvmult_end"
   next remaining
);

end link;

</pre></font>

<p>

<h3>Changes to C++ Files</h3>
The symbols defined in the linker control files can be made apparent to 
the C++ source files using the <tt>extern "C"</tt> statements. For example
to see the symbols defined in the linker control file above our
C++ program sould contain the lines

<pre>
extern "C" void mvmult_dest();
extern "C" void mvmult_begin();
extern "C" void mvmuld_end();

</pre>

<p>
The reason for the <tt>extern "C"</tt> statements, is to do with the 
C++ compiler. When you define a function like <tt>void foo(float)</tt>
the C++ compiler encodes the name into some others string such as
<tt>_foo__XXXXX</tt> for the linker symbol where <tt>XXXX</tt> is some
code that signifies that this particular version of the <tt>foo</tt> 
takes a single float argument. If you then define a <tt>void foo(int)</tt>
(which you are perfectly allowed to do in C++) the compiler would mangle
this into some other compiler symbol, say <tt>_foo__YYYY</tt>. The <tt>extern "C"</tt> basically instructs the compiler to not do this encoding. Hence, after the
declarations above, if the C++ compiler encounters the <tt>mvmult_dest</tt>
it would not encode it but would straightforwardly translate it to
<tt>_mvmult_dest</tt> which is the correct linker symbol that we defined
for it in the linker control file.

<p>
Likewise we must declare the actual <tt>matVecMult</tt> function as <tt>extern "C"</tt> otherwise the C++ compiler will mangle it to something else and the linker
will not find a module called <tt>matvecmult</tt>. Instead it will find something
like <tt>_matVecMult__FPfN21</tt>, which can lead to linking errors. I do 
this by defining a header file <b>matvecmult.h</b> and <tt>
it both into the <b>matvecmult.C</b> file where the subroutine is defined
(remember it has to be in a separate file to be a separate module) 
the and <tt>main.C</tt> file where the routine is called. The header file
looks like this:

<pre>
#ifndef MATVECMULT_H
#define MATVECMULT_H
extern "C" void matVecMult(float *, float *, float *);
#endif

</pre>

<p>
Why do the symbols need to be declared as void functions? Well in the 
linker control file we defined them effectively as entry points to functions.
These functions take no arguments in this example, but may in later ones.

<p>

<h3>Copying the Code to the CRAM</h3>
Once the linker control file is set up correctly and the linker
symbols are visible we simply need to write a subroutine to copy 
the <tt>matVecMult</tt> subroutine  into the CRAM. This could be done with
a single <tt>memcpy</tt> instruction, but despite the claims of the 
Tartan manual, I couldn't manage to find the library where <tt>memcpy</tt>
lives. Consequentially I just wrote a loop to do the <tt>memcpy</tt> which I
show below:
<font size="-3">

<pre>
void loadMatVecMultIntoCRAM(void)
{
   unsigned int length = (unsigned int*)&amp;mvmult_end
                        -(unsigned int*)&amp;mvmult_begin;
	
   // I guess uip stands for unsigned integer pointer

   unsigned int * uip_src = (unsigned int *)&amp;mvmult_begin;
   unsigned int * uip_dest = (unsigned int *)&amp;mvmult_dest;

   printf("Copying MatVecMult Into CRAM\n");
   int i;
   for(i=0; i &lt; length; i++) {
        *uip_dest++ = *uip_src++;
   }    
   printf("Done\n");
}

</pre></font>

<p>
Note here the usage of the external symbols. The addresses of the 
symbols (without any calling parameters or trailing brackets) are 
used to get at the memory addresses at which they were defined in
the linker control file. The results are cast to unsigned integers. 

<p>
Let us now go through the process of optimising. We will follow the 
example above and deal with a single SU(3) matrix times 3-vector 
multiplication.

<p>
 <h2><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Step One: Straight C++</h2>
In this section, we shall write a basic vector and matrix class 
in file called <b>matvec.h</b>, a routine to multiply the two together
in <b>matvecmult.C</b> and finally a <b>main.C</b> file where we
time the multiplication routines. There is also a file called <b>
defines.h</b> where we define a few convenient macros.

<p>
I present here the header files. Firstly <b>defines.h</b>
<font size="-3">

<pre>
#ifndef DEFINES_H
#define DEFINES_H

#define RE  0
#define IM  1
#define N_COMPLEX 2
#define N_COLOUR  3

#endif

</pre></font>
secondly <b>matvec.h</b> 
<font size="-3">

<pre>
// ---------------------------
// matvec.h
// ---------------------------
#ifndef MATVEC_H
#define MATVEC_H





// ----------------------------------------
// Quick and dirty Complex 3x3 matrix class
// Supports indexing and can get a
// pointer to the matrix class
// ----------------------------------------

class Matrix {
private:
  float data_[N_COLOUR * N_COLOUR * N_COMPLEX];
public:
  float &amp; operator()(int cmpx, int col, int row) 
  {
        return( data_[ cmpx + N_COMPLEX*(col + N_COLOUR*row) ]  );
  }

  float* data() 
  {
        return &amp;data_[0]; 
  }
};

// -----------------------------------------
// Quick and dirty complex 3 vector
// ------------------------------------------

class Vector {
private:
   float data_[N_COLOUR * N_COMPLEX];
public: 

   float &amp; operator()(int cmpx, int row) 
   {
        return( data_[ cmpx + N_COMPLEX*row ] );
   }
 
   float * data()
   { 
        return &amp;data_[0];
   }
}; 
#endif

</pre></font>
and finally <b>matvecmult.h</b>
<font size="-3">

<pre>
#ifndef MATVECMULT_H
#define MATVECMULT_H
extern "C" void matVecMult(float *, float *, float *);
#endif

</pre></font>

<p>
The corresponding C++ files are <b>matvecmult.C</b>:
<font size="-3">

<pre>



// Define some indexes into the Matrix
// For Loop Unrolling

// First Row (Row 0) Columnwise
#define RE00  0
#define IM00  1
#define RE10  2
#define IM10  3
#define RE20  4
#define IM20  5

// Second Row (Row 1) Columnwise
#define RE01  6
#define IM01  7
#define RE11  8
#define IM11  9 
#define RE21  10
#define IM21  11

// Third Row (Row 2) Columnwise
#define RE02  12
#define IM02  13
#define RE12  14
#define IM12  15
#define RE22  16
#define IM22  17


// Define Some indices into the vectors
#define RE0    0
#define IM0    1
#define RE1    2
#define IM1    3
#define RE2    4
#define IM2    5

void matVecMult(float *y, float *a, float *x)
{
        // First row

        y[RE0] = ( a[RE00]*x[RE0] - a[IM00]*x[IM0] )
                +( a[RE10]*x[RE1] - a[IM10]*x[IM1] )
                +( a[RE20]*x[RE2] - a[IM20]*x[IM2] );

        y[IM0] = ( a[RE00]*x[IM0] + a[IM00]*x[RE0] )
                +( a[RE10]*x[IM1] + a[IM10]*x[RE1] )
                +( a[RE20]*x[IM2] + a[IM20]*x[RE2] );

        // Second Row
        y[RE1] = ( a[RE01]*x[RE0] - a[IM01]*x[IM0] )
                +( a[RE11]*x[RE1] - a[IM11]*x[IM1] )
                +( a[RE21]*x[RE2] - a[IM21]*x[IM2] );

        y[IM1] = ( a[RE01]*x[IM0] + a[IM01]*x[RE0] )
                +( a[RE11]*x[IM1] + a[IM11]*x[RE1] )
                +( a[RE21]*x[IM2] + a[IM21]*x[RE2] );


        // Third Row
        y[RE2] = ( a[RE02]*x[RE0] - a[IM02]*x[IM0] )
                +( a[RE12]*x[RE1] - a[IM12]*x[IM1] )
                +( a[RE22]*x[RE2] - a[IM22]*x[IM2] );

        y[IM2] = ( a[RE02]*x[IM0] + a[IM02]*x[RE0] )
                +( a[RE12]*x[IM1] + a[IM12]*x[RE1] )
                +( a[RE22]*x[IM2] + a[IM22]*x[RE2] );
}

</pre></font>
and finally the main program in <tt>main.C</tt>:
<font size="-3">

<pre>









void printTime(unsigned long start, unsigned long end, char *string)
{
        printf("%s: Start Time  %lu\n", string, start);
        printf("%s: End   Time  %lu\n", string, end);
        printf("%s: Difference  %lu cycles\n", string, end - start);

} 
  
   
int main(int argc, char *argv[]) 
{
  Matrix a;
  Vector x;
  Vector y; 
  int col,row;

  // Initialize the matrix and the vector 

  printf("Entered Program. Setting up Matrix and vector\n");

  for(row = 0; row &lt; N_COLOUR; row++) {
    for(col = 0; col &lt; N_COLOUR; col++) {
      a(RE,col,row) = row+1;
      a(IM,col,row) = (float)0;
      x(RE,row)   = row+1;
      x(IM,row)   = (float)0;
      y(RE,row)   = (float)0;
      y(IM,row)   = (float)0;
    }
  }

  printf("Calling Mat Vec routine \n");
  // Start timing
  unsigned long start_time, end_time;
  start_time = clock();

  // Call to matrix multiplication routine:
  // 
  // y &lt;- A x 
  // 
  matVecMult(y.data(), a.data(), x.data());

  // Stop timing
  end_time = clock();
  
  printf("Done. Printing Results\n");

  // Print out result 
  for(row = 0; row &lt; N_COLOUR; row++) {
    printf("[ ( %6f, %6f ) ] \n", y(RE, row), y(IM, row));
  }
  printTime(start_time, end_time, "matVecMult ");
}

</pre></font>

<p>
The <tt>clock()</tt> function can be used to time the performance of the 
routine. You should be able to find this code in <tt>/qcdsp/sfw/qos.5.3.3/example/optimise1</tt> with a suitable makefile and linker control file.

<p>
Upon compiling and running I get the following output on the nodes
(as usual neglecting the Qdaemon messages)

<p>

<pre>
Entered Program. Setting up Matrix and vector
Calling Mat Vec routine 
Done. Printing Results
[ ( 6.000000, 0.000000 ) ] 
[ ( 12.000000, 0.000000 ) ] 
[ ( 18.000000, 0.000000 ) ] 
matVecMult : Start Time  113454
matVecMult : End   Time  113964
matVecMult : Difference  510 cycles

</pre>

<p>
The matrix multiply routine as written, performs 66 floating point
operations during execution. Currently this takes 512 ticks of the 
(is it a 25 or 50MHz clock Bob?) clock.

<p>
 <h2><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Step 2: Relocate C++ to CRAM</h2>
Our first optimisation is to relocate the matrix vector multiplication
to CRAM. We have described all the steps needed to do this and have
shown the complete linker control file in section <a href="#s:ModLCF">7.2</a>. 
We now show the whole main program:
<font size="-3">

<pre>









// ------------------------------------------------
// Entry points defined by the linker control file
//
// To all intents and purposes these look like entry
// pointers to functions
// ------------------------------------------------

extern "C" void mvmult_end();
extern "C" void mvmult_begin();
extern "C" void mvmult_dest();

void loadMatVecMultIntoCRAM(void)
{
   unsigned int length = (unsigned int*)&amp;mvmult_end
                        -(unsigned int*)&amp;mvmult_begin;
   unsigned int * uip_src = (unsigned int *)&amp;mvmult_begin;
   unsigned int * uip_dest = (unsigned int *)&amp;mvmult_dest;

   printf("Copying MatVecMult Into CRAM\n");
   int i;
   for(i=0; i &lt; length; i++) {
        *uip_dest++ = *uip_src++;
   }   
   printf("Done\n");
}

void printTime(unsigned long start, unsigned long end, char *string)
{
        printf("%s: Start Time  %lu\n", string, start);
        printf("%s: End   Time  %lu\n", string, end);
        printf("%s: Difference  %lu cycles\n", string, end - start);

}

int main(int argc, char *argv[])
{
  Matrix a;
  Vector x;
  Vector y;

  int col,row;

  // Initialize the matrix and the vector

  printf("Entered Program. Setting up Matrix and vector\n");

  for(row = 0; row &lt; N_COLOUR; row++) {
    for(col = 0; col &lt; N_COLOUR; col++) {
      a(RE,col,row) = row+1;
      a(IM,col,row) = (float)0;
      x(RE,row)   = row+1;
      x(IM,row)   = (float)0;
      y(RE,row)   = (float)0;
      y(IM,row)   = (float)0;
    }
  }

  loadMatVecMultIntoCRAM();

  printf("Calling Mat Vec routine \n");

  // Start timing
  unsigned long start_time, end_time;
  start_time = clock();

  // Call to matrix multiplication routine:
  //
  // y &lt;- A x
  //

  matVecMult(y.data(), a.data(), x.data());

  // Stop timing
  end_time = clock();
 
  printf("Done. Printing Results\n");

  // Print out result
  for(row = 0; row &lt; N_COLOUR; row++) {
    printf("[ ( %6f, %6f ) ] \n", y(RE, row), y(IM, row));
  }
  printTime(start_time, end_time, "matVecMult ");
}

</pre></font>

<p>
Upon running I find that the program the output is

<pre>
Entered Program. Setting up Matrix and vector
Copying MatVecMult Into CRAM
Done
Calling Mat Vec routine 
Done. Printing Results
[ ( 6.000000, 0.000000 ) ] 
[ ( 12.000000, 0.000000 ) ] 
[ ( 18.000000, 0.000000 ) ] 
matVecMult : Start Time  240616
matVecMult : End   Time  240922
matVecMult : Difference  306 cycles

</pre>

<p>
Hence we have managed to make a substantial gain in execution time
simply by relocating the C++ code to CRAM.

<p>
 <h2><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;Step 3: Assembler optimisation</h2>
In this final step, we use a wrapper function
that calls an assembler routine to perform the matrix multiplication.
Since we are not interested in measuring overheads of relocating 
memory to CRAM just now, this means moving the timing tests into the 
wrapper. All the code including makefiles and routines shall eventually
be available from <tt>/qcdsp/sfw/qos.5.3.3/example/optimise3</tt>.

<p>

<h3>Assembling the Assembler Routine</h3>
We have not yet had occasion to use the assembler. The assembler in 
general use (in the default Makefiles etc) is the Texas Instruments
assembler, known as <tt>asm30</tt>. This produces Texas Instruments
(<tt>.obj</tt>) files. To be able to link these using the <tt>tcpp</tt>
command we must prefix the files with the <tt>-fi</tt> option to indicate
that they are in the Texas instruments COFF object format.

<p>
I defined the assembler to be used and the respective flags (having blatantly
stolen them from the default makefiles) using the following macros:

<pre>
ASM             = asm30
ASMFLAGS        = -q -lxs -mb -v30

</pre>
and used the following rules to allow assembly:
 <font size="-3">

<pre>
.SUFFIXES: .C .asm .tof .obj

.asm.obj:
        $(ASM) $(ASMFLAGS) $&lt;

</pre> </font>

<p>
and the lines that do the linking look like:
<font size="-3">

<pre>
ASMSRCS         = mtv.asm
ASM_OBJS        = $(ASMSRCS:.asm=.obj)
$(OUTBASE).out: $(TOF_OBJS) $(ASM_OBJS) $(INCLUDE) $(MAKEFILE) 
        $(TCPP) $(TCPPFLAGS) -e $(OUTBASE).outtof $(TOF_OBJS) -fi $(ASM_OBJS)
                $(SYSLIB) -fl $(LCF)
        t2c $(OUTBASE).outtof $(OUTBASE).out

</pre> </font>

<p>

<h3>The assembler routine</h3>
The assembler routine is shown below. Most of the contents are explained
in the comments. We make the point that the symbol <tt>||</tt> indicates that
the statements before and after the symbol are to be executed in parallel.
This feature is used when loading data from DRAM to CRAM and vice versa,
as well as in instructions where an addition and multiplication can 
be overlapped using the separate addition and multiplication feature
of the DSP.

<p>
<font size="-3">
<pre>
************************************************************************
*       mtv.asm
*       Balint Joo May/2000
*
*       derived from mtv.asm written by RDM
*
*           derived from dirac.asm, written by Dong Chen.
*
*       mtv( (FLOAT *) U, (FLOAT **)x )
*
************************************************************************

Y       .set            AR0
U       .set            AR1
X       .set            AR2
FP      .set            AR3

        .def    _mtv
        .def    _cram_vector

*  Space to hold 2 vectors in CRAM

_cram_vector
        .space  12

******************************************************
* FUNCTION DEF : _mtv
******************************************************

_mtv:
        PUSH    FP
        LDI     SP,FP
******************************************************
        ; *-FP(1)       return_addr
        ; *-FP(2)       U
        ; *-FP(3)       x
        ;
        ; AR5           _address of cram_vector
******************************************************
        PUSH    R4
        PUSH    R5
        PUSHF   R6
        PUSHF   R7
        PUSH    AR4
        PUSH    AR5
        PUSH    AR6
        PUSH    AR7


******************************************************
*  Load data to CRAM

        LDI     *-FP(3), AR4            ; load x into AR4
        LDI     80h, AR5                ; get 800000 into AR5 
        LSH     16, AR5
        OR      _cram_vector, AR5       ; mask in lower bits AR5
                                        ; now holds address of _cram_vector

        LDI     AR5, AR1                ; put _cram_vector address into AR1
        LDI     *AR4++, AR0             ; dereference x into AR0
        LDF     *AR0++, R0              ; get first element *x[0] into R0

        RPTS    4                       ; repeat 5 times
        LDF     *AR0++, R0              ; get next element *x[i] into R0
     || STF     R0, *AR1++              ; store *x[i] to _cram_vector[i]

        STF     R0, *AR1++              ; store last element *x[n-1] in 
                                        ; CRAM
*  Set pointers for U, Y and X.  AR4 is loaded into Y before each
*  multiply.

        LDI     *-FP(2), U              ; set U to point to matrix
        LDI     AR5, X                  ; set X to point to _cram_buffer
        LDI     6, AR4                  ; put 6 into AR4
        ADDI    AR5, AR4                ; add AR4 to _cram_buffer -&#62; AR4
                                        ; AR4 should point to second vector
                                        ; in CRAM = address of Y

        LDI     5, IR0

******************************************************
* ASM FUNCTION DEF : u_dot_x
******************************************************
u_dot_x:
*
* X2 = U . X1   (Complex 3x3 matrix dot 3 vector)
* 
* Y : X2                return with X2
* U : U  - 1            return with U + 17
* X : X1                return with X1
* R0,R1,R2,R3   are used for parallel instructions
* R0,R1 : temporary storage
* R2  : real part of X2
* R3  : imaginary part of X2
*
* first row of U
        LDI     AR4, Y                  ; set Y to AR4

        MPYF3   *U,     *X,     R2      ;R2 = U[0] * X1[0]
        MPYF3   *U++,   *++X,   R3      ;R3 = U[0] * X1[1]
        MPYF3   *U,     *X,     R0      ;R0 = U[1] * X1[1]
        MPYF3   *U++,   *-X,    R1
    ||  SUBF3   R0,     R2,     R2      ;R1 = U[1] * X1[0] || R2 -= R0
        MPYF3   *U,     *++X,   R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[2] * X1[2] || R3 += R1
        MPYF3   *U++, *++X,     R1
    ||  ADDF3   R0,     R2,     R2      ;R1 = U[2] * X1[3] || R2 += R0
        MPYF3   *U,     *X,     R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[3] * X1[3] || R3 += R1
        MPYF3   *U++,   *-X,    R1
   ||  	SUBF3   R0,     R2,     R2      ;R1 = U[3] * X1[2] || R2 -= R0
        MPYF3   *U,     *++X,   R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[4] * X1[4] || R3 += R1
        MPYF3   *U++, *++X,     R1
    ||  ADDF3   R0,     R2,     R2      ;R1 = U[4] * X1[5] || R2 += R0
        MPYF3   *U,     *X,     R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[5] * X1[5] || R3 += R1
        MPYF3   *U++,   *-X,    R1
    ||  SUBF3   R0,     R2,     R2      ;R1 = U[5] * X1[4] || R2 -= R0
* second row of U
        MPYF3   *U,     *--X(IR0),R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[6] * X1[0] || R3 += R1

        LDF     *++X,   R2
    ||  STF     R2,     *Y++            ;R2 = X1[1]        || X2[0] = R2

        MPYF3   *U++,   R2,     R3
    ||  STF     R3,     *Y++            ;R3 = U[6] * X1[1] || X2[1] = R3

        MPYF3   *U,     *X,     R2      ;R2 = U[7] * X1[1] || R3 += R1
        MPYF3   *U++,   *-X,    R1
    ||  SUBF3   R2,     R0,     R2      ;R1 = U[7] * X1[0] || R2 = R0-R2
        MPYF3   *U,     *++X,   R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[8] * X1[2] || R3 += R1
        MPYF3   *U++, *++X,     R1
    ||  ADDF3   R0,     R2,     R2      ;R1 = U[8] * X1[3] || R2 += R0
        MPYF3   *U,     *X,     R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[9] * X1[3] || R3 += R1
        MPYF3   *U++,   *-X,    R1
    ||  SUBF3   R0,     R2,     R2      ;R1 = U[9] * X1[2] || R2 -= R0
        MPYF3   *U,     *++X,   R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[10] * X1[4] || R3 += R1
        MPYF3   *U++,   *++X,   R1
    ||  ADDF3   R0,     R2,     R2      ;R1 = U[10] * X1[5] || R2 += R0
        MPYF3   *U,     *X,     R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[11] * X1[5] || R3 += R1
        MPYF3   *U++,   *-X,    R1
    ||  SUBF3   R0,     R2,     R2      ;R1 = U[11] * X1[4] || R2 -= R0
* third row of U
        MPYF3   *U,     *--X(IR0), R0

    ||  ADDF3   R1,     R3,     R3      ;R0 = U[12] * X1[0] || R3 += R1

        LDF     *++X,   R2              ;
    ||  STF     R2,     *Y++            ;R2 = X1[1]         || X2[2] = R2

        MPYF3   *U++,   R2,     R3
    ||  STF     R3,     *Y++            ;R3 = U[12] * X1[1] || X2[3] = R3

        MPYF3   *U,     *X,     R2      ;R2 = U[13] * X1[1] || R3 += R1
        MPYF3   *U++,  *-X,     R1
    ||  SUBF3   R2,     R0,     R2      ;R1 = U[13] * X1[0] || R2 = R0-R2
        MPYF3   *U,     *++X,   R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[14] * X1[2] || R3 += R1
        MPYF3   *U++,   *++X,   R1
    ||  ADDF3   R0,     R2,     R2      ;R1 = U[14] * X1[3] || R2 += R0
        MPYF3   *U,     *X,     R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[15] * X1[3] || R3 += R1
        MPYF3   *U++,   *-X,    R1
    ||  SUBF3   R0,     R2,     R2      ;R1 = U[15] * X1[2] || R2 -= R0
        MPYF3   *U,     *++X,   R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[16] * X1[4] || R3 += R1
        MPYF3   *U++,   *++X,   R1
    ||  ADDF3   R0,     R2,     R2      ;R1 = U[16] * X1[5] || R2 += R0
        MPYF3   *U,     *X,     R0
    ||  ADDF3   R1,     R3,     R3      ;R0 = U[17] * X1[5] || R3 += R1
        MPYF3   *U++,   *-X,    R1
    ||  SUBF3   R0,     R2,     R2      ;R1 = U[17] * X1[4] || R2 -= R0
        MPYF3   *X++, R0,       R0      ; dummy multiply
    ||  STF     R2,     *Y++            ;X2[4] = R2

        ADDF3   R1,     R3, R3          ;R3 += R1

        STF     R3,     *Y++            ;X2[5] = R3

*  Copy result back to DRAM
        LDI     AR4, AR0                ;  Y in CRAM
        LDI     *-FP(3), AR4
        LDI     *++AR4, AR1             ;  Y in DRAM
        
        LDF     *AR0++,R0               ; get first element of Y into R0
        RPTS    4                       ; repeat 5 times
        LDF     *AR0++, R0              ; get next element of Y into R0
     || STF     R0, *AR1++              ; store previous element to DRAM
        STF     R0, *AR1++              ; store last element
        POP     AR7                     ; restore registers and stack frame
        POP     AR6
        POP     AR5
        POP     AR4
        POPF    R7
        POPF    R6
        POP     R5
        POP     R4
        POP     FP
        RETS

</pre> </font>

<p>
By my counting this routine performs the multiplication using 73 floating
point instructions, however a lot of these are executed in parallel. Also
the routine was originally written to be performing 8 SU(3) multiplies
in a similar manner to a 4D finite difference operator. I may not have
stripped out all vestiges of this properly. However the routine does
seem to work. It is called from <b>main.C</b> in a similar manner to the 
last section. We list the complete <b>main.C</b> file below:
<font size="-3">

<pre>








// ------------------------------------------------
// Entry points defined by the linker control file
//
// To all intents and purposes these look like entry
// pointers to functions
// ------------------------------------------------
extern "C" void mvmult_end();
extern "C" void mvmult_begin();
extern "C" void mvmult_dest();

// -------------------------------------------------
// Entry point of Matrix Vector assembler routine
// -------------------------------------------------
extern "C" void mtv(float *u, float **vecs);


// -----------------------------------------------
// Routine for loading assembler routine MTV
// into CRAM
// -----------------------------------------------
void loadMatVecMultIntoCRAM(void)
{
  unsigned int length = (unsigned int*)&amp;mvmult_end
                         -(unsigned int*)&amp;mvmult_begin;

  unsigned int * uip_src = (unsigned int *)&amp;mvmult_begin;
  unsigned int * uip_dest = (unsigned int *)&amp;mvmult_dest;

  printf("Copying MatVecMult Into CRAM\n");
  int i;
  for(i=0; i &lt; length; i++) {
    *uip_dest++ = *uip_src++;
  }
  printf("Done\n");
}

void printTime(unsigned long start, unsigned long end, char *string){
        printf("%s: Start Time  %lu\n", string, start);
        printf("%s: End   Time  %lu\n", string, end);
        printf("%s: Difference  %lu cycles\n", string, end - start);
} 


// ---------------------------------------------
// Wrapper Routine to Call Assembler routine mtv
// 
// Does y = Ax
// ---------------------------------------------
void matVecMultMtv(float *y, float *A, float *x)
{


  // -------------------------------
  // mtv expects a (float **)vectors
  // so that vectors[0] = x
  // and vectors[1] = y
  // -------------------------------
  float *vector_array[2];
  float **vectors = &amp;vector_array[0];;
  vector_array[0]=x;
  vector_array[1]=y;

  // -------------------------------
  // Start Timing
  // -------------------------------
  unsigned long start_time, end_time;
  start_time = clock();

  // -------------------------------
  // Call assembler
  // -------------------------------
  mtv(A, vectors);  

  // -------------------------------
  // End Timing
  // -------------------------------
  end_time = clock();
  printTime(start_time,end_time, "MTV Assembler");
}

int main(int argc, char *argv[])
{
  int col,row;
  Vector x,y;
  Matrix A;

  // ------------------------------------
  // Initialize the matrix and the vector
  // ------------------------------------
  printf("Setting up Matrix and vector\n");
  for(row = 0; row &lt; N_COLOUR; row++) {
    for(col = 0; col &lt; N_COLOUR; col++) {
      A(RE,col,row) = row+1;
      A(IM,col,row) = (float)0;
      x(RE,row)   = row+1;
      x(IM,row)   = (float)0;
      y(RE,row)   = (float)0;
      y(IM,row)   = (float)0;
    }
  }
  // -----------------------------
  // Load MatVec routine into CRAM
  // -----------------------------
  printf("Loading Matrix Vector Routine into CRAM\n");
  loadMatVecMultIntoCRAM();


  // --------------------------------------
  // Call to matrix multiplication routine:
  //
  // y &lt;- A x
  // --------------------------------------
  printf("Calling Mat Vec routine \n");
  matVecMultMtv(y.data(), A.data(), x.data());

  // --------------------------------------
  // Print out result
  // --------------------------------------
  for(row = 0; row &lt; N_COLOUR; row++) {
    printf("[ ( %6f, %6f ) ] \n", y(RE, row), y(IM, row));
  }
}

</pre></font>

<p>
You can find all this code in <tt>/qcdsp/sfw/qos5.3.3/example/optimise3</tt>.
On running I get the following output:

<pre>
Setting up Matrix and vector
Loading Matrix Vector Routine into CRAM
Copying MatVecMult Into CRAM
Done
Calling Mat Vec routine 
MTV Assembler: Start Time  303414
MTV Assembler: End   Time  303587
MTV Assembler: Difference  173 cycles
[ ( 6.000000, 0.000000 ) ] 
[ ( 12.000000, 0.000000 ) ] 
[ ( 18.000000, 0.000000 ) ] 

</pre>

<p>
 <h2><a name="tth_sEc7.6">
7.6</a>&nbsp;&nbsp;Summary</h2>
In this chapter we have reviewed the basic means of performing 
single procesor optimisations on the QCDSP. These can be made
by making use of the 2Kword on chip RAM and the circular buffer.

<p>
The circuler buffer is considered as an advanced topic and is left
for future addenda/revisions of this document. We have then detailed
the use of the CRAM and presented a three stage process to optimisation:

<ol type="1">
<li>Step 1&nbsp; Write the code as usual</li>

<li>Step 2&nbsp; Relocate compute intensive (C++) routine to CRAM</li>

<li>Step 3&nbsp; Replace compute intensive routine in CRAM with</li>
</ol>
assembler routine taking advantage of the ability to execute two 
instructions per cycle.

<p>

<h3>Overlay Summary</h3>
When defining an overlay, define its origin in the <tt>allocate</tt> statement
of the linker control file to be in the CRAM. It is useful to define
a compiler symbol for this origin. Since one is now  dealing with 
virtual addresses that are different from physical addresses, one must
include a <tt>physical</tt> statement at the end of the linker control file
to specify the layout of sections. Here it is possible to define
symbols pointing to the start and end of the overlay which will facilitate
its copying to the CRAM.

<p>
Overlay code is module based. A module unit is a <b>.toff</b> or a <tt>.coff</tt>
file. Alternatively an archive <b>.olb</b> file can contain a collection of 
modules. Hence code for different overlays must reside in different files.

<p>
Overlays must be explicitly copied to CRAM before used. 

<p>

<h3>Linker symbols and C++ Files</h3>
Linker symbols  can be made visible to C++
program files through the use of the <tt>extern "C" void symbol()</tt> statements,
This stops the compiler from encoding <tt>symbol</tt>. Linker symbols need
to be defined with a leading underscore, but this underscore is dropped
when dealing with them in C++ files.

<p>

<h3>Assembly Summary</h3>
Assembly coded  overlays work the same way as C++ overlays, except that the 
object files are assembled using the <tt>asm30</tt> assembler rather than 
compiled. The <tt>asm30</tt> assembler outputs object files in the Texas Intsruments COFF format (<tt>.obj</tt> suffix). Such files should automatically be
recognised by <tt>tcpp</tt> and dealt with appropriately. One may however
at one's discretion prepend them with <tt>-fi</tt> flag which forces <tt>tcpp</tt> 
to treat them as COFF object files.

<p>
<hr /><h3>Footnotes:</h3>

<p>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Currently Bob Mawhinney, email <tt>rdm@phys.columbia.edu</tt>
<p>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>Multiple Instruction Multiple Data
<p>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>Single Program Multiple Data
<p>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>if you haven't yet please do so now
<p>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>Freely available at <tt>http://cliodhna.cop.uop.edu/&#126;hetrick/milc/</tt>. You could do us a great
service if you ported it to the QCDSP...
<p>
<a name="tthFtNtAAG"></a><a href="#tthFrefAAG"><sup>6</sup></a>The actual operation and type of
data are specified using tags such as <tt>MPI_INT</tt> and <tt>MPI_SUM</tt>
for example
<p>
<a name="tthFtNtAAH"></a><a href="#tthFrefAAH"><sup>7</sup></a>The wordsize of the DSP is 32bits. The physical
size of a word in DRAM is 40bits of which 8 are reserved for error
correction. Hence 0.5Mwords corresponds to 2Mb of useable
memory. However since everything is word size for the DSP from
characters to floating point numbers it makes more sense to discuss
memory in terms of words than bytes.
<p>
<a name="tthFtNtAAI"></a><a href="#tthFrefAAI"><sup>8</sup></a>See the Gauge Connection Web site <tt>http://qcd.nersc.gov</tt>
<p>
<a name="tthFtNtAAJ"></a><a href="#tthFrefAAJ"><sup>9</sup></a><tt>
strtol</tt> is a very useful function. For details look at the <tt>man</tt>
page in section 3 of the manual
<p>
<a name="tthFtNtABA"></a><a href="#tthFrefABA"><sup>10</sup></a>This product is no longer supported by Texas Instruments but it may be ``borrowed'' from the 
Columbia University Group
<p>
<a name="tthFtNtABB"></a><a href="#tthFrefABB"><sup>11</sup></a>One of my favourite books explaining all this stuff used to be Graham Glass published by Prentice-Hall. This is now in a second edition. I do not know how good the second edition is
<p>
<a name="tthFtNtABC"></a><a href="#tthFrefABC"><sup>12</sup></a>We will
ignore setup costs, although they are important for the case of a single
matrix vector multiply, they will become negligible when the operation
has to be performed for many matrices
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 2.92.<br />On  4 Jul 2002, 16:38.</small>
</body></html>

